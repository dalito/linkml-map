{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LinkML-Map LinkML Map is a framework for specifying and executing mappings between data models. Features: YAML-based lightweight syntax Python library for executing mappings on data files Ability to compile to other frameworks (SQL/DuckDB) Derivation of target (implicit) schemas, allowing easy customization of data models ( profiling ) Simple YAML dictionaries for simple mappings Automatic unit conversion Use of subset of Python to specify complex mappings Visualizations of mappings Mappings are reversible (provided all expressions used are reversible) Compatibility with SSSOM This documentation are available at: linkml.io/linkml-map/ Status: The transformation data model is not yet fully stable, and may be subject to change. Not all parts of the model are implemented in the reference Python framework. Basic idea Given the LinkML schema id : https://w3id.org/linkml/examples/personinfo name : personinfo prefixes : linkml : https://w3id.org/linkml/ personinfo : https://w3id.org/linkml/examples/personinfo imports : - linkml:types default_range : string default_prefix : personinfo classes : Person : attributes : id : given_name : family_name : aliases : multivalued : true height_in_cm : range : float unit : ucum_code : cm age_in_years : range : integer and an object that conforms to it, e.g.: given_name : Jane family_name : Doe height_in_cm : 172.0 age_in_years : 33 aliases : [ Janey , Janie ] Define a mapping in YAML: class_derivations : Individual : populated_from : Person slot_derivations : name : expr : \"{given_name} + ' ' + {family_name}\" description : Concatenating given and family names note this is a bad assumption for names in general, this is just for demonstration height_in_meters : populated_from : height_in_cm unit_conversion : target_unit : m aliases : populated_from : aliases stringification : delimiter : '|' The schema mapping (aka TransformationSpecification ) specifies how to transform the data model. The schema mapping is a collection of one or more ClassDerivation objects, which themselves consist of one or more SlotDerivation objects. Transform the data: linkml-map map-data -T tr.yaml -s schema.yaml my-data.yaml Giving: name : Jane Doe height_in_meters : 1.72 aliases : Janey|Janie Installation and usage Installation and command line usage: pip [ x ] install linkml-map cd tests/input/examples/personinfo_basic linkml-map map-data \\ -T transform/personinfo-to-agent.transform.yaml \\ -s source/personinfo.yaml \\ data/Container-001.yaml \\ -o output/Translated-001.yaml The command line has subcommands for: map-data - map data from a source schema to a target schema derive-schema - derive a target schema from a source schema and a mapping invert - reverses a mapping compile - compiles a mapping to another framework markdown - for generating static sites graphviz - for generating visualizations python - (partial) forthcoming: r2rml , ... Details This repo contains both: A data model for a data model transformation language A reference python implementation The transformation language is specified in terms of LinkML schemas. It is intended to be a ployglot transformation language, used for specifying how to map data models independent of underlying representation (TSVs, JSON/YAML, RDF, SQL Database, ...). Use cases include: ETL and mapping from one data model to another Database migrations (one version of a schema to another) Creating \"profiles\" Specifying mappings between different serializations of a model (e.g. OO to Relational) Mapping between normalized/non-redundant forms and denormalized/query-optimized forms Data Model The data model for transformations mirrors the data model for schemas: A top level TransformationSpecification class contains: Zero or more ClassDerivation objects, specifying how to map to a class, containing Zero or more SlotDerivation objects, specifying how to map to a slot Zero or more EnumDerivation objects, specifying how to map to an enum See the generated docs Conformance Suite The Maps conformance suite contains a collection of tests for each feature of the language. See: Compliance Suite Running the code linkml-map --help Usage: linkml-map [ OPTIONS ] COMMAND [ ARGS ] ... CLI for linkml-map. Options: -v, --verbose -q, --quiet TEXT --help Show this message and exit. Commands: derive-schema Derive a schema from a source schema and a mapping. map-data Map data in a source schema using a transformation. map-data Transforms (maps) data from a source schema to a target schema. This could range from a simple data dictionary mapping through to a complex mappings. cd tests/input/examples/personinfo_basic linkml-map map-data -T transform/personinfo-to-agent.transform.yaml -s source/personinfo.yaml data/Container-001.yaml derive-schema cd tests/input/examples/personinfo_basic linkml-map derive-schema -T transform/personinfo-to-agent.transform.yaml source/personinfo.yaml","title":"Index"},{"location":"#linkml-map","text":"LinkML Map is a framework for specifying and executing mappings between data models. Features: YAML-based lightweight syntax Python library for executing mappings on data files Ability to compile to other frameworks (SQL/DuckDB) Derivation of target (implicit) schemas, allowing easy customization of data models ( profiling ) Simple YAML dictionaries for simple mappings Automatic unit conversion Use of subset of Python to specify complex mappings Visualizations of mappings Mappings are reversible (provided all expressions used are reversible) Compatibility with SSSOM This documentation are available at: linkml.io/linkml-map/ Status: The transformation data model is not yet fully stable, and may be subject to change. Not all parts of the model are implemented in the reference Python framework.","title":"LinkML-Map"},{"location":"#basic-idea","text":"Given the LinkML schema id : https://w3id.org/linkml/examples/personinfo name : personinfo prefixes : linkml : https://w3id.org/linkml/ personinfo : https://w3id.org/linkml/examples/personinfo imports : - linkml:types default_range : string default_prefix : personinfo classes : Person : attributes : id : given_name : family_name : aliases : multivalued : true height_in_cm : range : float unit : ucum_code : cm age_in_years : range : integer and an object that conforms to it, e.g.: given_name : Jane family_name : Doe height_in_cm : 172.0 age_in_years : 33 aliases : [ Janey , Janie ] Define a mapping in YAML: class_derivations : Individual : populated_from : Person slot_derivations : name : expr : \"{given_name} + ' ' + {family_name}\" description : Concatenating given and family names note this is a bad assumption for names in general, this is just for demonstration height_in_meters : populated_from : height_in_cm unit_conversion : target_unit : m aliases : populated_from : aliases stringification : delimiter : '|' The schema mapping (aka TransformationSpecification ) specifies how to transform the data model. The schema mapping is a collection of one or more ClassDerivation objects, which themselves consist of one or more SlotDerivation objects. Transform the data: linkml-map map-data -T tr.yaml -s schema.yaml my-data.yaml Giving: name : Jane Doe height_in_meters : 1.72 aliases : Janey|Janie","title":"Basic idea"},{"location":"#installation-and-usage","text":"Installation and command line usage: pip [ x ] install linkml-map cd tests/input/examples/personinfo_basic linkml-map map-data \\ -T transform/personinfo-to-agent.transform.yaml \\ -s source/personinfo.yaml \\ data/Container-001.yaml \\ -o output/Translated-001.yaml The command line has subcommands for: map-data - map data from a source schema to a target schema derive-schema - derive a target schema from a source schema and a mapping invert - reverses a mapping compile - compiles a mapping to another framework markdown - for generating static sites graphviz - for generating visualizations python - (partial) forthcoming: r2rml , ...","title":"Installation and usage"},{"location":"#details","text":"This repo contains both: A data model for a data model transformation language A reference python implementation The transformation language is specified in terms of LinkML schemas. It is intended to be a ployglot transformation language, used for specifying how to map data models independent of underlying representation (TSVs, JSON/YAML, RDF, SQL Database, ...). Use cases include: ETL and mapping from one data model to another Database migrations (one version of a schema to another) Creating \"profiles\" Specifying mappings between different serializations of a model (e.g. OO to Relational) Mapping between normalized/non-redundant forms and denormalized/query-optimized forms","title":"Details"},{"location":"#data-model","text":"The data model for transformations mirrors the data model for schemas: A top level TransformationSpecification class contains: Zero or more ClassDerivation objects, specifying how to map to a class, containing Zero or more SlotDerivation objects, specifying how to map to a slot Zero or more EnumDerivation objects, specifying how to map to an enum See the generated docs","title":"Data Model"},{"location":"#conformance-suite","text":"The Maps conformance suite contains a collection of tests for each feature of the language. See: Compliance Suite","title":"Conformance Suite"},{"location":"#running-the-code","text":"linkml-map --help Usage: linkml-map [ OPTIONS ] COMMAND [ ARGS ] ... CLI for linkml-map. Options: -v, --verbose -q, --quiet TEXT --help Show this message and exit. Commands: derive-schema Derive a schema from a source schema and a mapping. map-data Map data in a source schema using a transformation.","title":"Running the code"},{"location":"#map-data","text":"Transforms (maps) data from a source schema to a target schema. This could range from a simple data dictionary mapping through to a complex mappings. cd tests/input/examples/personinfo_basic linkml-map map-data -T transform/personinfo-to-agent.transform.yaml -s source/personinfo.yaml data/Container-001.yaml","title":"map-data"},{"location":"#derive-schema","text":"cd tests/input/examples/personinfo_basic linkml-map derive-schema -T transform/personinfo-to-agent.transform.yaml source/personinfo.yaml","title":"derive-schema"},{"location":"faq/","text":"FAQ Why another framework? There are a number of excellent frameworks for performing mapping and data transformations. The LinkML Transformer framework was born out of a need for a framework that: was not inherently tied to: a particular serialization format (e.g. RDF, JSON, ...) a particular programming language (e.g. Python, Java, ...) a particular database system or database language (e.g. PostgreSQL or SQL or SPARQL) not tied to a particular kind of transformation (e.g. ORM or Tables to RDF) was a natural fit for the LinkML data modeling framework was declarative and easy to perform machine reasoning over is simple for simple use cases In its current state, this framework is less powerful and expressive than many other frameworks or methodologies for performing transformations. If you need to perform complex data transformations, you might be better off using an expressive query language like SPARQL or SQL, or even just coding transformations directly in a programming language or library like Python or Pandas (but note that even for the coding use case, the LinkML Transformer framework can be useful as a standard way of documenting transformations). Currently the main use case for this framework is mostly isomorphic transformations, with lightweight manipulations. These lend themselves well to a declarative framework. Uses cases that are a particularly good fit involve mapping between data-dictionary like standards, with large numbers of metadata elements, where these elements can often be mapped one-to-one, or with simple manipulations (e.g. unit conversions). The origins lie partly in the SSSOM standard, which is intended as an ultra-simple way of specifying precise mappings between entities (e.g. schema.org Person is the same as DBPedia person). We observed that many people wanted to extend the language to perform more complex mappings. To address this, we help a workshop at the Biocuration conference in Padua, Italy in 2022. Discussion SSSOM paper SSSOM Update 2023 SSSOM Complex Mappings Workshop 2023 Mapping Data Structures: Challenges and Approaches","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#why-another-framework","text":"There are a number of excellent frameworks for performing mapping and data transformations. The LinkML Transformer framework was born out of a need for a framework that: was not inherently tied to: a particular serialization format (e.g. RDF, JSON, ...) a particular programming language (e.g. Python, Java, ...) a particular database system or database language (e.g. PostgreSQL or SQL or SPARQL) not tied to a particular kind of transformation (e.g. ORM or Tables to RDF) was a natural fit for the LinkML data modeling framework was declarative and easy to perform machine reasoning over is simple for simple use cases In its current state, this framework is less powerful and expressive than many other frameworks or methodologies for performing transformations. If you need to perform complex data transformations, you might be better off using an expressive query language like SPARQL or SQL, or even just coding transformations directly in a programming language or library like Python or Pandas (but note that even for the coding use case, the LinkML Transformer framework can be useful as a standard way of documenting transformations). Currently the main use case for this framework is mostly isomorphic transformations, with lightweight manipulations. These lend themselves well to a declarative framework. Uses cases that are a particularly good fit involve mapping between data-dictionary like standards, with large numbers of metadata elements, where these elements can often be mapped one-to-one, or with simple manipulations (e.g. unit conversions). The origins lie partly in the SSSOM standard, which is intended as an ultra-simple way of specifying precise mappings between entities (e.g. schema.org Person is the same as DBPedia person). We observed that many people wanted to extend the language to perform more complex mappings. To address this, we help a workshop at the Biocuration conference in Padua, Italy in 2022. Discussion SSSOM paper SSSOM Update 2023 SSSOM Complex Mappings Workshop 2023 Mapping Data Structures: Challenges and Approaches","title":"Why another framework?"},{"location":"api/compiler/","text":"Compiler Package A compiler will compile a Map specification into an alternative representation Compiler (Base Class) Bases: ABC Base class for all compilers. A compiler will compile a transformation specification into an alternative representation. An example compiler would be a R2RML compiler. Note: Compilers and Importers will in general be implemented by providing mapping specifications Source code in src\\linkml_map\\compiler\\compiler.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @dataclass class Compiler ( ABC ): \"\"\" Base class for all compilers. A compiler will compile a transformation specification into an alternative representation. An example compiler would be a R2RML compiler. Note: Compilers and Importers will in general be implemented by providing mapping specifications \"\"\" source_schemaview : SchemaView = None \"\"\"A view over the schema describing the source.\"\"\" source_python_module : str = None \"\"\"The python module containing the source classes.\"\"\" target_python_module : str = None \"\"\"The python module containing the target classes.\"\"\" def compile ( self , specification : TransformationSpecification ) -> CompiledSpecification : \"\"\" Transform source object into an instance of the target class. :param specification: :return: \"\"\" s = self . _compile_header ( specification ) for chunk in self . _compile_iterator ( specification ): s += chunk return CompiledSpecification ( serialization = s ) def _compile_header ( self , specification : TransformationSpecification ) -> str : return \"\" def _compile_iterator ( self , specification : TransformationSpecification ) -> Iterator [ str ]: raise NotImplementedError def derived_target_schemaview ( self , specification : TransformationSpecification ): \"\"\" Returns a view over the target schema, including any derived classes. \"\"\" mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) return SchemaView ( yaml_dumper . dumps ( mapper . derive_schema ( specification ))) source_python_module : str = None class-attribute instance-attribute The python module containing the source classes. source_schemaview : SchemaView = None class-attribute instance-attribute A view over the schema describing the source. target_python_module : str = None class-attribute instance-attribute The python module containing the target classes. compile ( specification ) Transform source object into an instance of the target class. :param specification: :return: Source code in src\\linkml_map\\compiler\\compiler.py 65 66 67 68 69 70 71 72 73 74 75 def compile ( self , specification : TransformationSpecification ) -> CompiledSpecification : \"\"\" Transform source object into an instance of the target class. :param specification: :return: \"\"\" s = self . _compile_header ( specification ) for chunk in self . _compile_iterator ( specification ): s += chunk return CompiledSpecification ( serialization = s ) derived_target_schemaview ( specification ) Returns a view over the target schema, including any derived classes. Source code in src\\linkml_map\\compiler\\compiler.py 83 84 85 86 87 88 def derived_target_schemaview ( self , specification : TransformationSpecification ): \"\"\" Returns a view over the target schema, including any derived classes. \"\"\" mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) return SchemaView ( yaml_dumper . dumps ( mapper . derive_schema ( specification ))) Python Compiler Bases: Compiler Compiles a Transformation Specification to Python code. Source code in src\\linkml_map\\compiler\\python_compiler.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @dataclass class PythonCompiler ( Compiler ): \"\"\" Compiles a Transformation Specification to Python code. \"\"\" def _compile_header ( self , specification : TransformationSpecification ) -> str : s = \"\" if self . source_python_module : s += f \"import { self . source_python_module } as src \\n \" if self . target_python_module : s += f \"import { self . target_python_module } as tgt \\n \" s += \" \\n NULL = None \\n\\n \" return s def _compile_iterator ( self , specification : TransformationSpecification ) -> Iterator [ str ]: specification = deepcopy ( specification ) induce_missing_values ( specification , self . source_schemaview ) for cd in specification . class_derivations . values (): yield from self . _compiled_class_derivations_iter ( cd ) def _compiled_class_derivations_iter ( self , cd : ClassDerivation ) -> Iterator [ str ]: sv = self . source_schemaview if cd . populated_from : populated_from = cd . populated_from else : populated_from = cd . name if populated_from not in sv . all_classes (): return induced_slots = { s . name : s for s in sv . class_induced_slots ( populated_from )} t = Template ( CD_TEMPLATE ) yield t . render ( cd = cd , source_module = \"src\" , target_module = \"tgt\" , induced_slots = induced_slots , schemaview = sv , source_slots = sv . class_induced_slots ( populated_from ), ) Markdown Compiler Bases: J2BasedCompiler Compiles a Transformation Specification to Markdown. Source code in src\\linkml_map\\compiler\\markdown_compiler.py 6 7 8 9 10 11 12 @dataclass class MarkdownCompiler ( J2BasedCompiler ): \"\"\" Compiles a Transformation Specification to Markdown. \"\"\" template_name : str = \"markdown.j2\" Graphviz Compiler Bases: Compiler Compiles a Transformation Specification to GraphViz. Source code in src\\linkml_map\\compiler\\graphviz_compiler.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 class GraphvizCompiler ( Compiler ): \"\"\" Compiles a Transformation Specification to GraphViz. \"\"\" def compile ( self , specification : TransformationSpecification , elements : Optional [ List [ str ]] = None ) -> GraphvizObject : dg = Digraph ( comment = \"UML Class Diagram\" , format = \"png\" ) dg . attr ( rankdir = \"LR\" ) # Set graph direction from left to right target_schemaview = self . derived_target_schemaview ( specification ) source_schemaview = self . source_schemaview records = [] records += self . add_records ( source_schemaview , \"source\" ) records += self . add_records ( target_schemaview , \"target\" ) for record in records : dg . node ( record . id , str ( record ), shape = \"plaintext\" ) # Define the class nodes with fields in UML format using HTML-like labels # for precise control over the stacking of the fields for target_cn , cd in specification . class_derivations . items (): source_cn = cd . populated_from if source_cn is None : source_cn = cd . name if elements is not None and target_cn not in elements : continue source_record = Record ( name = source_cn , source = \"source\" ) target_record = Record ( name = target_cn , source = \"target\" ) for sd in cd . slot_derivations . values (): target_slot = sd . name target_id = f \" { target_record . id } : { target_slot } \" source_slot = sd . populated_from if source_slot : source_id = f \" { source_record . id } : { source_slot } \" dg . edge ( source_id , target_id ) elif sd . expr : # TODO: do this in a less hacky way tokens = re . findall ( r \"\\w+\" , sd . expr ) for token in tokens : if token not in source_schemaview . all_slots (): continue dg . edge ( f \" { source_record . id } : { token } \" , target_id , style = \"dashed\" ) return GraphvizObject ( digraph = dg , serialization = dg . source ) def add_records ( self , schemaview : SchemaView , source : str ) -> List [ Record ]: records = [] for cn in schemaview . all_classes (): record = Record ( name = cn , source = source ) for induced_slot in schemaview . class_induced_slots ( cn ): record . fields . append (( induced_slot . name , induced_slot . range )) records . append ( record ) return records","title":"Compiler"},{"location":"api/compiler/#compiler-package","text":"A compiler will compile a Map specification into an alternative representation","title":"Compiler Package"},{"location":"api/compiler/#compiler-base-class","text":"Bases: ABC Base class for all compilers. A compiler will compile a transformation specification into an alternative representation. An example compiler would be a R2RML compiler. Note: Compilers and Importers will in general be implemented by providing mapping specifications Source code in src\\linkml_map\\compiler\\compiler.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @dataclass class Compiler ( ABC ): \"\"\" Base class for all compilers. A compiler will compile a transformation specification into an alternative representation. An example compiler would be a R2RML compiler. Note: Compilers and Importers will in general be implemented by providing mapping specifications \"\"\" source_schemaview : SchemaView = None \"\"\"A view over the schema describing the source.\"\"\" source_python_module : str = None \"\"\"The python module containing the source classes.\"\"\" target_python_module : str = None \"\"\"The python module containing the target classes.\"\"\" def compile ( self , specification : TransformationSpecification ) -> CompiledSpecification : \"\"\" Transform source object into an instance of the target class. :param specification: :return: \"\"\" s = self . _compile_header ( specification ) for chunk in self . _compile_iterator ( specification ): s += chunk return CompiledSpecification ( serialization = s ) def _compile_header ( self , specification : TransformationSpecification ) -> str : return \"\" def _compile_iterator ( self , specification : TransformationSpecification ) -> Iterator [ str ]: raise NotImplementedError def derived_target_schemaview ( self , specification : TransformationSpecification ): \"\"\" Returns a view over the target schema, including any derived classes. \"\"\" mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) return SchemaView ( yaml_dumper . dumps ( mapper . derive_schema ( specification )))","title":"Compiler (Base Class)"},{"location":"api/compiler/#linkml_map.compiler.compiler.Compiler.source_python_module","text":"The python module containing the source classes.","title":"source_python_module"},{"location":"api/compiler/#linkml_map.compiler.compiler.Compiler.source_schemaview","text":"A view over the schema describing the source.","title":"source_schemaview"},{"location":"api/compiler/#linkml_map.compiler.compiler.Compiler.target_python_module","text":"The python module containing the target classes.","title":"target_python_module"},{"location":"api/compiler/#linkml_map.compiler.compiler.Compiler.compile","text":"Transform source object into an instance of the target class. :param specification: :return: Source code in src\\linkml_map\\compiler\\compiler.py 65 66 67 68 69 70 71 72 73 74 75 def compile ( self , specification : TransformationSpecification ) -> CompiledSpecification : \"\"\" Transform source object into an instance of the target class. :param specification: :return: \"\"\" s = self . _compile_header ( specification ) for chunk in self . _compile_iterator ( specification ): s += chunk return CompiledSpecification ( serialization = s )","title":"compile"},{"location":"api/compiler/#linkml_map.compiler.compiler.Compiler.derived_target_schemaview","text":"Returns a view over the target schema, including any derived classes. Source code in src\\linkml_map\\compiler\\compiler.py 83 84 85 86 87 88 def derived_target_schemaview ( self , specification : TransformationSpecification ): \"\"\" Returns a view over the target schema, including any derived classes. \"\"\" mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) return SchemaView ( yaml_dumper . dumps ( mapper . derive_schema ( specification )))","title":"derived_target_schemaview"},{"location":"api/compiler/#python-compiler","text":"Bases: Compiler Compiles a Transformation Specification to Python code. Source code in src\\linkml_map\\compiler\\python_compiler.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @dataclass class PythonCompiler ( Compiler ): \"\"\" Compiles a Transformation Specification to Python code. \"\"\" def _compile_header ( self , specification : TransformationSpecification ) -> str : s = \"\" if self . source_python_module : s += f \"import { self . source_python_module } as src \\n \" if self . target_python_module : s += f \"import { self . target_python_module } as tgt \\n \" s += \" \\n NULL = None \\n\\n \" return s def _compile_iterator ( self , specification : TransformationSpecification ) -> Iterator [ str ]: specification = deepcopy ( specification ) induce_missing_values ( specification , self . source_schemaview ) for cd in specification . class_derivations . values (): yield from self . _compiled_class_derivations_iter ( cd ) def _compiled_class_derivations_iter ( self , cd : ClassDerivation ) -> Iterator [ str ]: sv = self . source_schemaview if cd . populated_from : populated_from = cd . populated_from else : populated_from = cd . name if populated_from not in sv . all_classes (): return induced_slots = { s . name : s for s in sv . class_induced_slots ( populated_from )} t = Template ( CD_TEMPLATE ) yield t . render ( cd = cd , source_module = \"src\" , target_module = \"tgt\" , induced_slots = induced_slots , schemaview = sv , source_slots = sv . class_induced_slots ( populated_from ), )","title":"Python Compiler"},{"location":"api/compiler/#markdown-compiler","text":"Bases: J2BasedCompiler Compiles a Transformation Specification to Markdown. Source code in src\\linkml_map\\compiler\\markdown_compiler.py 6 7 8 9 10 11 12 @dataclass class MarkdownCompiler ( J2BasedCompiler ): \"\"\" Compiles a Transformation Specification to Markdown. \"\"\" template_name : str = \"markdown.j2\"","title":"Markdown Compiler"},{"location":"api/compiler/#graphviz-compiler","text":"Bases: Compiler Compiles a Transformation Specification to GraphViz. Source code in src\\linkml_map\\compiler\\graphviz_compiler.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 class GraphvizCompiler ( Compiler ): \"\"\" Compiles a Transformation Specification to GraphViz. \"\"\" def compile ( self , specification : TransformationSpecification , elements : Optional [ List [ str ]] = None ) -> GraphvizObject : dg = Digraph ( comment = \"UML Class Diagram\" , format = \"png\" ) dg . attr ( rankdir = \"LR\" ) # Set graph direction from left to right target_schemaview = self . derived_target_schemaview ( specification ) source_schemaview = self . source_schemaview records = [] records += self . add_records ( source_schemaview , \"source\" ) records += self . add_records ( target_schemaview , \"target\" ) for record in records : dg . node ( record . id , str ( record ), shape = \"plaintext\" ) # Define the class nodes with fields in UML format using HTML-like labels # for precise control over the stacking of the fields for target_cn , cd in specification . class_derivations . items (): source_cn = cd . populated_from if source_cn is None : source_cn = cd . name if elements is not None and target_cn not in elements : continue source_record = Record ( name = source_cn , source = \"source\" ) target_record = Record ( name = target_cn , source = \"target\" ) for sd in cd . slot_derivations . values (): target_slot = sd . name target_id = f \" { target_record . id } : { target_slot } \" source_slot = sd . populated_from if source_slot : source_id = f \" { source_record . id } : { source_slot } \" dg . edge ( source_id , target_id ) elif sd . expr : # TODO: do this in a less hacky way tokens = re . findall ( r \"\\w+\" , sd . expr ) for token in tokens : if token not in source_schemaview . all_slots (): continue dg . edge ( f \" { source_record . id } : { token } \" , target_id , style = \"dashed\" ) return GraphvizObject ( digraph = dg , serialization = dg . source ) def add_records ( self , schemaview : SchemaView , source : str ) -> List [ Record ]: records = [] for cn in schemaview . all_classes (): record = Record ( name = cn , source = source ) for induced_slot in schemaview . class_induced_slots ( cn ): record . fields . append (( induced_slot . name , induced_slot . range )) records . append ( record ) return records","title":"Graphviz Compiler"},{"location":"api/functions/","text":"Functions Package Unit Conversion Basic unit conversion functions. Currently only native pint units or UCUM units are supported. For UCUM, the ucumvert library is used to convert UCUM units to pint units, see <https://github.com/dalito/ucumvert> _. DimensionalityError Bases: Exception Raised when a unit conversion cannot be performed. Note: equivalent to the pint error, but the pint dependency is optional Source code in src\\linkml_map\\functions\\unit_conversion.py 47 48 49 50 51 52 53 class DimensionalityError ( Exception ): \"\"\" Raised when a unit conversion cannot be performed. Note: equivalent to the pint error, but the pint dependency is optional \"\"\" QuantitySyntaxError Bases: Exception Raised when a quantity cannot be parsed. Source code in src\\linkml_map\\functions\\unit_conversion.py 41 42 43 44 class QuantitySyntaxError ( Exception ): \"\"\" Raised when a quantity cannot be parsed. \"\"\" UndefinedUnitError Bases: Exception Raised when a unit is not defined. Note: equivalent to the pint error, but the pint dependency is optional Source code in src\\linkml_map\\functions\\unit_conversion.py 32 33 34 35 36 37 38 class UndefinedUnitError ( Exception ): \"\"\" Raised when a unit is not defined. Note: equivalent to the pint error, but the pint dependency is optional \"\"\" UnitSystem Bases: str , Enum Enumeration of supported unit systems. Source code in src\\linkml_map\\functions\\unit_conversion.py 19 20 21 22 23 24 class UnitSystem ( str , Enum ): \"\"\"Enumeration of supported unit systems.\"\"\" UCUM = \"ucum\" IEC61360 = \"iec61360\" SI = \"SI\" convert_units ( magnitude , from_unit , to_unit , system = None ) Convert a quantity between units. convert_units(1, \"m\", \"cm\") 100.0 convert_units(1, \"m\", \"cm\", system=UnitSystem.UCUM) 100.0 convert_units(1, \"m\", \"cm\", system=UnitSystem.SI) 100.0 convert_units(1.0, \"hectare\", \"m^2\", system=UnitSystem.SI) 10000.0 convert_units(1.0, \"hectare\", \"m ** 2\", system=UnitSystem.SI) 10000.0 convert_units(1.0, \"hectare\", \"m ** 2\", system=None) 10000.0 convert_units(1.0, \"km2\", \"m2\", system=UnitSystem.UCUM) 1000000.0 :param magnitude: :param from_unit: :param to_unit: :return: converted magnitude Source code in src\\linkml_map\\functions\\unit_conversion.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def convert_units ( magnitude : float , from_unit : str , to_unit : str , system : Optional [ UnitSystem ] = None ): \"\"\" Convert a quantity between units. >>> convert_units(1, \"m\", \"cm\") 100.0 >>> convert_units(1, \"m\", \"cm\", system=UnitSystem.UCUM) 100.0 >>> convert_units(1, \"m\", \"cm\", system=UnitSystem.SI) 100.0 >>> convert_units(1.0, \"hectare\", \"m^2\", system=UnitSystem.SI) 10000.0 >>> convert_units(1.0, \"hectare\", \"m ** 2\", system=UnitSystem.SI) 10000.0 >>> convert_units(1.0, \"hectare\", \"m ** 2\", system=None) 10000.0 >>> convert_units(1.0, \"km2\", \"m2\", system=UnitSystem.UCUM) 1000000.0 :param magnitude: :param from_unit: :param to_unit: :return: converted magnitude \"\"\" import pint ureg : pint . UnitRegistry = get_unit_registry ( system ) from_unit = normalize_unit ( from_unit , system ) to_unit = normalize_unit ( to_unit , system ) try : from_unit_q = ureg . parse_units ( from_unit ) except lark . exceptions . UnexpectedCharacters : raise UndefinedUnitError ( f \"Cannot parse unit: { from_unit } \" ) except pint . errors . UndefinedUnitError : raise UndefinedUnitError ( f \"Unknown source unit: { from_unit } \" ) quantity = magnitude * from_unit_q try : return quantity . to ( to_unit ) . magnitude except pint . errors . UndefinedUnitError : raise UndefinedUnitError ( f \"Unknown target unit: { from_unit } \" ) except pint . errors . DimensionalityError : raise DimensionalityError ( f \"Cannot convert from { from_unit } to { to_unit } \" ) get_unit_registry ( system = None ) cached Get a unit registry. ureg = get_unit_registry(UnitSystem.UCUM) ureg.from_ucum(\"m/s2.kg\") str( ) '1.0 kilogram * meter / second ** 2' ureg.from_ucum(\"m[H2O]{35Cel}\") # UCUM code with annotation .to(\"mbar\") ureg(\"degC\") # a standard pint unit ureg.from_ucum(\"g/m2\") _.to(ureg.from_ucum(\"kg/m2\")) ureg.from_ucum(\"nmol/mmol{Cre}\") sireg = get_unit_registry(UnitSystem.SI) sireg(\"degC\") sireg(\"ha\") :param system: currently only supported values are None or UnitSystem.UCUM :return: Source code in src\\linkml_map\\functions\\unit_conversion.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 @lru_cache () def get_unit_registry ( system : Optional [ UnitSystem ] = None ) -> Any : \"\"\" Get a unit registry. >>> ureg = get_unit_registry(UnitSystem.UCUM) >>> ureg.from_ucum(\"m/s2.kg\") <Quantity(1.0, 'meter * kilogram / second ** 2')> >>> str(_) '1.0 kilogram * meter / second ** 2' >>> ureg.from_ucum(\"m[H2O]{35Cel}\") # UCUM code with annotation <Quantity(1, 'm_H2O')> >>> _.to(\"mbar\") <Quantity(98.0665, 'millibar')> >>> ureg(\"degC\") # a standard pint unit <Quantity(1, 'degree_Celsius')> >>> ureg.from_ucum(\"g/m2\") <Quantity(1.0, 'gram / meter ** 2')> >>> _.to(ureg.from_ucum(\"kg/m2\")) <Quantity(0.001, 'kilogram / meter ** 2')> >>> ureg.from_ucum(\"nmol/mmol{Cre}\") <Quantity(1.0, 'nanomole / millimole')> >>> sireg = get_unit_registry(UnitSystem.SI) >>> sireg(\"degC\") <Quantity(1, 'degree_Celsius')> >>> sireg(\"ha\") <Quantity(1, 'hectare')> :param system: currently only supported values are None or UnitSystem.UCUM :return: \"\"\" import pint ureg = pint . UnitRegistry () if not system : return ureg if system in REGISTRIES : return REGISTRIES [ system ] if system . value in dir ( ureg . sys ): ureg . default_system = system . value return ureg raise NotImplementedError ( f \"Unknown unit system: { system } \" )","title":"Functions"},{"location":"api/functions/#functions-package","text":"","title":"Functions Package"},{"location":"api/functions/#unit-conversion","text":"Basic unit conversion functions. Currently only native pint units or UCUM units are supported. For UCUM, the ucumvert library is used to convert UCUM units to pint units, see <https://github.com/dalito/ucumvert> _.","title":"Unit Conversion"},{"location":"api/functions/#linkml_map.functions.unit_conversion.DimensionalityError","text":"Bases: Exception Raised when a unit conversion cannot be performed. Note: equivalent to the pint error, but the pint dependency is optional Source code in src\\linkml_map\\functions\\unit_conversion.py 47 48 49 50 51 52 53 class DimensionalityError ( Exception ): \"\"\" Raised when a unit conversion cannot be performed. Note: equivalent to the pint error, but the pint dependency is optional \"\"\"","title":"DimensionalityError"},{"location":"api/functions/#linkml_map.functions.unit_conversion.QuantitySyntaxError","text":"Bases: Exception Raised when a quantity cannot be parsed. Source code in src\\linkml_map\\functions\\unit_conversion.py 41 42 43 44 class QuantitySyntaxError ( Exception ): \"\"\" Raised when a quantity cannot be parsed. \"\"\"","title":"QuantitySyntaxError"},{"location":"api/functions/#linkml_map.functions.unit_conversion.UndefinedUnitError","text":"Bases: Exception Raised when a unit is not defined. Note: equivalent to the pint error, but the pint dependency is optional Source code in src\\linkml_map\\functions\\unit_conversion.py 32 33 34 35 36 37 38 class UndefinedUnitError ( Exception ): \"\"\" Raised when a unit is not defined. Note: equivalent to the pint error, but the pint dependency is optional \"\"\"","title":"UndefinedUnitError"},{"location":"api/functions/#linkml_map.functions.unit_conversion.UnitSystem","text":"Bases: str , Enum Enumeration of supported unit systems. Source code in src\\linkml_map\\functions\\unit_conversion.py 19 20 21 22 23 24 class UnitSystem ( str , Enum ): \"\"\"Enumeration of supported unit systems.\"\"\" UCUM = \"ucum\" IEC61360 = \"iec61360\" SI = \"SI\"","title":"UnitSystem"},{"location":"api/functions/#linkml_map.functions.unit_conversion.convert_units","text":"Convert a quantity between units. convert_units(1, \"m\", \"cm\") 100.0 convert_units(1, \"m\", \"cm\", system=UnitSystem.UCUM) 100.0 convert_units(1, \"m\", \"cm\", system=UnitSystem.SI) 100.0 convert_units(1.0, \"hectare\", \"m^2\", system=UnitSystem.SI) 10000.0 convert_units(1.0, \"hectare\", \"m ** 2\", system=UnitSystem.SI) 10000.0 convert_units(1.0, \"hectare\", \"m ** 2\", system=None) 10000.0 convert_units(1.0, \"km2\", \"m2\", system=UnitSystem.UCUM) 1000000.0 :param magnitude: :param from_unit: :param to_unit: :return: converted magnitude Source code in src\\linkml_map\\functions\\unit_conversion.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def convert_units ( magnitude : float , from_unit : str , to_unit : str , system : Optional [ UnitSystem ] = None ): \"\"\" Convert a quantity between units. >>> convert_units(1, \"m\", \"cm\") 100.0 >>> convert_units(1, \"m\", \"cm\", system=UnitSystem.UCUM) 100.0 >>> convert_units(1, \"m\", \"cm\", system=UnitSystem.SI) 100.0 >>> convert_units(1.0, \"hectare\", \"m^2\", system=UnitSystem.SI) 10000.0 >>> convert_units(1.0, \"hectare\", \"m ** 2\", system=UnitSystem.SI) 10000.0 >>> convert_units(1.0, \"hectare\", \"m ** 2\", system=None) 10000.0 >>> convert_units(1.0, \"km2\", \"m2\", system=UnitSystem.UCUM) 1000000.0 :param magnitude: :param from_unit: :param to_unit: :return: converted magnitude \"\"\" import pint ureg : pint . UnitRegistry = get_unit_registry ( system ) from_unit = normalize_unit ( from_unit , system ) to_unit = normalize_unit ( to_unit , system ) try : from_unit_q = ureg . parse_units ( from_unit ) except lark . exceptions . UnexpectedCharacters : raise UndefinedUnitError ( f \"Cannot parse unit: { from_unit } \" ) except pint . errors . UndefinedUnitError : raise UndefinedUnitError ( f \"Unknown source unit: { from_unit } \" ) quantity = magnitude * from_unit_q try : return quantity . to ( to_unit ) . magnitude except pint . errors . UndefinedUnitError : raise UndefinedUnitError ( f \"Unknown target unit: { from_unit } \" ) except pint . errors . DimensionalityError : raise DimensionalityError ( f \"Cannot convert from { from_unit } to { to_unit } \" )","title":"convert_units"},{"location":"api/functions/#linkml_map.functions.unit_conversion.get_unit_registry","text":"Get a unit registry. ureg = get_unit_registry(UnitSystem.UCUM) ureg.from_ucum(\"m/s2.kg\") str( ) '1.0 kilogram * meter / second ** 2' ureg.from_ucum(\"m[H2O]{35Cel}\") # UCUM code with annotation .to(\"mbar\") ureg(\"degC\") # a standard pint unit ureg.from_ucum(\"g/m2\") _.to(ureg.from_ucum(\"kg/m2\")) ureg.from_ucum(\"nmol/mmol{Cre}\") sireg = get_unit_registry(UnitSystem.SI) sireg(\"degC\") sireg(\"ha\") :param system: currently only supported values are None or UnitSystem.UCUM :return: Source code in src\\linkml_map\\functions\\unit_conversion.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 @lru_cache () def get_unit_registry ( system : Optional [ UnitSystem ] = None ) -> Any : \"\"\" Get a unit registry. >>> ureg = get_unit_registry(UnitSystem.UCUM) >>> ureg.from_ucum(\"m/s2.kg\") <Quantity(1.0, 'meter * kilogram / second ** 2')> >>> str(_) '1.0 kilogram * meter / second ** 2' >>> ureg.from_ucum(\"m[H2O]{35Cel}\") # UCUM code with annotation <Quantity(1, 'm_H2O')> >>> _.to(\"mbar\") <Quantity(98.0665, 'millibar')> >>> ureg(\"degC\") # a standard pint unit <Quantity(1, 'degree_Celsius')> >>> ureg.from_ucum(\"g/m2\") <Quantity(1.0, 'gram / meter ** 2')> >>> _.to(ureg.from_ucum(\"kg/m2\")) <Quantity(0.001, 'kilogram / meter ** 2')> >>> ureg.from_ucum(\"nmol/mmol{Cre}\") <Quantity(1.0, 'nanomole / millimole')> >>> sireg = get_unit_registry(UnitSystem.SI) >>> sireg(\"degC\") <Quantity(1, 'degree_Celsius')> >>> sireg(\"ha\") <Quantity(1, 'hectare')> :param system: currently only supported values are None or UnitSystem.UCUM :return: \"\"\" import pint ureg = pint . UnitRegistry () if not system : return ureg if system in REGISTRIES : return REGISTRIES [ system ] if system . value in dir ( ureg . sys ): ureg . default_system = system . value return ureg raise NotImplementedError ( f \"Unknown unit system: { system } \" )","title":"get_unit_registry"},{"location":"api/inference/","text":"Inference Package Inference Utils induce_missing_values ( specification , source_schemaview ) Infer missing values in a specification. Currently only uses copy directives. :param specification: :param source_schemaview: :return: Source code in src\\linkml_map\\inference\\inference.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def induce_missing_values ( specification : TransformationSpecification , source_schemaview : SchemaView ): \"\"\" Infer missing values in a specification. Currently only uses copy directives. :param specification: :param source_schemaview: :return: \"\"\" for cd in specification . class_derivations . values (): if not cd . populated_from : cd . populated_from = cd . name for cd in specification . class_derivations . values (): for sd in cd . slot_derivations . values (): # for null mappings, assume that the slot is copied from the same slot in the source # TODO: decide if this is the desired behavior if sd . populated_from is None and sd . expr is None : sd . populated_from = sd . name if not sd . range : # auto-populate range field if sd . populated_from : if cd . populated_from not in source_schemaview . all_classes (): continue source_induced_slot = source_schemaview . induced_slot ( sd . populated_from , cd . populated_from ) source_induced_slot_range = source_induced_slot . range for range_cd in specification . class_derivations . values (): if range_cd . populated_from == source_induced_slot_range : sd . range = range_cd . name Inverter TransformationSpecificationInverter dataclass Invert a transformation specification. Source code in src\\linkml_map\\inference\\inverter.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @dataclass class TransformationSpecificationInverter : \"\"\" Invert a transformation specification. \"\"\" source_schemaview : SchemaView = None \"\"\"The source schema for the forward transformation. Note this becomes the target schema for the generated inverse transformation, because the goal of the inverted transformation is to map back to the original source.\"\"\" target_schemaview : SchemaView = None \"\"\"The target schema for the forward transformation. Note this becomes the source schema for the generated inverse transformation.\"\"\" strict : bool = field ( default = True ) def invert ( self , spec : TransformationSpecification ): \"\"\" Invert a transformation specification. :param spec: :return: \"\"\" logger . info ( \"Inverting specification\" ) inverted_spec = TransformationSpecification () for cd in spec . class_derivations . values (): inverted_cd = self . invert_class_derivation ( cd , spec ) inverted_spec . class_derivations [ inverted_cd . name ] = inverted_cd for ed in spec . enum_derivations . values (): inverted_ed = self . invert_enum_derivation ( ed , spec ) inverted_spec . enum_derivations [ inverted_ed . name ] = inverted_ed return inverted_spec def invert_class_derivation ( self , cd : ClassDerivation , spec : TransformationSpecification ): \"\"\" Invert a class derivation. :param cd: :param spec: :return: \"\"\" inverted_cd = ClassDerivation ( name = cd . populated_from if cd . populated_from else cd . name , populated_from = cd . name ) for sd in cd . slot_derivations . values (): inverted_sd = self . invert_slot_derivation ( sd , cd , spec ) if inverted_sd : inverted_cd . slot_derivations [ inverted_sd . name ] = inverted_sd else : if self . strict : raise NonInvertibleSpecification ( f \"Cannot invert slot derivation: { sd . name } \" ) return inverted_cd def invert_enum_derivation ( self , ed : EnumDerivation , spec : TransformationSpecification ): \"\"\" Invert an enum derivation. :param ed: :param spec: :return: \"\"\" inverted_ed = EnumDerivation ( name = ed . populated_from if ed . populated_from else ed . name , populated_from = ed . name ) if inverted_ed . expr : raise NonInvertibleSpecification ( \"TODO: invert enum derivation with expression\" ) for pv_deriv in ed . permissible_value_derivations . values (): inverted_pv_deriv = PermissibleValueDerivation ( name = pv_deriv . populated_from if pv_deriv . populated_from else pv_deriv . name , populated_from = pv_deriv . name , ) inverted_ed . permissible_value_derivations [ inverted_pv_deriv . name ] = inverted_pv_deriv return inverted_ed def invert_slot_derivation ( self , sd : SlotDerivation , cd : ClassDerivation , spec : TransformationSpecification ) -> Optional [ SlotDerivation ]: \"\"\" Invert a slot derivation. :param sd: :param cd: :param spec: :return: \"\"\" populated_from = sd . populated_from if sd . expr : if re . match ( r \"^\\w+$\" , sd . expr ): populated_from = sd . expr else : if not self . strict : return None # TODO: add logic for reversible expressions raise NonInvertibleSpecification ( f \"Cannot invert expression { sd . expr } in slot derivation: { sd . name } \" ) if not populated_from : # use defaults. TODO: decide on semantics of defaults populated_from = sd . name # raise NonInvertibleSpecification(f\"No populate_from or expr in slot derivation: {sd.name}\") inverted_sd = SlotDerivation ( name = populated_from , populated_from = sd . name ) # source_cls_name = spec.class_derivations[cd.populated_from].name source_cls_name = cd . populated_from if ( source_cls_name is None or source_cls_name in self . source_schemaview . all_classes () ) and sd . populated_from : source_slot = self . source_schemaview . induced_slot ( sd . populated_from , source_cls_name ) else : source_slot = None if sd . range : # source_slot = self.source_schemaview.induced_slot(sd.populated_from, source_cls_name) inverted_sd . range = source_slot . range if source_slot . range in self . source_schemaview . all_classes (): id_slot = self . source_schemaview . get_identifier_slot ( source_slot . range , use_key = True ) if id_slot : inverted_sd . dictionary_key = id_slot . name if source_slot and source_slot . multivalued : if source_slot . inlined_as_list : inverted_sd . cast_collection_as = CollectionType . MultiValuedList elif source_slot . inlined : if source_slot . range in self . source_schemaview . all_classes (): id_slot = self . source_schemaview . get_identifier_slot ( source_slot . range , use_key = True ) if id_slot : inverted_sd . cast_collection_as = CollectionType . MultiValuedDict inverted_sd . dictionary_key = id_slot . name if sd . unit_conversion : source_slot = self . source_schemaview . induced_slot ( sd . populated_from , source_cls_name ) target_unit = None target_unit_scheme = None if source_slot . unit is not None : for p in [ \"ucum_code\" , \"symbol\" ]: target_unit = getattr ( source_slot . unit , p , None ) if target_unit is not None : target_unit_scheme = p break inverted_uc = UnitConversionConfiguration ( target_unit = target_unit , target_unit_scheme = target_unit_scheme ) # if sd.unit_conversion.target_unit: # inverted_uc.source_unit = sd.unit_conversion.target_unit if sd . unit_conversion . source_unit_slot : inverted_uc . target_unit_slot = sd . unit_conversion . source_unit_slot if sd . unit_conversion . source_magnitude_slot : inverted_uc . target_magnitude_slot = sd . unit_conversion . source_magnitude_slot if sd . unit_conversion . target_unit : inverted_uc . source_unit = sd . unit_conversion . target_unit inverted_sd . unit_conversion = inverted_uc if sd . stringification : inverted_sd . stringification = copy ( sd . stringification ) inverted_sd . stringification . reversed = not inverted_sd . stringification . reversed return inverted_sd source_schemaview : SchemaView = None class-attribute instance-attribute The source schema for the forward transformation. Note this becomes the target schema for the generated inverse transformation, because the goal of the inverted transformation is to map back to the original source. target_schemaview : SchemaView = None class-attribute instance-attribute The target schema for the forward transformation. Note this becomes the source schema for the generated inverse transformation. invert ( spec ) Invert a transformation specification. :param spec: :return: Source code in src\\linkml_map\\inference\\inverter.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def invert ( self , spec : TransformationSpecification ): \"\"\" Invert a transformation specification. :param spec: :return: \"\"\" logger . info ( \"Inverting specification\" ) inverted_spec = TransformationSpecification () for cd in spec . class_derivations . values (): inverted_cd = self . invert_class_derivation ( cd , spec ) inverted_spec . class_derivations [ inverted_cd . name ] = inverted_cd for ed in spec . enum_derivations . values (): inverted_ed = self . invert_enum_derivation ( ed , spec ) inverted_spec . enum_derivations [ inverted_ed . name ] = inverted_ed return inverted_spec invert_class_derivation ( cd , spec ) Invert a class derivation. :param cd: :param spec: :return: Source code in src\\linkml_map\\inference\\inverter.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def invert_class_derivation ( self , cd : ClassDerivation , spec : TransformationSpecification ): \"\"\" Invert a class derivation. :param cd: :param spec: :return: \"\"\" inverted_cd = ClassDerivation ( name = cd . populated_from if cd . populated_from else cd . name , populated_from = cd . name ) for sd in cd . slot_derivations . values (): inverted_sd = self . invert_slot_derivation ( sd , cd , spec ) if inverted_sd : inverted_cd . slot_derivations [ inverted_sd . name ] = inverted_sd else : if self . strict : raise NonInvertibleSpecification ( f \"Cannot invert slot derivation: { sd . name } \" ) return inverted_cd invert_enum_derivation ( ed , spec ) Invert an enum derivation. :param ed: :param spec: :return: Source code in src\\linkml_map\\inference\\inverter.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def invert_enum_derivation ( self , ed : EnumDerivation , spec : TransformationSpecification ): \"\"\" Invert an enum derivation. :param ed: :param spec: :return: \"\"\" inverted_ed = EnumDerivation ( name = ed . populated_from if ed . populated_from else ed . name , populated_from = ed . name ) if inverted_ed . expr : raise NonInvertibleSpecification ( \"TODO: invert enum derivation with expression\" ) for pv_deriv in ed . permissible_value_derivations . values (): inverted_pv_deriv = PermissibleValueDerivation ( name = pv_deriv . populated_from if pv_deriv . populated_from else pv_deriv . name , populated_from = pv_deriv . name , ) inverted_ed . permissible_value_derivations [ inverted_pv_deriv . name ] = inverted_pv_deriv return inverted_ed invert_slot_derivation ( sd , cd , spec ) Invert a slot derivation. :param sd: :param cd: :param spec: :return: Source code in src\\linkml_map\\inference\\inverter.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def invert_slot_derivation ( self , sd : SlotDerivation , cd : ClassDerivation , spec : TransformationSpecification ) -> Optional [ SlotDerivation ]: \"\"\" Invert a slot derivation. :param sd: :param cd: :param spec: :return: \"\"\" populated_from = sd . populated_from if sd . expr : if re . match ( r \"^\\w+$\" , sd . expr ): populated_from = sd . expr else : if not self . strict : return None # TODO: add logic for reversible expressions raise NonInvertibleSpecification ( f \"Cannot invert expression { sd . expr } in slot derivation: { sd . name } \" ) if not populated_from : # use defaults. TODO: decide on semantics of defaults populated_from = sd . name # raise NonInvertibleSpecification(f\"No populate_from or expr in slot derivation: {sd.name}\") inverted_sd = SlotDerivation ( name = populated_from , populated_from = sd . name ) # source_cls_name = spec.class_derivations[cd.populated_from].name source_cls_name = cd . populated_from if ( source_cls_name is None or source_cls_name in self . source_schemaview . all_classes () ) and sd . populated_from : source_slot = self . source_schemaview . induced_slot ( sd . populated_from , source_cls_name ) else : source_slot = None if sd . range : # source_slot = self.source_schemaview.induced_slot(sd.populated_from, source_cls_name) inverted_sd . range = source_slot . range if source_slot . range in self . source_schemaview . all_classes (): id_slot = self . source_schemaview . get_identifier_slot ( source_slot . range , use_key = True ) if id_slot : inverted_sd . dictionary_key = id_slot . name if source_slot and source_slot . multivalued : if source_slot . inlined_as_list : inverted_sd . cast_collection_as = CollectionType . MultiValuedList elif source_slot . inlined : if source_slot . range in self . source_schemaview . all_classes (): id_slot = self . source_schemaview . get_identifier_slot ( source_slot . range , use_key = True ) if id_slot : inverted_sd . cast_collection_as = CollectionType . MultiValuedDict inverted_sd . dictionary_key = id_slot . name if sd . unit_conversion : source_slot = self . source_schemaview . induced_slot ( sd . populated_from , source_cls_name ) target_unit = None target_unit_scheme = None if source_slot . unit is not None : for p in [ \"ucum_code\" , \"symbol\" ]: target_unit = getattr ( source_slot . unit , p , None ) if target_unit is not None : target_unit_scheme = p break inverted_uc = UnitConversionConfiguration ( target_unit = target_unit , target_unit_scheme = target_unit_scheme ) # if sd.unit_conversion.target_unit: # inverted_uc.source_unit = sd.unit_conversion.target_unit if sd . unit_conversion . source_unit_slot : inverted_uc . target_unit_slot = sd . unit_conversion . source_unit_slot if sd . unit_conversion . source_magnitude_slot : inverted_uc . target_magnitude_slot = sd . unit_conversion . source_magnitude_slot if sd . unit_conversion . target_unit : inverted_uc . source_unit = sd . unit_conversion . target_unit inverted_sd . unit_conversion = inverted_uc if sd . stringification : inverted_sd . stringification = copy ( sd . stringification ) inverted_sd . stringification . reversed = not inverted_sd . stringification . reversed return inverted_sd Schema Mapper Translates a source schema and transformation specification into a target schema. Source code in src\\linkml_map\\inference\\schema_mapper.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 @dataclass class SchemaMapper : \"\"\" Translates a source schema and transformation specification into a target schema. \"\"\" source_schemaview : SchemaView = None transformer : Transformer = None source_to_target_class_mappings : Dict [ str , List [ str ]] = field ( default_factory = lambda : defaultdict ( list ) ) slot_info : Dict [ Tuple [ str , str ], Any ] = field ( default_factory = lambda : {}) def _copy_dict ( self , copy_directive : CopyDirective , src_elements , tgt_elements , ): if copy_directive . copy_all : for element in src_elements . keys (): tgt_elements [ element ] = src_elements [ element ] if copy_directive . exclude : for element in src_elements . keys (): if element in copy_directive . exclude : del tgt_elements [ element ] if copy_directive . exclude_all : elements_to_delete = [ key for key in tgt_elements ] for element in elements_to_delete : del tgt_elements [ element ] if copy_directive . include : for element in copy_directive . include : if element in src_elements . keys (): tgt_elements [ element ] = src_elements [ element ] def _copy_list ( self , copy_directive : CopyDirective , src_elements , tgt_elements , ): if copy_directive . copy_all : for element in src_elements : tgt_elements . append ( element ) if copy_directive . exclude : for element in src_elements : if copy_directive . exclude : tgt_elements . remove ( element ) if copy_directive . exclude_all : for element in tgt_elements : tgt_elements . remove ( element ) if copy_directive . include : for element in copy_directive . include : if element in src_elements : tgt_elements . append ( element ) def _copy_schema ( self , copy_directives : list [ CopyDirective ], source : SchemaDefinition , target : SchemaDefinition , ) -> SchemaDefinition : if type ( copy_directives ) is dict : copy_directives_list = copy_directives . values () else : copy_directives_list = copy_directives for copy_directive in copy_directives_list : for element_type in [ \"classes\" , \"slots\" , \"enums\" , \"types\" ]: if not hasattr ( source , element_type ): continue src_elements = getattr ( source , element_type ) tgt_elements = getattr ( target , element_type ) self . _copy_dict ( copy_directive , src_elements , tgt_elements ) return target def _copy_class ( self , copy_directives : list [ CopyDirective ], source : ClassDefinition , target : ClassDefinition , ) -> ClassDefinition : if type ( copy_directives ) is dict : copy_directives_list = copy_directives . values () else : copy_directives_list = copy_directives for copy_directive in copy_directives_list : if hasattr ( source , \"attributes\" ): # copy attributes (which is a dict) src_elements = source . attributes tgt_elements = target . attributes self . _copy_dict ( copy_directive , src_elements , tgt_elements ) if hasattr ( source , \"slots\" ): # copy slots (which is a list) src_elements = source . slots tgt_elements = target . slots self . _copy_list ( copy_directive , src_elements , tgt_elements ) return target def derive_schema ( self , specification : Optional [ TransformationSpecification ] = None , target_schema_id : Optional [ str ] = None , target_schema_name : Optional [ str ] = None , suffix = \"-derived\" , ) -> SchemaDefinition : \"\"\" Use a transformation specification to generate a target/profile schema from a source schema. :param specification: :return: \"\"\" if specification is None : specification = self . transformer . specification source_schemaview = self . source_schemaview source_schema = source_schemaview . schema if target_schema_id is None : target_schema_id = source_schema . id + suffix if target_schema_name is None : target_schema_name = source_schema . name + suffix target_schema = SchemaDefinition ( id = target_schema_id , name = target_schema_name ) if hasattr ( specification , \"copy_directives\" ): target_schema = self . _copy_schema ( specification . copy_directives , source_schema , target_schema , ) for im in source_schema . imports : target_schema . imports . append ( im ) for prefix in source_schema . prefixes . values (): target_schema . prefixes [ prefix . prefix_prefix ] = prefix for class_derivation in specification . class_derivations . values (): class_definition = self . _derive_class ( class_derivation ) target_schema . classes [ class_definition . name ] = class_definition for enum_derivation in specification . enum_derivations . values (): enum_definition = self . _derive_enum ( enum_derivation ) target_schema . enums [ enum_definition . name ] = enum_definition target_schema . default_range = source_schema . default_range for cd in target_schema . classes . values (): self . _rewire_class ( cd ) for ( cn , sn ), info in self . slot_info . items (): cd = target_schema . classes [ cn ] sd = cd . attributes [ sn ] for k , v in info . items (): setattr ( sd , k , v ) return target_schema def _derive_class ( self , class_derivation : ClassDerivation ) -> ClassDefinition : \"\"\" Derive a class from a class derivation. \"\"\" populated_from = class_derivation . populated_from if not populated_from : populated_from = class_derivation . name logger . info ( f \"Populating { class_derivation . name } from { populated_from } \" ) source_class = self . source_schemaview . get_class ( populated_from ) if source_class is None : logger . warning ( f \"No such class { populated_from } \" ) target_class = ClassDefinition ( name = class_derivation . name ) else : target_class = copy ( source_class ) target_class . from_schema = None target_class . name = class_derivation . name target_class . slots = [] target_class . attributes = {} target_class . slot_usage = {} if hasattr ( class_derivation , \"copy_directives\" ): target_class = self . _copy_class ( class_derivation . copy_directives , source_class , target_class , ) for slot_derivation in class_derivation . slot_derivations . values (): slot_definition = self . _derive_slot ( slot_derivation ) target_class . attributes [ slot_definition . name ] = slot_definition if class_derivation . is_a : target_class . is_a = class_derivation . is_a if class_derivation . mixins : target_class . mixins = class_derivation . mixins if class_derivation . target_definition : spec_defn = ClassDefinition ( ** { \"name\" : target_class . name }, ** class_derivation . target_definition ) for k , v in vars ( spec_defn ) . items (): curr_v = getattr ( target_class , k , None ) if curr_v is None or curr_v == [] or curr_v == {}: setattr ( target_class , k , v ) self . source_to_target_class_mappings [ populated_from ] . append ( target_class . name ) if class_derivation . overrides : curr = json_dumper . to_dict ( target_class ) for k , v in class_derivation . overrides . items (): curr [ k ] = v target_class = ClassDefinition ( ** curr ) return target_class def _derive_enum ( self , enum_derivation : EnumDerivation ) -> EnumDefinition : \"\"\" Derive an enum from an enum derivation. :param enum_derivation: :return: \"\"\" populated_from = enum_derivation . populated_from if not populated_from : populated_from = enum_derivation . name source_enum = self . source_schemaview . get_enum ( populated_from ) if source_enum is None : logger . warning ( f \"No such enum { populated_from } \" ) target_enum = ClassDefinition ( name = enum_derivation . name ) else : target_enum = copy ( source_enum ) target_enum . from_schema = None target_enum . name = enum_derivation . name target_enum . slots = [] target_enum . attributes = {} target_enum . slot_usage = {} for pv_derivation in enum_derivation . permissible_value_derivations . values (): if pv_derivation . populated_from : pv = PermissibleValue ( text = pv_derivation . populated_from ) target_enum . permissible_values [ pv . text ] = pv elif pv_derivation . sources : for source in pv_derivation . sources : pv = PermissibleValue ( text = source ) target_enum . permissible_values [ pv . text ] = pv else : raise ValueError ( f \"Missing populated_from or sources for { pv_derivation } \" ) if enum_derivation . mirror_source : for pv in source_enum . permissible_values . values (): if pv . text not in target_enum . permissible_values : target_enum . permissible_values [ pv . text ] = copy ( pv ) self . source_to_target_class_mappings [ populated_from ] . append ( target_enum . name ) return target_enum def _derive_slot ( self , slot_derivation ) -> SlotDefinition : \"\"\" Derive a slot from a slot derivation. \"\"\" populated_from = slot_derivation . populated_from if not populated_from : populated_from = slot_derivation . name source_slot = self . source_schemaview . get_slot ( populated_from ) if source_slot is None : target_slot = SlotDefinition ( name = slot_derivation . name ) else : target_slot = copy ( source_slot ) target_slot . from_schema = None target_slot . owner = None target_slot . name = slot_derivation . name if slot_derivation . range : target_slot . range = slot_derivation . range if slot_derivation . target_definition : spec_defn = SlotDefinition ( ** { \"name\" : target_slot . name }, ** slot_derivation . target_definition ) for k , v in vars ( spec_defn ) . items (): setattr ( target_slot , k , v ) if slot_derivation . unit_conversion : target_slot . unit = UnitOfMeasure ( ucum_code = slot_derivation . unit_conversion . target_unit ) if slot_derivation . stringification : if slot_derivation . stringification . reversed : target_slot . multivalued = True else : target_slot . multivalued = False if slot_derivation . dictionary_key : target_slot . inlined = True target_slot . inlined_as_list = False self . slot_info [( target_slot . range , slot_derivation . dictionary_key )] = { \"identifier\" : True } if slot_derivation . cast_collection_as : if slot_derivation . cast_collection_as == CollectionType . MultiValued : target_slot . inlined = True elif slot_derivation . cast_collection_as == CollectionType . MultiValuedList : target_slot . inlined_as_list = True elif slot_derivation . cast_collection_as == CollectionType . MultiValuedDict : target_slot . inlined = True target_slot . inlined_as_list = False if slot_derivation . overrides : curr = json_dumper . to_dict ( target_slot ) for k , v in slot_derivation . overrides . items (): curr [ k ] = v target_slot = SlotDefinition ( ** curr ) return target_slot def _rewire_class ( self , class_definition : ClassDefinition ): if class_definition . is_a : class_definition . is_a = self . _rewire_parent ( class_definition , class_definition . is_a ) mixins = [ self . _rewire_parent ( class_definition , m ) for m in class_definition . mixins ] class_definition . mixins = [ m for m in mixins if m is not None ] def _rewire_parent ( self , class_definition : ClassDefinition , parent : ClassDefinitionName ) -> Optional [ str ]: if parent in self . source_to_target_class_mappings : new_parents = self . source_to_target_class_mappings [ parent ] if len ( new_parents ) > 1 : raise ValueError ( f \"Cannot rewire to non-isomorphic mappings { parent } => { new_parents } \" ) if len ( new_parents ) == 1 : return new_parents [ 0 ] parent_cls = self . source_schemaview . get_class ( parent ) if parent_cls . is_a : return self . _rewire_parent ( class_definition , parent_cls . is_a ) return None def copy_attributes ( self , target_element : Element , source_element : Element , copy_directive : CopyDirective , ) -> None : \"\"\" Copy attributes from source to target according to a directive. :param target_element: :param source_element: :param copy_directive: :return: \"\"\" for k , v in vars ( source_element ) . items (): included = False if copy_directive . include_all : included = True if k in copy_directive . include : included = True if k in copy_directive . exclude : included = False if included : setattr ( target_element , k , v ) copy_attributes ( target_element , source_element , copy_directive ) Copy attributes from source to target according to a directive. :param target_element: :param source_element: :param copy_directive: :return: Source code in src\\linkml_map\\inference\\schema_mapper.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def copy_attributes ( self , target_element : Element , source_element : Element , copy_directive : CopyDirective , ) -> None : \"\"\" Copy attributes from source to target according to a directive. :param target_element: :param source_element: :param copy_directive: :return: \"\"\" for k , v in vars ( source_element ) . items (): included = False if copy_directive . include_all : included = True if k in copy_directive . include : included = True if k in copy_directive . exclude : included = False if included : setattr ( target_element , k , v ) derive_schema ( specification = None , target_schema_id = None , target_schema_name = None , suffix = '-derived' ) Use a transformation specification to generate a target/profile schema from a source schema. :param specification: :return: Source code in src\\linkml_map\\inference\\schema_mapper.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def derive_schema ( self , specification : Optional [ TransformationSpecification ] = None , target_schema_id : Optional [ str ] = None , target_schema_name : Optional [ str ] = None , suffix = \"-derived\" , ) -> SchemaDefinition : \"\"\" Use a transformation specification to generate a target/profile schema from a source schema. :param specification: :return: \"\"\" if specification is None : specification = self . transformer . specification source_schemaview = self . source_schemaview source_schema = source_schemaview . schema if target_schema_id is None : target_schema_id = source_schema . id + suffix if target_schema_name is None : target_schema_name = source_schema . name + suffix target_schema = SchemaDefinition ( id = target_schema_id , name = target_schema_name ) if hasattr ( specification , \"copy_directives\" ): target_schema = self . _copy_schema ( specification . copy_directives , source_schema , target_schema , ) for im in source_schema . imports : target_schema . imports . append ( im ) for prefix in source_schema . prefixes . values (): target_schema . prefixes [ prefix . prefix_prefix ] = prefix for class_derivation in specification . class_derivations . values (): class_definition = self . _derive_class ( class_derivation ) target_schema . classes [ class_definition . name ] = class_definition for enum_derivation in specification . enum_derivations . values (): enum_definition = self . _derive_enum ( enum_derivation ) target_schema . enums [ enum_definition . name ] = enum_definition target_schema . default_range = source_schema . default_range for cd in target_schema . classes . values (): self . _rewire_class ( cd ) for ( cn , sn ), info in self . slot_info . items (): cd = target_schema . classes [ cn ] sd = cd . attributes [ sn ] for k , v in info . items (): setattr ( sd , k , v ) return target_schema","title":"Inference"},{"location":"api/inference/#inference-package","text":"","title":"Inference Package"},{"location":"api/inference/#inference-utils","text":"","title":"Inference Utils"},{"location":"api/inference/#linkml_map.inference.inference.induce_missing_values","text":"Infer missing values in a specification. Currently only uses copy directives. :param specification: :param source_schemaview: :return: Source code in src\\linkml_map\\inference\\inference.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def induce_missing_values ( specification : TransformationSpecification , source_schemaview : SchemaView ): \"\"\" Infer missing values in a specification. Currently only uses copy directives. :param specification: :param source_schemaview: :return: \"\"\" for cd in specification . class_derivations . values (): if not cd . populated_from : cd . populated_from = cd . name for cd in specification . class_derivations . values (): for sd in cd . slot_derivations . values (): # for null mappings, assume that the slot is copied from the same slot in the source # TODO: decide if this is the desired behavior if sd . populated_from is None and sd . expr is None : sd . populated_from = sd . name if not sd . range : # auto-populate range field if sd . populated_from : if cd . populated_from not in source_schemaview . all_classes (): continue source_induced_slot = source_schemaview . induced_slot ( sd . populated_from , cd . populated_from ) source_induced_slot_range = source_induced_slot . range for range_cd in specification . class_derivations . values (): if range_cd . populated_from == source_induced_slot_range : sd . range = range_cd . name","title":"induce_missing_values"},{"location":"api/inference/#inverter","text":"","title":"Inverter"},{"location":"api/inference/#linkml_map.inference.inverter.TransformationSpecificationInverter","text":"Invert a transformation specification. Source code in src\\linkml_map\\inference\\inverter.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @dataclass class TransformationSpecificationInverter : \"\"\" Invert a transformation specification. \"\"\" source_schemaview : SchemaView = None \"\"\"The source schema for the forward transformation. Note this becomes the target schema for the generated inverse transformation, because the goal of the inverted transformation is to map back to the original source.\"\"\" target_schemaview : SchemaView = None \"\"\"The target schema for the forward transformation. Note this becomes the source schema for the generated inverse transformation.\"\"\" strict : bool = field ( default = True ) def invert ( self , spec : TransformationSpecification ): \"\"\" Invert a transformation specification. :param spec: :return: \"\"\" logger . info ( \"Inverting specification\" ) inverted_spec = TransformationSpecification () for cd in spec . class_derivations . values (): inverted_cd = self . invert_class_derivation ( cd , spec ) inverted_spec . class_derivations [ inverted_cd . name ] = inverted_cd for ed in spec . enum_derivations . values (): inverted_ed = self . invert_enum_derivation ( ed , spec ) inverted_spec . enum_derivations [ inverted_ed . name ] = inverted_ed return inverted_spec def invert_class_derivation ( self , cd : ClassDerivation , spec : TransformationSpecification ): \"\"\" Invert a class derivation. :param cd: :param spec: :return: \"\"\" inverted_cd = ClassDerivation ( name = cd . populated_from if cd . populated_from else cd . name , populated_from = cd . name ) for sd in cd . slot_derivations . values (): inverted_sd = self . invert_slot_derivation ( sd , cd , spec ) if inverted_sd : inverted_cd . slot_derivations [ inverted_sd . name ] = inverted_sd else : if self . strict : raise NonInvertibleSpecification ( f \"Cannot invert slot derivation: { sd . name } \" ) return inverted_cd def invert_enum_derivation ( self , ed : EnumDerivation , spec : TransformationSpecification ): \"\"\" Invert an enum derivation. :param ed: :param spec: :return: \"\"\" inverted_ed = EnumDerivation ( name = ed . populated_from if ed . populated_from else ed . name , populated_from = ed . name ) if inverted_ed . expr : raise NonInvertibleSpecification ( \"TODO: invert enum derivation with expression\" ) for pv_deriv in ed . permissible_value_derivations . values (): inverted_pv_deriv = PermissibleValueDerivation ( name = pv_deriv . populated_from if pv_deriv . populated_from else pv_deriv . name , populated_from = pv_deriv . name , ) inverted_ed . permissible_value_derivations [ inverted_pv_deriv . name ] = inverted_pv_deriv return inverted_ed def invert_slot_derivation ( self , sd : SlotDerivation , cd : ClassDerivation , spec : TransformationSpecification ) -> Optional [ SlotDerivation ]: \"\"\" Invert a slot derivation. :param sd: :param cd: :param spec: :return: \"\"\" populated_from = sd . populated_from if sd . expr : if re . match ( r \"^\\w+$\" , sd . expr ): populated_from = sd . expr else : if not self . strict : return None # TODO: add logic for reversible expressions raise NonInvertibleSpecification ( f \"Cannot invert expression { sd . expr } in slot derivation: { sd . name } \" ) if not populated_from : # use defaults. TODO: decide on semantics of defaults populated_from = sd . name # raise NonInvertibleSpecification(f\"No populate_from or expr in slot derivation: {sd.name}\") inverted_sd = SlotDerivation ( name = populated_from , populated_from = sd . name ) # source_cls_name = spec.class_derivations[cd.populated_from].name source_cls_name = cd . populated_from if ( source_cls_name is None or source_cls_name in self . source_schemaview . all_classes () ) and sd . populated_from : source_slot = self . source_schemaview . induced_slot ( sd . populated_from , source_cls_name ) else : source_slot = None if sd . range : # source_slot = self.source_schemaview.induced_slot(sd.populated_from, source_cls_name) inverted_sd . range = source_slot . range if source_slot . range in self . source_schemaview . all_classes (): id_slot = self . source_schemaview . get_identifier_slot ( source_slot . range , use_key = True ) if id_slot : inverted_sd . dictionary_key = id_slot . name if source_slot and source_slot . multivalued : if source_slot . inlined_as_list : inverted_sd . cast_collection_as = CollectionType . MultiValuedList elif source_slot . inlined : if source_slot . range in self . source_schemaview . all_classes (): id_slot = self . source_schemaview . get_identifier_slot ( source_slot . range , use_key = True ) if id_slot : inverted_sd . cast_collection_as = CollectionType . MultiValuedDict inverted_sd . dictionary_key = id_slot . name if sd . unit_conversion : source_slot = self . source_schemaview . induced_slot ( sd . populated_from , source_cls_name ) target_unit = None target_unit_scheme = None if source_slot . unit is not None : for p in [ \"ucum_code\" , \"symbol\" ]: target_unit = getattr ( source_slot . unit , p , None ) if target_unit is not None : target_unit_scheme = p break inverted_uc = UnitConversionConfiguration ( target_unit = target_unit , target_unit_scheme = target_unit_scheme ) # if sd.unit_conversion.target_unit: # inverted_uc.source_unit = sd.unit_conversion.target_unit if sd . unit_conversion . source_unit_slot : inverted_uc . target_unit_slot = sd . unit_conversion . source_unit_slot if sd . unit_conversion . source_magnitude_slot : inverted_uc . target_magnitude_slot = sd . unit_conversion . source_magnitude_slot if sd . unit_conversion . target_unit : inverted_uc . source_unit = sd . unit_conversion . target_unit inverted_sd . unit_conversion = inverted_uc if sd . stringification : inverted_sd . stringification = copy ( sd . stringification ) inverted_sd . stringification . reversed = not inverted_sd . stringification . reversed return inverted_sd","title":"TransformationSpecificationInverter"},{"location":"api/inference/#linkml_map.inference.inverter.TransformationSpecificationInverter.source_schemaview","text":"The source schema for the forward transformation. Note this becomes the target schema for the generated inverse transformation, because the goal of the inverted transformation is to map back to the original source.","title":"source_schemaview"},{"location":"api/inference/#linkml_map.inference.inverter.TransformationSpecificationInverter.target_schemaview","text":"The target schema for the forward transformation. Note this becomes the source schema for the generated inverse transformation.","title":"target_schemaview"},{"location":"api/inference/#linkml_map.inference.inverter.TransformationSpecificationInverter.invert","text":"Invert a transformation specification. :param spec: :return: Source code in src\\linkml_map\\inference\\inverter.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def invert ( self , spec : TransformationSpecification ): \"\"\" Invert a transformation specification. :param spec: :return: \"\"\" logger . info ( \"Inverting specification\" ) inverted_spec = TransformationSpecification () for cd in spec . class_derivations . values (): inverted_cd = self . invert_class_derivation ( cd , spec ) inverted_spec . class_derivations [ inverted_cd . name ] = inverted_cd for ed in spec . enum_derivations . values (): inverted_ed = self . invert_enum_derivation ( ed , spec ) inverted_spec . enum_derivations [ inverted_ed . name ] = inverted_ed return inverted_spec","title":"invert"},{"location":"api/inference/#linkml_map.inference.inverter.TransformationSpecificationInverter.invert_class_derivation","text":"Invert a class derivation. :param cd: :param spec: :return: Source code in src\\linkml_map\\inference\\inverter.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def invert_class_derivation ( self , cd : ClassDerivation , spec : TransformationSpecification ): \"\"\" Invert a class derivation. :param cd: :param spec: :return: \"\"\" inverted_cd = ClassDerivation ( name = cd . populated_from if cd . populated_from else cd . name , populated_from = cd . name ) for sd in cd . slot_derivations . values (): inverted_sd = self . invert_slot_derivation ( sd , cd , spec ) if inverted_sd : inverted_cd . slot_derivations [ inverted_sd . name ] = inverted_sd else : if self . strict : raise NonInvertibleSpecification ( f \"Cannot invert slot derivation: { sd . name } \" ) return inverted_cd","title":"invert_class_derivation"},{"location":"api/inference/#linkml_map.inference.inverter.TransformationSpecificationInverter.invert_enum_derivation","text":"Invert an enum derivation. :param ed: :param spec: :return: Source code in src\\linkml_map\\inference\\inverter.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def invert_enum_derivation ( self , ed : EnumDerivation , spec : TransformationSpecification ): \"\"\" Invert an enum derivation. :param ed: :param spec: :return: \"\"\" inverted_ed = EnumDerivation ( name = ed . populated_from if ed . populated_from else ed . name , populated_from = ed . name ) if inverted_ed . expr : raise NonInvertibleSpecification ( \"TODO: invert enum derivation with expression\" ) for pv_deriv in ed . permissible_value_derivations . values (): inverted_pv_deriv = PermissibleValueDerivation ( name = pv_deriv . populated_from if pv_deriv . populated_from else pv_deriv . name , populated_from = pv_deriv . name , ) inverted_ed . permissible_value_derivations [ inverted_pv_deriv . name ] = inverted_pv_deriv return inverted_ed","title":"invert_enum_derivation"},{"location":"api/inference/#linkml_map.inference.inverter.TransformationSpecificationInverter.invert_slot_derivation","text":"Invert a slot derivation. :param sd: :param cd: :param spec: :return: Source code in src\\linkml_map\\inference\\inverter.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def invert_slot_derivation ( self , sd : SlotDerivation , cd : ClassDerivation , spec : TransformationSpecification ) -> Optional [ SlotDerivation ]: \"\"\" Invert a slot derivation. :param sd: :param cd: :param spec: :return: \"\"\" populated_from = sd . populated_from if sd . expr : if re . match ( r \"^\\w+$\" , sd . expr ): populated_from = sd . expr else : if not self . strict : return None # TODO: add logic for reversible expressions raise NonInvertibleSpecification ( f \"Cannot invert expression { sd . expr } in slot derivation: { sd . name } \" ) if not populated_from : # use defaults. TODO: decide on semantics of defaults populated_from = sd . name # raise NonInvertibleSpecification(f\"No populate_from or expr in slot derivation: {sd.name}\") inverted_sd = SlotDerivation ( name = populated_from , populated_from = sd . name ) # source_cls_name = spec.class_derivations[cd.populated_from].name source_cls_name = cd . populated_from if ( source_cls_name is None or source_cls_name in self . source_schemaview . all_classes () ) and sd . populated_from : source_slot = self . source_schemaview . induced_slot ( sd . populated_from , source_cls_name ) else : source_slot = None if sd . range : # source_slot = self.source_schemaview.induced_slot(sd.populated_from, source_cls_name) inverted_sd . range = source_slot . range if source_slot . range in self . source_schemaview . all_classes (): id_slot = self . source_schemaview . get_identifier_slot ( source_slot . range , use_key = True ) if id_slot : inverted_sd . dictionary_key = id_slot . name if source_slot and source_slot . multivalued : if source_slot . inlined_as_list : inverted_sd . cast_collection_as = CollectionType . MultiValuedList elif source_slot . inlined : if source_slot . range in self . source_schemaview . all_classes (): id_slot = self . source_schemaview . get_identifier_slot ( source_slot . range , use_key = True ) if id_slot : inverted_sd . cast_collection_as = CollectionType . MultiValuedDict inverted_sd . dictionary_key = id_slot . name if sd . unit_conversion : source_slot = self . source_schemaview . induced_slot ( sd . populated_from , source_cls_name ) target_unit = None target_unit_scheme = None if source_slot . unit is not None : for p in [ \"ucum_code\" , \"symbol\" ]: target_unit = getattr ( source_slot . unit , p , None ) if target_unit is not None : target_unit_scheme = p break inverted_uc = UnitConversionConfiguration ( target_unit = target_unit , target_unit_scheme = target_unit_scheme ) # if sd.unit_conversion.target_unit: # inverted_uc.source_unit = sd.unit_conversion.target_unit if sd . unit_conversion . source_unit_slot : inverted_uc . target_unit_slot = sd . unit_conversion . source_unit_slot if sd . unit_conversion . source_magnitude_slot : inverted_uc . target_magnitude_slot = sd . unit_conversion . source_magnitude_slot if sd . unit_conversion . target_unit : inverted_uc . source_unit = sd . unit_conversion . target_unit inverted_sd . unit_conversion = inverted_uc if sd . stringification : inverted_sd . stringification = copy ( sd . stringification ) inverted_sd . stringification . reversed = not inverted_sd . stringification . reversed return inverted_sd","title":"invert_slot_derivation"},{"location":"api/inference/#schema-mapper","text":"Translates a source schema and transformation specification into a target schema. Source code in src\\linkml_map\\inference\\schema_mapper.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 @dataclass class SchemaMapper : \"\"\" Translates a source schema and transformation specification into a target schema. \"\"\" source_schemaview : SchemaView = None transformer : Transformer = None source_to_target_class_mappings : Dict [ str , List [ str ]] = field ( default_factory = lambda : defaultdict ( list ) ) slot_info : Dict [ Tuple [ str , str ], Any ] = field ( default_factory = lambda : {}) def _copy_dict ( self , copy_directive : CopyDirective , src_elements , tgt_elements , ): if copy_directive . copy_all : for element in src_elements . keys (): tgt_elements [ element ] = src_elements [ element ] if copy_directive . exclude : for element in src_elements . keys (): if element in copy_directive . exclude : del tgt_elements [ element ] if copy_directive . exclude_all : elements_to_delete = [ key for key in tgt_elements ] for element in elements_to_delete : del tgt_elements [ element ] if copy_directive . include : for element in copy_directive . include : if element in src_elements . keys (): tgt_elements [ element ] = src_elements [ element ] def _copy_list ( self , copy_directive : CopyDirective , src_elements , tgt_elements , ): if copy_directive . copy_all : for element in src_elements : tgt_elements . append ( element ) if copy_directive . exclude : for element in src_elements : if copy_directive . exclude : tgt_elements . remove ( element ) if copy_directive . exclude_all : for element in tgt_elements : tgt_elements . remove ( element ) if copy_directive . include : for element in copy_directive . include : if element in src_elements : tgt_elements . append ( element ) def _copy_schema ( self , copy_directives : list [ CopyDirective ], source : SchemaDefinition , target : SchemaDefinition , ) -> SchemaDefinition : if type ( copy_directives ) is dict : copy_directives_list = copy_directives . values () else : copy_directives_list = copy_directives for copy_directive in copy_directives_list : for element_type in [ \"classes\" , \"slots\" , \"enums\" , \"types\" ]: if not hasattr ( source , element_type ): continue src_elements = getattr ( source , element_type ) tgt_elements = getattr ( target , element_type ) self . _copy_dict ( copy_directive , src_elements , tgt_elements ) return target def _copy_class ( self , copy_directives : list [ CopyDirective ], source : ClassDefinition , target : ClassDefinition , ) -> ClassDefinition : if type ( copy_directives ) is dict : copy_directives_list = copy_directives . values () else : copy_directives_list = copy_directives for copy_directive in copy_directives_list : if hasattr ( source , \"attributes\" ): # copy attributes (which is a dict) src_elements = source . attributes tgt_elements = target . attributes self . _copy_dict ( copy_directive , src_elements , tgt_elements ) if hasattr ( source , \"slots\" ): # copy slots (which is a list) src_elements = source . slots tgt_elements = target . slots self . _copy_list ( copy_directive , src_elements , tgt_elements ) return target def derive_schema ( self , specification : Optional [ TransformationSpecification ] = None , target_schema_id : Optional [ str ] = None , target_schema_name : Optional [ str ] = None , suffix = \"-derived\" , ) -> SchemaDefinition : \"\"\" Use a transformation specification to generate a target/profile schema from a source schema. :param specification: :return: \"\"\" if specification is None : specification = self . transformer . specification source_schemaview = self . source_schemaview source_schema = source_schemaview . schema if target_schema_id is None : target_schema_id = source_schema . id + suffix if target_schema_name is None : target_schema_name = source_schema . name + suffix target_schema = SchemaDefinition ( id = target_schema_id , name = target_schema_name ) if hasattr ( specification , \"copy_directives\" ): target_schema = self . _copy_schema ( specification . copy_directives , source_schema , target_schema , ) for im in source_schema . imports : target_schema . imports . append ( im ) for prefix in source_schema . prefixes . values (): target_schema . prefixes [ prefix . prefix_prefix ] = prefix for class_derivation in specification . class_derivations . values (): class_definition = self . _derive_class ( class_derivation ) target_schema . classes [ class_definition . name ] = class_definition for enum_derivation in specification . enum_derivations . values (): enum_definition = self . _derive_enum ( enum_derivation ) target_schema . enums [ enum_definition . name ] = enum_definition target_schema . default_range = source_schema . default_range for cd in target_schema . classes . values (): self . _rewire_class ( cd ) for ( cn , sn ), info in self . slot_info . items (): cd = target_schema . classes [ cn ] sd = cd . attributes [ sn ] for k , v in info . items (): setattr ( sd , k , v ) return target_schema def _derive_class ( self , class_derivation : ClassDerivation ) -> ClassDefinition : \"\"\" Derive a class from a class derivation. \"\"\" populated_from = class_derivation . populated_from if not populated_from : populated_from = class_derivation . name logger . info ( f \"Populating { class_derivation . name } from { populated_from } \" ) source_class = self . source_schemaview . get_class ( populated_from ) if source_class is None : logger . warning ( f \"No such class { populated_from } \" ) target_class = ClassDefinition ( name = class_derivation . name ) else : target_class = copy ( source_class ) target_class . from_schema = None target_class . name = class_derivation . name target_class . slots = [] target_class . attributes = {} target_class . slot_usage = {} if hasattr ( class_derivation , \"copy_directives\" ): target_class = self . _copy_class ( class_derivation . copy_directives , source_class , target_class , ) for slot_derivation in class_derivation . slot_derivations . values (): slot_definition = self . _derive_slot ( slot_derivation ) target_class . attributes [ slot_definition . name ] = slot_definition if class_derivation . is_a : target_class . is_a = class_derivation . is_a if class_derivation . mixins : target_class . mixins = class_derivation . mixins if class_derivation . target_definition : spec_defn = ClassDefinition ( ** { \"name\" : target_class . name }, ** class_derivation . target_definition ) for k , v in vars ( spec_defn ) . items (): curr_v = getattr ( target_class , k , None ) if curr_v is None or curr_v == [] or curr_v == {}: setattr ( target_class , k , v ) self . source_to_target_class_mappings [ populated_from ] . append ( target_class . name ) if class_derivation . overrides : curr = json_dumper . to_dict ( target_class ) for k , v in class_derivation . overrides . items (): curr [ k ] = v target_class = ClassDefinition ( ** curr ) return target_class def _derive_enum ( self , enum_derivation : EnumDerivation ) -> EnumDefinition : \"\"\" Derive an enum from an enum derivation. :param enum_derivation: :return: \"\"\" populated_from = enum_derivation . populated_from if not populated_from : populated_from = enum_derivation . name source_enum = self . source_schemaview . get_enum ( populated_from ) if source_enum is None : logger . warning ( f \"No such enum { populated_from } \" ) target_enum = ClassDefinition ( name = enum_derivation . name ) else : target_enum = copy ( source_enum ) target_enum . from_schema = None target_enum . name = enum_derivation . name target_enum . slots = [] target_enum . attributes = {} target_enum . slot_usage = {} for pv_derivation in enum_derivation . permissible_value_derivations . values (): if pv_derivation . populated_from : pv = PermissibleValue ( text = pv_derivation . populated_from ) target_enum . permissible_values [ pv . text ] = pv elif pv_derivation . sources : for source in pv_derivation . sources : pv = PermissibleValue ( text = source ) target_enum . permissible_values [ pv . text ] = pv else : raise ValueError ( f \"Missing populated_from or sources for { pv_derivation } \" ) if enum_derivation . mirror_source : for pv in source_enum . permissible_values . values (): if pv . text not in target_enum . permissible_values : target_enum . permissible_values [ pv . text ] = copy ( pv ) self . source_to_target_class_mappings [ populated_from ] . append ( target_enum . name ) return target_enum def _derive_slot ( self , slot_derivation ) -> SlotDefinition : \"\"\" Derive a slot from a slot derivation. \"\"\" populated_from = slot_derivation . populated_from if not populated_from : populated_from = slot_derivation . name source_slot = self . source_schemaview . get_slot ( populated_from ) if source_slot is None : target_slot = SlotDefinition ( name = slot_derivation . name ) else : target_slot = copy ( source_slot ) target_slot . from_schema = None target_slot . owner = None target_slot . name = slot_derivation . name if slot_derivation . range : target_slot . range = slot_derivation . range if slot_derivation . target_definition : spec_defn = SlotDefinition ( ** { \"name\" : target_slot . name }, ** slot_derivation . target_definition ) for k , v in vars ( spec_defn ) . items (): setattr ( target_slot , k , v ) if slot_derivation . unit_conversion : target_slot . unit = UnitOfMeasure ( ucum_code = slot_derivation . unit_conversion . target_unit ) if slot_derivation . stringification : if slot_derivation . stringification . reversed : target_slot . multivalued = True else : target_slot . multivalued = False if slot_derivation . dictionary_key : target_slot . inlined = True target_slot . inlined_as_list = False self . slot_info [( target_slot . range , slot_derivation . dictionary_key )] = { \"identifier\" : True } if slot_derivation . cast_collection_as : if slot_derivation . cast_collection_as == CollectionType . MultiValued : target_slot . inlined = True elif slot_derivation . cast_collection_as == CollectionType . MultiValuedList : target_slot . inlined_as_list = True elif slot_derivation . cast_collection_as == CollectionType . MultiValuedDict : target_slot . inlined = True target_slot . inlined_as_list = False if slot_derivation . overrides : curr = json_dumper . to_dict ( target_slot ) for k , v in slot_derivation . overrides . items (): curr [ k ] = v target_slot = SlotDefinition ( ** curr ) return target_slot def _rewire_class ( self , class_definition : ClassDefinition ): if class_definition . is_a : class_definition . is_a = self . _rewire_parent ( class_definition , class_definition . is_a ) mixins = [ self . _rewire_parent ( class_definition , m ) for m in class_definition . mixins ] class_definition . mixins = [ m for m in mixins if m is not None ] def _rewire_parent ( self , class_definition : ClassDefinition , parent : ClassDefinitionName ) -> Optional [ str ]: if parent in self . source_to_target_class_mappings : new_parents = self . source_to_target_class_mappings [ parent ] if len ( new_parents ) > 1 : raise ValueError ( f \"Cannot rewire to non-isomorphic mappings { parent } => { new_parents } \" ) if len ( new_parents ) == 1 : return new_parents [ 0 ] parent_cls = self . source_schemaview . get_class ( parent ) if parent_cls . is_a : return self . _rewire_parent ( class_definition , parent_cls . is_a ) return None def copy_attributes ( self , target_element : Element , source_element : Element , copy_directive : CopyDirective , ) -> None : \"\"\" Copy attributes from source to target according to a directive. :param target_element: :param source_element: :param copy_directive: :return: \"\"\" for k , v in vars ( source_element ) . items (): included = False if copy_directive . include_all : included = True if k in copy_directive . include : included = True if k in copy_directive . exclude : included = False if included : setattr ( target_element , k , v )","title":"Schema Mapper"},{"location":"api/inference/#linkml_map.inference.schema_mapper.SchemaMapper.copy_attributes","text":"Copy attributes from source to target according to a directive. :param target_element: :param source_element: :param copy_directive: :return: Source code in src\\linkml_map\\inference\\schema_mapper.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def copy_attributes ( self , target_element : Element , source_element : Element , copy_directive : CopyDirective , ) -> None : \"\"\" Copy attributes from source to target according to a directive. :param target_element: :param source_element: :param copy_directive: :return: \"\"\" for k , v in vars ( source_element ) . items (): included = False if copy_directive . include_all : included = True if k in copy_directive . include : included = True if k in copy_directive . exclude : included = False if included : setattr ( target_element , k , v )","title":"copy_attributes"},{"location":"api/inference/#linkml_map.inference.schema_mapper.SchemaMapper.derive_schema","text":"Use a transformation specification to generate a target/profile schema from a source schema. :param specification: :return: Source code in src\\linkml_map\\inference\\schema_mapper.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def derive_schema ( self , specification : Optional [ TransformationSpecification ] = None , target_schema_id : Optional [ str ] = None , target_schema_name : Optional [ str ] = None , suffix = \"-derived\" , ) -> SchemaDefinition : \"\"\" Use a transformation specification to generate a target/profile schema from a source schema. :param specification: :return: \"\"\" if specification is None : specification = self . transformer . specification source_schemaview = self . source_schemaview source_schema = source_schemaview . schema if target_schema_id is None : target_schema_id = source_schema . id + suffix if target_schema_name is None : target_schema_name = source_schema . name + suffix target_schema = SchemaDefinition ( id = target_schema_id , name = target_schema_name ) if hasattr ( specification , \"copy_directives\" ): target_schema = self . _copy_schema ( specification . copy_directives , source_schema , target_schema , ) for im in source_schema . imports : target_schema . imports . append ( im ) for prefix in source_schema . prefixes . values (): target_schema . prefixes [ prefix . prefix_prefix ] = prefix for class_derivation in specification . class_derivations . values (): class_definition = self . _derive_class ( class_derivation ) target_schema . classes [ class_definition . name ] = class_definition for enum_derivation in specification . enum_derivations . values (): enum_definition = self . _derive_enum ( enum_derivation ) target_schema . enums [ enum_definition . name ] = enum_definition target_schema . default_range = source_schema . default_range for cd in target_schema . classes . values (): self . _rewire_class ( cd ) for ( cn , sn ), info in self . slot_info . items (): cd = target_schema . classes [ cn ] sd = cd . attributes [ sn ] for k , v in info . items (): setattr ( sd , k , v ) return target_schema","title":"derive_schema"},{"location":"api/session/","text":"Session A wrapper object for a transformer session. TODO: rename to Manager? consolidate configuration include source and target database current spec, src_sv, tgt_sv all live in both this class and transformer Source code in src\\linkml_map\\session.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 @dataclass class Session : \"\"\" A wrapper object for a transformer session. TODO: - rename to Manager? - consolidate configuration - include source and target database - current spec, src_sv, tgt_sv all live in both this class and transformer \"\"\" transformer_specification : Optional [ TransformationSpecification ] = None source_schemaview : Optional [ SchemaView ] = None transformer : Optional [ Transformer ] = None object_transformer : Optional [ ObjectTransformer ] = None schema_mapper : Optional [ SchemaMapper ] = None _target_schema : Optional [ SchemaDefinition ] = None _target_schemaview : Optional [ SchemaView ] = None def set_transformer_specification ( self , specification : Optional [ Union [ TransformationSpecification , dict , str , Path ]] = None ): if isinstance ( specification , Path ): specification = str ( specification ) if isinstance ( specification , TransformationSpecification ): self . transformer_specification = specification elif isinstance ( specification , dict ): # TODO: centralize this code normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True specification = normalizer . normalize ( specification ) self . transformer_specification = TransformationSpecification ( ** specification ) elif isinstance ( specification , str ): if \" \\n \" in specification : obj = yaml . safe_load ( specification ) else : obj = yaml . safe_load ( open ( specification )) self . set_transformer_specification ( obj ) def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None def set_transformer ( self , transformer : Optional [ Union [ Transformer , Type [ Transformer ]]], ** kwargs , ): if isinstance ( transformer , Type ): transformer = transformer () transformer . specification = self . transformer_specification self . transformer = transformer def set_object_transformer ( self , transformer : Optional [ Union [ ObjectTransformer , TransformationSpecification , dict , str , Path ] ] = None , ): if transformer is None : if self . object_transformer is not None : logger . info ( \"No change\" ) return else : logger . warning ( \"No transformer specified\" ) return if transformer is not None : if isinstance ( transformer , ObjectTransformer ): self . object_transformer = transformer else : self . set_transformer_specification ( transformer ) self . object_transformer = ObjectTransformer () self . object_transformer . specification = self . transformer_specification self . _target_schema = None @property def target_schema ( self ) -> SchemaDefinition : if self . _target_schema is None : if not self . schema_mapper : self . schema_mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) self . _target_schema = self . schema_mapper . derive_schema ( self . transformer_specification ) return self . _target_schema @property def target_schemaview ( self ) -> SchemaView : if self . _target_schemaview is None : # TODO: simplify self . _target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return self . _target_schemaview def transform ( self , obj : dict , ** kwargs ) -> dict : if self . object_transformer is None : raise ValueError ( \"No transformer specified\" ) if not self . object_transformer . source_schemaview : self . object_transformer . source_schemaview = self . source_schemaview return self . object_transformer . map_object ( obj , ** kwargs ) def reverse_transform ( self , obj : dict , ** kwargs ) -> dict : inv_spec = self . invert () reverse_transformer = ObjectTransformer () reverse_transformer . specification = inv_spec reverse_transformer . source_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return reverse_transformer . map_object ( obj , ** kwargs ) def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph graphviz ( ** kwargs ) Return a graphviz representation of the schema. Source code in src\\linkml_map\\session.py 159 160 161 162 163 164 165 166 167 def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph invert ( in_place = False ) Invert the transformer specification. Source code in src\\linkml_map\\session.py 146 147 148 149 150 151 152 153 154 155 156 157 def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec set_source_schema ( schema ) Sets the schema from a path or SchemaView object. Source code in src\\linkml_map\\session.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None","title":"Session"},{"location":"api/session/#session","text":"A wrapper object for a transformer session. TODO: rename to Manager? consolidate configuration include source and target database current spec, src_sv, tgt_sv all live in both this class and transformer Source code in src\\linkml_map\\session.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 @dataclass class Session : \"\"\" A wrapper object for a transformer session. TODO: - rename to Manager? - consolidate configuration - include source and target database - current spec, src_sv, tgt_sv all live in both this class and transformer \"\"\" transformer_specification : Optional [ TransformationSpecification ] = None source_schemaview : Optional [ SchemaView ] = None transformer : Optional [ Transformer ] = None object_transformer : Optional [ ObjectTransformer ] = None schema_mapper : Optional [ SchemaMapper ] = None _target_schema : Optional [ SchemaDefinition ] = None _target_schemaview : Optional [ SchemaView ] = None def set_transformer_specification ( self , specification : Optional [ Union [ TransformationSpecification , dict , str , Path ]] = None ): if isinstance ( specification , Path ): specification = str ( specification ) if isinstance ( specification , TransformationSpecification ): self . transformer_specification = specification elif isinstance ( specification , dict ): # TODO: centralize this code normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True specification = normalizer . normalize ( specification ) self . transformer_specification = TransformationSpecification ( ** specification ) elif isinstance ( specification , str ): if \" \\n \" in specification : obj = yaml . safe_load ( specification ) else : obj = yaml . safe_load ( open ( specification )) self . set_transformer_specification ( obj ) def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None def set_transformer ( self , transformer : Optional [ Union [ Transformer , Type [ Transformer ]]], ** kwargs , ): if isinstance ( transformer , Type ): transformer = transformer () transformer . specification = self . transformer_specification self . transformer = transformer def set_object_transformer ( self , transformer : Optional [ Union [ ObjectTransformer , TransformationSpecification , dict , str , Path ] ] = None , ): if transformer is None : if self . object_transformer is not None : logger . info ( \"No change\" ) return else : logger . warning ( \"No transformer specified\" ) return if transformer is not None : if isinstance ( transformer , ObjectTransformer ): self . object_transformer = transformer else : self . set_transformer_specification ( transformer ) self . object_transformer = ObjectTransformer () self . object_transformer . specification = self . transformer_specification self . _target_schema = None @property def target_schema ( self ) -> SchemaDefinition : if self . _target_schema is None : if not self . schema_mapper : self . schema_mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) self . _target_schema = self . schema_mapper . derive_schema ( self . transformer_specification ) return self . _target_schema @property def target_schemaview ( self ) -> SchemaView : if self . _target_schemaview is None : # TODO: simplify self . _target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return self . _target_schemaview def transform ( self , obj : dict , ** kwargs ) -> dict : if self . object_transformer is None : raise ValueError ( \"No transformer specified\" ) if not self . object_transformer . source_schemaview : self . object_transformer . source_schemaview = self . source_schemaview return self . object_transformer . map_object ( obj , ** kwargs ) def reverse_transform ( self , obj : dict , ** kwargs ) -> dict : inv_spec = self . invert () reverse_transformer = ObjectTransformer () reverse_transformer . specification = inv_spec reverse_transformer . source_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return reverse_transformer . map_object ( obj , ** kwargs ) def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph","title":"Session"},{"location":"api/session/#linkml_map.session.Session.graphviz","text":"Return a graphviz representation of the schema. Source code in src\\linkml_map\\session.py 159 160 161 162 163 164 165 166 167 def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph","title":"graphviz"},{"location":"api/session/#linkml_map.session.Session.invert","text":"Invert the transformer specification. Source code in src\\linkml_map\\session.py 146 147 148 149 150 151 152 153 154 155 156 157 def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec","title":"invert"},{"location":"api/session/#linkml_map.session.Session.set_source_schema","text":"Sets the schema from a path or SchemaView object. Source code in src\\linkml_map\\session.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None","title":"set_source_schema"},{"location":"api/transformer/","text":"Transformer Package Transformer (Base Class) Bases: ABC Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this Source code in src\\linkml_map\\transformer\\transformer.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @dataclass class Transformer ( ABC ): \"\"\" Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this \"\"\" specification : TransformationSpecification = None \"\"\"A specification of how to generate target objects from source objects.\"\"\" source_schemaview : SchemaView = None \"\"\"A view over the schema describing the input/source object.\"\"\" _derived_specification : TransformationSpecification = None \"\"\"A specification with inferred missing values.\"\"\" target_schemaview : Optional [ SchemaView ] = None \"\"\"A view over the schema describing the output/target object.\"\"\" unrestricted_eval : bool = field ( default = False ) \"\"\"Set to True to allow arbitrary evals as part of transformation.\"\"\" _curie_converter : Converter = None def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path ) def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) @property def derived_specification ( self ) -> Optional [ TransformationSpecification ]: if self . _derived_specification is None : if self . specification is None : return None self . _derived_specification = deepcopy ( self . specification ) induce_missing_values ( self . _derived_specification , self . source_schemaview ) return self . _derived_specification def _get_class_derivation ( self , target_class_name : str ) -> ClassDerivation : spec = self . derived_specification matching_tgt_class_derivs = [ deriv for deriv in spec . class_derivations . values () if deriv . populated_from == target_class_name or ( not deriv . populated_from and target_class_name == deriv . name ) ] logger . debug ( f \"Target class derivations= { matching_tgt_class_derivs } \" ) if len ( matching_tgt_class_derivs ) != 1 : raise ValueError ( f \"Could not find class derivation for { target_class_name } (results= { len ( matching_tgt_class_derivs ) } )\" ) cd = matching_tgt_class_derivs [ 0 ] ancmap = self . _class_derivation_ancestors ( cd ) if ancmap : cd = deepcopy ( cd ) for anc in ancmap . values (): for k , v in anc . __dict__ . items (): if v is not None and v != []: curr_v = getattr ( cd , k , None ) if isinstance ( curr_v , list ): curr_v . extend ( v ) elif isinstance ( curr_v , dict ): curr_v . update ({ ** v , ** curr_v }) else : if curr_v is None : setattr ( cd , k , v ) return cd def _class_derivation_ancestors ( self , cd : ClassDerivation ) -> Dict [ str , ClassDerivation ]: \"\"\" Returns a map of all class derivations that are ancestors of the given class derivation. :param cd: :return: \"\"\" spec = self . specification ancestors = {} parents = cd . mixins + ([ cd . is_a ] if cd . is_a else []) for parent in parents : ancestors [ parent ] = spec . class_derivations [ parent ] ancestors . update ( self . _class_derivation_ancestors ( spec . class_derivations [ parent ])) return ancestors def _get_enum_derivation ( self , target_enum_name : str ) -> EnumDerivation : spec = self . derived_specification matching_tgt_enum_derivs = [ deriv for deriv in spec . enum_derivations . values () if deriv . populated_from == target_enum_name or ( not deriv . populated_from and target_enum_name == deriv . name ) ] logger . debug ( f \"Target enum derivations= { matching_tgt_enum_derivs } \" ) if len ( matching_tgt_enum_derivs ) != 1 : raise ValueError ( f \"Could not find what to derive from a source { target_enum_name } \" ) return matching_tgt_enum_derivs [ 0 ] def _is_coerce_to_multivalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as in [ CollectionType . MultiValued , CollectionType . MultiValuedDict , CollectionType . MultiValuedDict , ]: return True if slot_derivation . stringification and slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if slot . multivalued : return True return False def _is_coerce_to_singlevalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as == CollectionType ( CollectionType . SingleValued ): return True if slot_derivation . stringification and not slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if not slot . multivalued : return True return False def _coerce_datatype ( self , v : Any , target_range : Optional [ str ]) -> Any : if target_range is None : return v if isinstance ( v , list ): return [ self . _coerce_datatype ( v1 , target_range ) for v1 in v ] if isinstance ( v , dict ): return { k : self . _coerce_datatype ( v1 , target_range ) for k , v1 in v . items ()} cmap = { \"integer\" : int , \"float\" : float , \"string\" : str , \"boolean\" : bool , } cls = cmap . get ( target_range , None ) if not cls : logger . warning ( f \"Unknown target range { target_range } \" ) return v if isinstance ( v , cls ): return v return cls ( v ) @property def curie_converter ( self ) -> Converter : if not self . _curie_converter : self . _curie_converter = Converter ([]) for prefix in self . source_schemaview . schema . prefixes . values (): self . _curie_converter . add_prefix ( prefix . prefix_prefix , prefix . prefix_reference ) for prefix in self . specification . prefixes . values (): self . _curie_converter . add_prefix ( prefix . key , prefix . value ) return self . _curie_converter def expand_curie ( self , curie : str ) -> str : return self . curie_converter . expand ( curie ) def compress_uri ( self , uri : str ) -> str : return self . curie_converter . compress ( uri ) source_schemaview : SchemaView = None class-attribute instance-attribute A view over the schema describing the input/source object. specification : TransformationSpecification = None class-attribute instance-attribute A specification of how to generate target objects from source objects. target_schemaview : Optional [ SchemaView ] = None class-attribute instance-attribute A view over the schema describing the output/target object. unrestricted_eval : bool = field ( default = False ) class-attribute instance-attribute Set to True to allow arbitrary evals as part of transformation. create_transformer_specification ( obj ) Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) load_source_schema ( path ) Sets source_schemaview from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 89 90 91 92 93 94 95 96 97 98 def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path ) load_transformer_specification ( path ) Sets specification from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) map_database ( source_database , target_database = None , ** kwargs ) Transform source resource. :param source_database: :param target_database: :param kwargs: :return: Source code in src\\linkml_map\\transformer\\transformer.py 76 77 78 79 80 81 82 83 84 85 86 87 def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError map_object ( obj , source_type = None , ** kwargs ) Transform source object into an instance of the target class. :param obj: :param source_type: :return: Source code in src\\linkml_map\\transformer\\transformer.py 66 67 68 69 70 71 72 73 74 def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError ObjectTransformer Bases: Transformer A Transformer that works on in-memory dict objects. This works recursively Source code in src\\linkml_map\\transformer\\object_transformer.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 @dataclass class ObjectTransformer ( Transformer ): \"\"\" A Transformer that works on in-memory dict objects. This works recursively \"\"\" object_index : ObjectIndex = None def index ( self , source_obj : Any , target : str = None ): \"\"\" Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into \"\"\" if isinstance ( source_obj , dict ): if target is None : [ target ] = [ c . name for c in self . source_schemaview . all_classes () . values () if c . tree_root ] if target is None : raise ValueError ( f \"target must be passed if source_obj is dict: { source_obj } \" ) source_obj_typed = dynamic_object ( source_obj , self . source_schemaview , target ) self . object_index = ObjectIndex ( source_obj_typed , schemaview = self . source_schemaview ) else : self . object_index = ObjectIndex ( source_obj , schemaview = self . source_schemaview ) def map_object ( self , source_obj : OBJECT_TYPE , source_type : str = None , target_type : str = None , ) -> Union [ DICT_OBJ , Any ]: \"\"\" Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary \"\"\" sv = self . source_schemaview if source_type is None and sv is None : # TODO: use smarter method source_type = list ( self . specification . class_derivations . values ())[ 0 ] . name if source_type is None and sv is not None : source_types = [ c . name for c in sv . all_classes () . values () if c . tree_root ] if len ( source_types ) == 1 : source_type = source_types [ 0 ] elif len ( source_types ) > 1 : raise ValueError ( \"No source type specified and multiple root classes found\" ) elif len ( source_types ) == 0 : if len ( sv . all_classes ()) == 1 : source_type = list ( sv . all_classes () . keys ())[ 0 ] else : raise ValueError ( \"No source type specified and no root classes found\" ) if source_type in sv . all_types (): if target_type : if target_type == \"string\" : return str ( source_obj ) elif target_type == \"integer\" : return int ( source_obj ) elif target_type == \"float\" or target_type == \"double\" : return float ( source_obj ) elif target_type == \"uri\" : return self . expand_curie ( source_obj ) elif target_type == \"curie\" : return self . compress_uri ( source_obj ) return source_obj if source_type in sv . all_enums (): # TODO: enum derivations return self . transform_enum ( source_obj , source_type , source_obj ) # return str(source_obj) source_obj_typed = None if isinstance ( source_obj , ( BaseModel , YAMLRoot )): # ensure dict source_obj_typed = source_obj source_obj = vars ( source_obj ) if not isinstance ( source_obj , dict ): logger . warning ( f \"Unexpected: { source_obj } for type { source_type } \" ) return source_obj class_deriv = self . _get_class_derivation ( source_type ) tgt_attrs = {} bindings = None # map each slot assignment in source_obj, if there is a slot_derivation for slot_derivation in class_deriv . slot_derivations . values (): v = None source_class_slot = None if slot_derivation . unit_conversion : v = self . _perform_unit_conversion ( slot_derivation , source_obj , sv , source_type ) elif slot_derivation . expr : if bindings is None : bindings = Bindings ( self , source_obj = source_obj , source_obj_typed = source_obj_typed , source_type = source_type , sv = sv , bindings = { \"NULL\" : None }, ) try : v = eval_expr_with_mapping ( slot_derivation . expr , bindings ) except Exception : if not self . unrestricted_eval : raise RuntimeError ( f \"Expression not in safe subset: { slot_derivation . expr } \" ) ctxt_obj , _ = bindings . get_ctxt_obj_and_dict () aeval = Interpreter ( usersyms = { \"src\" : ctxt_obj , \"target\" : None }) aeval ( slot_derivation . expr ) v = aeval . symtable [ \"target\" ] elif slot_derivation . populated_from : v = source_obj . get ( slot_derivation . populated_from , None ) source_class_slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) elif slot_derivation . sources : vmap = { s : source_obj . get ( s , None ) for s in slot_derivation . sources } vmap = { k : v for k , v in vmap . items () if v is not None } if len ( vmap . keys ()) > 1 : raise ValueError ( f \"Multiple sources for { slot_derivation . name } : { vmap } \" ) elif len ( vmap . keys ()) == 1 : v = list ( vmap . values ())[ 0 ] source_class_slot_name = list ( vmap . keys ())[ 0 ] source_class_slot = sv . induced_slot ( source_class_slot_name , source_type ) else : v = None source_class_slot = None logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) else : source_class_slot = sv . induced_slot ( slot_derivation . name , source_type ) v = source_obj . get ( slot_derivation . name , None ) if source_class_slot and v is not None : # slot is mapped and there is a value in the assignment target_range = slot_derivation . range source_class_slot_range = source_class_slot . range if source_class_slot . multivalued : if isinstance ( v , list ): v = [ self . map_object ( v1 , source_class_slot_range , target_range ) for v1 in v ] elif isinstance ( v , dict ): v = { k1 : self . map_object ( v1 , source_class_slot_range , target_range ) for k1 , v1 in v . items () } else : v = [ v ] else : v = self . map_object ( v , source_class_slot_range , target_range ) if ( self . _is_coerce_to_multivalued ( slot_derivation , class_deriv ) and v is not None and not isinstance ( v , list ) ): v = self . _singlevalued_to_multivalued ( v , slot_derivation ) if self . _is_coerce_to_singlevalued ( slot_derivation , class_deriv ) and isinstance ( v , list ): v = self . _multivalued_to_singlevalued ( v , slot_derivation ) v = self . _coerce_datatype ( v , target_range ) if slot_derivation . dictionary_key and isinstance ( v , list ): # List to CompactDict v = { v1 [ slot_derivation . dictionary_key ]: v1 for v1 in v } for v1 in v . values (): del v1 [ slot_derivation . dictionary_key ] elif ( slot_derivation . cast_collection_as and slot_derivation . cast_collection_as == CollectionType . MultiValuedList and isinstance ( v , dict ) ): # CompactDict to List src_rng = source_class_slot . range src_rng_id_slot = self . source_schemaview . get_identifier_slot ( src_rng , use_key = True ) if src_rng_id_slot : v = [{ ** v1 , src_rng_id_slot . name : k } for k , v1 in v . items ()] else : v = list ( v . values ()) tgt_attrs [ str ( slot_derivation . name )] = v return tgt_attrs def _perform_unit_conversion ( self , slot_derivation : SlotDerivation , source_obj : Any , sv : SchemaView , source_type : str ) -> Union [ float , Dict ]: uc = slot_derivation . unit_conversion curr_v = source_obj . get ( slot_derivation . populated_from , None ) system = UnitSystem . UCUM if curr_v is not None : slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) to_unit = uc . target_unit if uc . source_unit_slot : from_unit = curr_v . get ( uc . source_unit_slot , None ) if from_unit is None : raise ValueError ( f \"Could not determine unit from { curr_v } \" f \" using { uc . source_unit_slot } \" ) magnitude = curr_v . get ( uc . source_magnitude_slot , None ) if magnitude is None : raise ValueError ( f \"Could not determine magnitude from { curr_v } \" f \" using { uc . source_magnitude_slot } \" ) else : if slot . unit . ucum_code : from_unit = slot . unit . ucum_code elif slot . unit . iec61360code : from_unit = slot . unit . iec61360code system = UnitSystem . IEC61360 else : system = None if slot . unit . symbol : from_unit = slot . unit . symbol elif slot . unit . abbreviation : from_unit = slot . unit . abbreviation elif slot . unit . descriptive_name : from_unit = slot . unit . descriptive_name else : raise NotImplementedError ( f \"Cannot determine unit system for { slot . unit } \" ) magnitude = curr_v if not from_unit : raise ValueError ( f \"Could not determine from_unit for { slot_derivation } \" ) if not to_unit : to_unit = from_unit # raise ValueError(f\"Could not determine to_unit for {slot_derivation}\") if from_unit == to_unit : v = magnitude else : v = convert_units ( magnitude , from_unit = from_unit , to_unit = to_unit , system = system , ) if uc . target_magnitude_slot : v = { uc . target_magnitude_slot : v , uc . target_unit_slot : to_unit } return v def _multivalued_to_singlevalued ( self , vs : List [ Any ], slot_derivation : SlotDerivation ) -> Any : if slot_derivation . stringification : stringification = slot_derivation . stringification delimiter = stringification . delimiter if delimiter : return delimiter . join ( vs ) elif stringification . syntax : if stringification . syntax == SerializationSyntaxType . JSON : return json . dumps ( vs ) elif stringification . syntax == SerializationSyntaxType . YAML : return yaml . dump ( vs , default_flow_style = True ) . strip () else : raise ValueError ( f \"Unknown syntax: { stringification . syntax } \" ) else : raise ValueError ( f \"Cannot convert multivalued to single valued: { vs } ; no delimiter\" ) if len ( vs ) > 1 : raise ValueError ( f \"Cannot coerce multiple values { vs } \" ) if len ( vs ) == 0 : return None else : return vs [ 0 ] def _singlevalued_to_multivalued ( self , v : Any , slot_derivation : SlotDerivation ) -> List [ Any ]: stringification = slot_derivation . stringification if stringification : delimiter = stringification . delimiter if delimiter : vs = v . split ( slot_derivation . stringification . delimiter ) if vs == [ \"\" ]: vs = [] elif stringification . syntax : syntax = stringification . syntax if syntax == SerializationSyntaxType . JSON : vs = json . loads ( v ) elif syntax == SerializationSyntaxType . YAML : vs = yaml . safe_load ( v ) else : raise ValueError ( f \"Unknown syntax: { syntax } \" ) else : raise ValueError ( f \"Cannot convert single valued to multivalued: { v } ; no delimiter\" ) return vs return [ v ] def transform_object ( self , source_obj : Union [ YAMLRoot , BaseModel ], target_class : Optional [ Union [ Type [ YAMLRoot ], Type [ BaseModel ]]] = None , ) -> Union [ YAMLRoot , BaseModel ]: \"\"\" Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] \"\"\" if not target_class : raise ValueError ( \"No target_class specified for transform_object\" ) source_type = type ( source_obj ) source_type_name = source_type . __name__ # if isinstance(source_obj, YAMLRoot): # source_obj_dict = json_dumper.to_dict(source_obj) # elif isinstance(source_obj, BaseModel): # source_obj_dict = source_obj.dict() # else: # raise ValueError(f\"Do not know how to handle type: {typ}\") tr_obj_dict = self . map_object ( source_obj , source_type_name ) return target_class ( ** tr_obj_dict ) def transform_enum ( self , source_value : str , enum_name : str , source_obj : Any ) -> Optional [ str ]: enum_deriv = self . _get_enum_derivation ( enum_name ) if enum_deriv . expr : try : if enum_deriv . expr : v = eval_expr ( enum_deriv . expr , ** source_obj , NULL = None ) except Exception : aeval = Interpreter ( usersyms = { \"src\" : source_obj , \"target\" : None }) aeval ( enum_deriv . expr ) v = aeval . symtable [ \"target\" ] if v is not None : return v for pv_deriv in enum_deriv . permissible_value_derivations . values (): if source_value == pv_deriv . populated_from : return pv_deriv . name if source_value in pv_deriv . sources : return pv_deriv . name if enum_deriv . mirror_source : return str ( source_value ) else : return None index ( source_obj , target = None ) Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into Source code in src\\linkml_map\\transformer\\object_transformer.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def index ( self , source_obj : Any , target : str = None ): \"\"\" Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into \"\"\" if isinstance ( source_obj , dict ): if target is None : [ target ] = [ c . name for c in self . source_schemaview . all_classes () . values () if c . tree_root ] if target is None : raise ValueError ( f \"target must be passed if source_obj is dict: { source_obj } \" ) source_obj_typed = dynamic_object ( source_obj , self . source_schemaview , target ) self . object_index = ObjectIndex ( source_obj_typed , schemaview = self . source_schemaview ) else : self . object_index = ObjectIndex ( source_obj , schemaview = self . source_schemaview ) map_object ( source_obj , source_type = None , target_type = None ) Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary Source code in src\\linkml_map\\transformer\\object_transformer.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def map_object ( self , source_obj : OBJECT_TYPE , source_type : str = None , target_type : str = None , ) -> Union [ DICT_OBJ , Any ]: \"\"\" Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary \"\"\" sv = self . source_schemaview if source_type is None and sv is None : # TODO: use smarter method source_type = list ( self . specification . class_derivations . values ())[ 0 ] . name if source_type is None and sv is not None : source_types = [ c . name for c in sv . all_classes () . values () if c . tree_root ] if len ( source_types ) == 1 : source_type = source_types [ 0 ] elif len ( source_types ) > 1 : raise ValueError ( \"No source type specified and multiple root classes found\" ) elif len ( source_types ) == 0 : if len ( sv . all_classes ()) == 1 : source_type = list ( sv . all_classes () . keys ())[ 0 ] else : raise ValueError ( \"No source type specified and no root classes found\" ) if source_type in sv . all_types (): if target_type : if target_type == \"string\" : return str ( source_obj ) elif target_type == \"integer\" : return int ( source_obj ) elif target_type == \"float\" or target_type == \"double\" : return float ( source_obj ) elif target_type == \"uri\" : return self . expand_curie ( source_obj ) elif target_type == \"curie\" : return self . compress_uri ( source_obj ) return source_obj if source_type in sv . all_enums (): # TODO: enum derivations return self . transform_enum ( source_obj , source_type , source_obj ) # return str(source_obj) source_obj_typed = None if isinstance ( source_obj , ( BaseModel , YAMLRoot )): # ensure dict source_obj_typed = source_obj source_obj = vars ( source_obj ) if not isinstance ( source_obj , dict ): logger . warning ( f \"Unexpected: { source_obj } for type { source_type } \" ) return source_obj class_deriv = self . _get_class_derivation ( source_type ) tgt_attrs = {} bindings = None # map each slot assignment in source_obj, if there is a slot_derivation for slot_derivation in class_deriv . slot_derivations . values (): v = None source_class_slot = None if slot_derivation . unit_conversion : v = self . _perform_unit_conversion ( slot_derivation , source_obj , sv , source_type ) elif slot_derivation . expr : if bindings is None : bindings = Bindings ( self , source_obj = source_obj , source_obj_typed = source_obj_typed , source_type = source_type , sv = sv , bindings = { \"NULL\" : None }, ) try : v = eval_expr_with_mapping ( slot_derivation . expr , bindings ) except Exception : if not self . unrestricted_eval : raise RuntimeError ( f \"Expression not in safe subset: { slot_derivation . expr } \" ) ctxt_obj , _ = bindings . get_ctxt_obj_and_dict () aeval = Interpreter ( usersyms = { \"src\" : ctxt_obj , \"target\" : None }) aeval ( slot_derivation . expr ) v = aeval . symtable [ \"target\" ] elif slot_derivation . populated_from : v = source_obj . get ( slot_derivation . populated_from , None ) source_class_slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) elif slot_derivation . sources : vmap = { s : source_obj . get ( s , None ) for s in slot_derivation . sources } vmap = { k : v for k , v in vmap . items () if v is not None } if len ( vmap . keys ()) > 1 : raise ValueError ( f \"Multiple sources for { slot_derivation . name } : { vmap } \" ) elif len ( vmap . keys ()) == 1 : v = list ( vmap . values ())[ 0 ] source_class_slot_name = list ( vmap . keys ())[ 0 ] source_class_slot = sv . induced_slot ( source_class_slot_name , source_type ) else : v = None source_class_slot = None logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) else : source_class_slot = sv . induced_slot ( slot_derivation . name , source_type ) v = source_obj . get ( slot_derivation . name , None ) if source_class_slot and v is not None : # slot is mapped and there is a value in the assignment target_range = slot_derivation . range source_class_slot_range = source_class_slot . range if source_class_slot . multivalued : if isinstance ( v , list ): v = [ self . map_object ( v1 , source_class_slot_range , target_range ) for v1 in v ] elif isinstance ( v , dict ): v = { k1 : self . map_object ( v1 , source_class_slot_range , target_range ) for k1 , v1 in v . items () } else : v = [ v ] else : v = self . map_object ( v , source_class_slot_range , target_range ) if ( self . _is_coerce_to_multivalued ( slot_derivation , class_deriv ) and v is not None and not isinstance ( v , list ) ): v = self . _singlevalued_to_multivalued ( v , slot_derivation ) if self . _is_coerce_to_singlevalued ( slot_derivation , class_deriv ) and isinstance ( v , list ): v = self . _multivalued_to_singlevalued ( v , slot_derivation ) v = self . _coerce_datatype ( v , target_range ) if slot_derivation . dictionary_key and isinstance ( v , list ): # List to CompactDict v = { v1 [ slot_derivation . dictionary_key ]: v1 for v1 in v } for v1 in v . values (): del v1 [ slot_derivation . dictionary_key ] elif ( slot_derivation . cast_collection_as and slot_derivation . cast_collection_as == CollectionType . MultiValuedList and isinstance ( v , dict ) ): # CompactDict to List src_rng = source_class_slot . range src_rng_id_slot = self . source_schemaview . get_identifier_slot ( src_rng , use_key = True ) if src_rng_id_slot : v = [{ ** v1 , src_rng_id_slot . name : k } for k , v1 in v . items ()] else : v = list ( v . values ()) tgt_attrs [ str ( slot_derivation . name )] = v return tgt_attrs transform_object ( source_obj , target_class = None ) Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] Source code in src\\linkml_map\\transformer\\object_transformer.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def transform_object ( self , source_obj : Union [ YAMLRoot , BaseModel ], target_class : Optional [ Union [ Type [ YAMLRoot ], Type [ BaseModel ]]] = None , ) -> Union [ YAMLRoot , BaseModel ]: \"\"\" Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] \"\"\" if not target_class : raise ValueError ( \"No target_class specified for transform_object\" ) source_type = type ( source_obj ) source_type_name = source_type . __name__ # if isinstance(source_obj, YAMLRoot): # source_obj_dict = json_dumper.to_dict(source_obj) # elif isinstance(source_obj, BaseModel): # source_obj_dict = source_obj.dict() # else: # raise ValueError(f\"Do not know how to handle type: {typ}\") tr_obj_dict = self . map_object ( source_obj , source_type_name ) return target_class ( ** tr_obj_dict )","title":"Transformer"},{"location":"api/transformer/#transformer-package","text":"","title":"Transformer Package"},{"location":"api/transformer/#transformer-base-class","text":"Bases: ABC Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this Source code in src\\linkml_map\\transformer\\transformer.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @dataclass class Transformer ( ABC ): \"\"\" Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this \"\"\" specification : TransformationSpecification = None \"\"\"A specification of how to generate target objects from source objects.\"\"\" source_schemaview : SchemaView = None \"\"\"A view over the schema describing the input/source object.\"\"\" _derived_specification : TransformationSpecification = None \"\"\"A specification with inferred missing values.\"\"\" target_schemaview : Optional [ SchemaView ] = None \"\"\"A view over the schema describing the output/target object.\"\"\" unrestricted_eval : bool = field ( default = False ) \"\"\"Set to True to allow arbitrary evals as part of transformation.\"\"\" _curie_converter : Converter = None def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path ) def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) @property def derived_specification ( self ) -> Optional [ TransformationSpecification ]: if self . _derived_specification is None : if self . specification is None : return None self . _derived_specification = deepcopy ( self . specification ) induce_missing_values ( self . _derived_specification , self . source_schemaview ) return self . _derived_specification def _get_class_derivation ( self , target_class_name : str ) -> ClassDerivation : spec = self . derived_specification matching_tgt_class_derivs = [ deriv for deriv in spec . class_derivations . values () if deriv . populated_from == target_class_name or ( not deriv . populated_from and target_class_name == deriv . name ) ] logger . debug ( f \"Target class derivations= { matching_tgt_class_derivs } \" ) if len ( matching_tgt_class_derivs ) != 1 : raise ValueError ( f \"Could not find class derivation for { target_class_name } (results= { len ( matching_tgt_class_derivs ) } )\" ) cd = matching_tgt_class_derivs [ 0 ] ancmap = self . _class_derivation_ancestors ( cd ) if ancmap : cd = deepcopy ( cd ) for anc in ancmap . values (): for k , v in anc . __dict__ . items (): if v is not None and v != []: curr_v = getattr ( cd , k , None ) if isinstance ( curr_v , list ): curr_v . extend ( v ) elif isinstance ( curr_v , dict ): curr_v . update ({ ** v , ** curr_v }) else : if curr_v is None : setattr ( cd , k , v ) return cd def _class_derivation_ancestors ( self , cd : ClassDerivation ) -> Dict [ str , ClassDerivation ]: \"\"\" Returns a map of all class derivations that are ancestors of the given class derivation. :param cd: :return: \"\"\" spec = self . specification ancestors = {} parents = cd . mixins + ([ cd . is_a ] if cd . is_a else []) for parent in parents : ancestors [ parent ] = spec . class_derivations [ parent ] ancestors . update ( self . _class_derivation_ancestors ( spec . class_derivations [ parent ])) return ancestors def _get_enum_derivation ( self , target_enum_name : str ) -> EnumDerivation : spec = self . derived_specification matching_tgt_enum_derivs = [ deriv for deriv in spec . enum_derivations . values () if deriv . populated_from == target_enum_name or ( not deriv . populated_from and target_enum_name == deriv . name ) ] logger . debug ( f \"Target enum derivations= { matching_tgt_enum_derivs } \" ) if len ( matching_tgt_enum_derivs ) != 1 : raise ValueError ( f \"Could not find what to derive from a source { target_enum_name } \" ) return matching_tgt_enum_derivs [ 0 ] def _is_coerce_to_multivalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as in [ CollectionType . MultiValued , CollectionType . MultiValuedDict , CollectionType . MultiValuedDict , ]: return True if slot_derivation . stringification and slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if slot . multivalued : return True return False def _is_coerce_to_singlevalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as == CollectionType ( CollectionType . SingleValued ): return True if slot_derivation . stringification and not slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if not slot . multivalued : return True return False def _coerce_datatype ( self , v : Any , target_range : Optional [ str ]) -> Any : if target_range is None : return v if isinstance ( v , list ): return [ self . _coerce_datatype ( v1 , target_range ) for v1 in v ] if isinstance ( v , dict ): return { k : self . _coerce_datatype ( v1 , target_range ) for k , v1 in v . items ()} cmap = { \"integer\" : int , \"float\" : float , \"string\" : str , \"boolean\" : bool , } cls = cmap . get ( target_range , None ) if not cls : logger . warning ( f \"Unknown target range { target_range } \" ) return v if isinstance ( v , cls ): return v return cls ( v ) @property def curie_converter ( self ) -> Converter : if not self . _curie_converter : self . _curie_converter = Converter ([]) for prefix in self . source_schemaview . schema . prefixes . values (): self . _curie_converter . add_prefix ( prefix . prefix_prefix , prefix . prefix_reference ) for prefix in self . specification . prefixes . values (): self . _curie_converter . add_prefix ( prefix . key , prefix . value ) return self . _curie_converter def expand_curie ( self , curie : str ) -> str : return self . curie_converter . expand ( curie ) def compress_uri ( self , uri : str ) -> str : return self . curie_converter . compress ( uri )","title":"Transformer (Base Class)"},{"location":"api/transformer/#linkml_map.transformer.transformer.Transformer.source_schemaview","text":"A view over the schema describing the input/source object.","title":"source_schemaview"},{"location":"api/transformer/#linkml_map.transformer.transformer.Transformer.specification","text":"A specification of how to generate target objects from source objects.","title":"specification"},{"location":"api/transformer/#linkml_map.transformer.transformer.Transformer.target_schemaview","text":"A view over the schema describing the output/target object.","title":"target_schemaview"},{"location":"api/transformer/#linkml_map.transformer.transformer.Transformer.unrestricted_eval","text":"Set to True to allow arbitrary evals as part of transformation.","title":"unrestricted_eval"},{"location":"api/transformer/#linkml_map.transformer.transformer.Transformer.create_transformer_specification","text":"Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj )","title":"create_transformer_specification"},{"location":"api/transformer/#linkml_map.transformer.transformer.Transformer.load_source_schema","text":"Sets source_schemaview from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 89 90 91 92 93 94 95 96 97 98 def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path )","title":"load_source_schema"},{"location":"api/transformer/#linkml_map.transformer.transformer.Transformer.load_transformer_specification","text":"Sets specification from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj )","title":"load_transformer_specification"},{"location":"api/transformer/#linkml_map.transformer.transformer.Transformer.map_database","text":"Transform source resource. :param source_database: :param target_database: :param kwargs: :return: Source code in src\\linkml_map\\transformer\\transformer.py 76 77 78 79 80 81 82 83 84 85 86 87 def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError","title":"map_database"},{"location":"api/transformer/#linkml_map.transformer.transformer.Transformer.map_object","text":"Transform source object into an instance of the target class. :param obj: :param source_type: :return: Source code in src\\linkml_map\\transformer\\transformer.py 66 67 68 69 70 71 72 73 74 def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError","title":"map_object"},{"location":"api/transformer/#objecttransformer","text":"Bases: Transformer A Transformer that works on in-memory dict objects. This works recursively Source code in src\\linkml_map\\transformer\\object_transformer.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 @dataclass class ObjectTransformer ( Transformer ): \"\"\" A Transformer that works on in-memory dict objects. This works recursively \"\"\" object_index : ObjectIndex = None def index ( self , source_obj : Any , target : str = None ): \"\"\" Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into \"\"\" if isinstance ( source_obj , dict ): if target is None : [ target ] = [ c . name for c in self . source_schemaview . all_classes () . values () if c . tree_root ] if target is None : raise ValueError ( f \"target must be passed if source_obj is dict: { source_obj } \" ) source_obj_typed = dynamic_object ( source_obj , self . source_schemaview , target ) self . object_index = ObjectIndex ( source_obj_typed , schemaview = self . source_schemaview ) else : self . object_index = ObjectIndex ( source_obj , schemaview = self . source_schemaview ) def map_object ( self , source_obj : OBJECT_TYPE , source_type : str = None , target_type : str = None , ) -> Union [ DICT_OBJ , Any ]: \"\"\" Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary \"\"\" sv = self . source_schemaview if source_type is None and sv is None : # TODO: use smarter method source_type = list ( self . specification . class_derivations . values ())[ 0 ] . name if source_type is None and sv is not None : source_types = [ c . name for c in sv . all_classes () . values () if c . tree_root ] if len ( source_types ) == 1 : source_type = source_types [ 0 ] elif len ( source_types ) > 1 : raise ValueError ( \"No source type specified and multiple root classes found\" ) elif len ( source_types ) == 0 : if len ( sv . all_classes ()) == 1 : source_type = list ( sv . all_classes () . keys ())[ 0 ] else : raise ValueError ( \"No source type specified and no root classes found\" ) if source_type in sv . all_types (): if target_type : if target_type == \"string\" : return str ( source_obj ) elif target_type == \"integer\" : return int ( source_obj ) elif target_type == \"float\" or target_type == \"double\" : return float ( source_obj ) elif target_type == \"uri\" : return self . expand_curie ( source_obj ) elif target_type == \"curie\" : return self . compress_uri ( source_obj ) return source_obj if source_type in sv . all_enums (): # TODO: enum derivations return self . transform_enum ( source_obj , source_type , source_obj ) # return str(source_obj) source_obj_typed = None if isinstance ( source_obj , ( BaseModel , YAMLRoot )): # ensure dict source_obj_typed = source_obj source_obj = vars ( source_obj ) if not isinstance ( source_obj , dict ): logger . warning ( f \"Unexpected: { source_obj } for type { source_type } \" ) return source_obj class_deriv = self . _get_class_derivation ( source_type ) tgt_attrs = {} bindings = None # map each slot assignment in source_obj, if there is a slot_derivation for slot_derivation in class_deriv . slot_derivations . values (): v = None source_class_slot = None if slot_derivation . unit_conversion : v = self . _perform_unit_conversion ( slot_derivation , source_obj , sv , source_type ) elif slot_derivation . expr : if bindings is None : bindings = Bindings ( self , source_obj = source_obj , source_obj_typed = source_obj_typed , source_type = source_type , sv = sv , bindings = { \"NULL\" : None }, ) try : v = eval_expr_with_mapping ( slot_derivation . expr , bindings ) except Exception : if not self . unrestricted_eval : raise RuntimeError ( f \"Expression not in safe subset: { slot_derivation . expr } \" ) ctxt_obj , _ = bindings . get_ctxt_obj_and_dict () aeval = Interpreter ( usersyms = { \"src\" : ctxt_obj , \"target\" : None }) aeval ( slot_derivation . expr ) v = aeval . symtable [ \"target\" ] elif slot_derivation . populated_from : v = source_obj . get ( slot_derivation . populated_from , None ) source_class_slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) elif slot_derivation . sources : vmap = { s : source_obj . get ( s , None ) for s in slot_derivation . sources } vmap = { k : v for k , v in vmap . items () if v is not None } if len ( vmap . keys ()) > 1 : raise ValueError ( f \"Multiple sources for { slot_derivation . name } : { vmap } \" ) elif len ( vmap . keys ()) == 1 : v = list ( vmap . values ())[ 0 ] source_class_slot_name = list ( vmap . keys ())[ 0 ] source_class_slot = sv . induced_slot ( source_class_slot_name , source_type ) else : v = None source_class_slot = None logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) else : source_class_slot = sv . induced_slot ( slot_derivation . name , source_type ) v = source_obj . get ( slot_derivation . name , None ) if source_class_slot and v is not None : # slot is mapped and there is a value in the assignment target_range = slot_derivation . range source_class_slot_range = source_class_slot . range if source_class_slot . multivalued : if isinstance ( v , list ): v = [ self . map_object ( v1 , source_class_slot_range , target_range ) for v1 in v ] elif isinstance ( v , dict ): v = { k1 : self . map_object ( v1 , source_class_slot_range , target_range ) for k1 , v1 in v . items () } else : v = [ v ] else : v = self . map_object ( v , source_class_slot_range , target_range ) if ( self . _is_coerce_to_multivalued ( slot_derivation , class_deriv ) and v is not None and not isinstance ( v , list ) ): v = self . _singlevalued_to_multivalued ( v , slot_derivation ) if self . _is_coerce_to_singlevalued ( slot_derivation , class_deriv ) and isinstance ( v , list ): v = self . _multivalued_to_singlevalued ( v , slot_derivation ) v = self . _coerce_datatype ( v , target_range ) if slot_derivation . dictionary_key and isinstance ( v , list ): # List to CompactDict v = { v1 [ slot_derivation . dictionary_key ]: v1 for v1 in v } for v1 in v . values (): del v1 [ slot_derivation . dictionary_key ] elif ( slot_derivation . cast_collection_as and slot_derivation . cast_collection_as == CollectionType . MultiValuedList and isinstance ( v , dict ) ): # CompactDict to List src_rng = source_class_slot . range src_rng_id_slot = self . source_schemaview . get_identifier_slot ( src_rng , use_key = True ) if src_rng_id_slot : v = [{ ** v1 , src_rng_id_slot . name : k } for k , v1 in v . items ()] else : v = list ( v . values ()) tgt_attrs [ str ( slot_derivation . name )] = v return tgt_attrs def _perform_unit_conversion ( self , slot_derivation : SlotDerivation , source_obj : Any , sv : SchemaView , source_type : str ) -> Union [ float , Dict ]: uc = slot_derivation . unit_conversion curr_v = source_obj . get ( slot_derivation . populated_from , None ) system = UnitSystem . UCUM if curr_v is not None : slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) to_unit = uc . target_unit if uc . source_unit_slot : from_unit = curr_v . get ( uc . source_unit_slot , None ) if from_unit is None : raise ValueError ( f \"Could not determine unit from { curr_v } \" f \" using { uc . source_unit_slot } \" ) magnitude = curr_v . get ( uc . source_magnitude_slot , None ) if magnitude is None : raise ValueError ( f \"Could not determine magnitude from { curr_v } \" f \" using { uc . source_magnitude_slot } \" ) else : if slot . unit . ucum_code : from_unit = slot . unit . ucum_code elif slot . unit . iec61360code : from_unit = slot . unit . iec61360code system = UnitSystem . IEC61360 else : system = None if slot . unit . symbol : from_unit = slot . unit . symbol elif slot . unit . abbreviation : from_unit = slot . unit . abbreviation elif slot . unit . descriptive_name : from_unit = slot . unit . descriptive_name else : raise NotImplementedError ( f \"Cannot determine unit system for { slot . unit } \" ) magnitude = curr_v if not from_unit : raise ValueError ( f \"Could not determine from_unit for { slot_derivation } \" ) if not to_unit : to_unit = from_unit # raise ValueError(f\"Could not determine to_unit for {slot_derivation}\") if from_unit == to_unit : v = magnitude else : v = convert_units ( magnitude , from_unit = from_unit , to_unit = to_unit , system = system , ) if uc . target_magnitude_slot : v = { uc . target_magnitude_slot : v , uc . target_unit_slot : to_unit } return v def _multivalued_to_singlevalued ( self , vs : List [ Any ], slot_derivation : SlotDerivation ) -> Any : if slot_derivation . stringification : stringification = slot_derivation . stringification delimiter = stringification . delimiter if delimiter : return delimiter . join ( vs ) elif stringification . syntax : if stringification . syntax == SerializationSyntaxType . JSON : return json . dumps ( vs ) elif stringification . syntax == SerializationSyntaxType . YAML : return yaml . dump ( vs , default_flow_style = True ) . strip () else : raise ValueError ( f \"Unknown syntax: { stringification . syntax } \" ) else : raise ValueError ( f \"Cannot convert multivalued to single valued: { vs } ; no delimiter\" ) if len ( vs ) > 1 : raise ValueError ( f \"Cannot coerce multiple values { vs } \" ) if len ( vs ) == 0 : return None else : return vs [ 0 ] def _singlevalued_to_multivalued ( self , v : Any , slot_derivation : SlotDerivation ) -> List [ Any ]: stringification = slot_derivation . stringification if stringification : delimiter = stringification . delimiter if delimiter : vs = v . split ( slot_derivation . stringification . delimiter ) if vs == [ \"\" ]: vs = [] elif stringification . syntax : syntax = stringification . syntax if syntax == SerializationSyntaxType . JSON : vs = json . loads ( v ) elif syntax == SerializationSyntaxType . YAML : vs = yaml . safe_load ( v ) else : raise ValueError ( f \"Unknown syntax: { syntax } \" ) else : raise ValueError ( f \"Cannot convert single valued to multivalued: { v } ; no delimiter\" ) return vs return [ v ] def transform_object ( self , source_obj : Union [ YAMLRoot , BaseModel ], target_class : Optional [ Union [ Type [ YAMLRoot ], Type [ BaseModel ]]] = None , ) -> Union [ YAMLRoot , BaseModel ]: \"\"\" Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] \"\"\" if not target_class : raise ValueError ( \"No target_class specified for transform_object\" ) source_type = type ( source_obj ) source_type_name = source_type . __name__ # if isinstance(source_obj, YAMLRoot): # source_obj_dict = json_dumper.to_dict(source_obj) # elif isinstance(source_obj, BaseModel): # source_obj_dict = source_obj.dict() # else: # raise ValueError(f\"Do not know how to handle type: {typ}\") tr_obj_dict = self . map_object ( source_obj , source_type_name ) return target_class ( ** tr_obj_dict ) def transform_enum ( self , source_value : str , enum_name : str , source_obj : Any ) -> Optional [ str ]: enum_deriv = self . _get_enum_derivation ( enum_name ) if enum_deriv . expr : try : if enum_deriv . expr : v = eval_expr ( enum_deriv . expr , ** source_obj , NULL = None ) except Exception : aeval = Interpreter ( usersyms = { \"src\" : source_obj , \"target\" : None }) aeval ( enum_deriv . expr ) v = aeval . symtable [ \"target\" ] if v is not None : return v for pv_deriv in enum_deriv . permissible_value_derivations . values (): if source_value == pv_deriv . populated_from : return pv_deriv . name if source_value in pv_deriv . sources : return pv_deriv . name if enum_deriv . mirror_source : return str ( source_value ) else : return None","title":"ObjectTransformer"},{"location":"api/transformer/#linkml_map.transformer.object_transformer.ObjectTransformer.index","text":"Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into Source code in src\\linkml_map\\transformer\\object_transformer.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def index ( self , source_obj : Any , target : str = None ): \"\"\" Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into \"\"\" if isinstance ( source_obj , dict ): if target is None : [ target ] = [ c . name for c in self . source_schemaview . all_classes () . values () if c . tree_root ] if target is None : raise ValueError ( f \"target must be passed if source_obj is dict: { source_obj } \" ) source_obj_typed = dynamic_object ( source_obj , self . source_schemaview , target ) self . object_index = ObjectIndex ( source_obj_typed , schemaview = self . source_schemaview ) else : self . object_index = ObjectIndex ( source_obj , schemaview = self . source_schemaview )","title":"index"},{"location":"api/transformer/#linkml_map.transformer.object_transformer.ObjectTransformer.map_object","text":"Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary Source code in src\\linkml_map\\transformer\\object_transformer.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def map_object ( self , source_obj : OBJECT_TYPE , source_type : str = None , target_type : str = None , ) -> Union [ DICT_OBJ , Any ]: \"\"\" Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary \"\"\" sv = self . source_schemaview if source_type is None and sv is None : # TODO: use smarter method source_type = list ( self . specification . class_derivations . values ())[ 0 ] . name if source_type is None and sv is not None : source_types = [ c . name for c in sv . all_classes () . values () if c . tree_root ] if len ( source_types ) == 1 : source_type = source_types [ 0 ] elif len ( source_types ) > 1 : raise ValueError ( \"No source type specified and multiple root classes found\" ) elif len ( source_types ) == 0 : if len ( sv . all_classes ()) == 1 : source_type = list ( sv . all_classes () . keys ())[ 0 ] else : raise ValueError ( \"No source type specified and no root classes found\" ) if source_type in sv . all_types (): if target_type : if target_type == \"string\" : return str ( source_obj ) elif target_type == \"integer\" : return int ( source_obj ) elif target_type == \"float\" or target_type == \"double\" : return float ( source_obj ) elif target_type == \"uri\" : return self . expand_curie ( source_obj ) elif target_type == \"curie\" : return self . compress_uri ( source_obj ) return source_obj if source_type in sv . all_enums (): # TODO: enum derivations return self . transform_enum ( source_obj , source_type , source_obj ) # return str(source_obj) source_obj_typed = None if isinstance ( source_obj , ( BaseModel , YAMLRoot )): # ensure dict source_obj_typed = source_obj source_obj = vars ( source_obj ) if not isinstance ( source_obj , dict ): logger . warning ( f \"Unexpected: { source_obj } for type { source_type } \" ) return source_obj class_deriv = self . _get_class_derivation ( source_type ) tgt_attrs = {} bindings = None # map each slot assignment in source_obj, if there is a slot_derivation for slot_derivation in class_deriv . slot_derivations . values (): v = None source_class_slot = None if slot_derivation . unit_conversion : v = self . _perform_unit_conversion ( slot_derivation , source_obj , sv , source_type ) elif slot_derivation . expr : if bindings is None : bindings = Bindings ( self , source_obj = source_obj , source_obj_typed = source_obj_typed , source_type = source_type , sv = sv , bindings = { \"NULL\" : None }, ) try : v = eval_expr_with_mapping ( slot_derivation . expr , bindings ) except Exception : if not self . unrestricted_eval : raise RuntimeError ( f \"Expression not in safe subset: { slot_derivation . expr } \" ) ctxt_obj , _ = bindings . get_ctxt_obj_and_dict () aeval = Interpreter ( usersyms = { \"src\" : ctxt_obj , \"target\" : None }) aeval ( slot_derivation . expr ) v = aeval . symtable [ \"target\" ] elif slot_derivation . populated_from : v = source_obj . get ( slot_derivation . populated_from , None ) source_class_slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) elif slot_derivation . sources : vmap = { s : source_obj . get ( s , None ) for s in slot_derivation . sources } vmap = { k : v for k , v in vmap . items () if v is not None } if len ( vmap . keys ()) > 1 : raise ValueError ( f \"Multiple sources for { slot_derivation . name } : { vmap } \" ) elif len ( vmap . keys ()) == 1 : v = list ( vmap . values ())[ 0 ] source_class_slot_name = list ( vmap . keys ())[ 0 ] source_class_slot = sv . induced_slot ( source_class_slot_name , source_type ) else : v = None source_class_slot = None logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) else : source_class_slot = sv . induced_slot ( slot_derivation . name , source_type ) v = source_obj . get ( slot_derivation . name , None ) if source_class_slot and v is not None : # slot is mapped and there is a value in the assignment target_range = slot_derivation . range source_class_slot_range = source_class_slot . range if source_class_slot . multivalued : if isinstance ( v , list ): v = [ self . map_object ( v1 , source_class_slot_range , target_range ) for v1 in v ] elif isinstance ( v , dict ): v = { k1 : self . map_object ( v1 , source_class_slot_range , target_range ) for k1 , v1 in v . items () } else : v = [ v ] else : v = self . map_object ( v , source_class_slot_range , target_range ) if ( self . _is_coerce_to_multivalued ( slot_derivation , class_deriv ) and v is not None and not isinstance ( v , list ) ): v = self . _singlevalued_to_multivalued ( v , slot_derivation ) if self . _is_coerce_to_singlevalued ( slot_derivation , class_deriv ) and isinstance ( v , list ): v = self . _multivalued_to_singlevalued ( v , slot_derivation ) v = self . _coerce_datatype ( v , target_range ) if slot_derivation . dictionary_key and isinstance ( v , list ): # List to CompactDict v = { v1 [ slot_derivation . dictionary_key ]: v1 for v1 in v } for v1 in v . values (): del v1 [ slot_derivation . dictionary_key ] elif ( slot_derivation . cast_collection_as and slot_derivation . cast_collection_as == CollectionType . MultiValuedList and isinstance ( v , dict ) ): # CompactDict to List src_rng = source_class_slot . range src_rng_id_slot = self . source_schemaview . get_identifier_slot ( src_rng , use_key = True ) if src_rng_id_slot : v = [{ ** v1 , src_rng_id_slot . name : k } for k , v1 in v . items ()] else : v = list ( v . values ()) tgt_attrs [ str ( slot_derivation . name )] = v return tgt_attrs","title":"map_object"},{"location":"api/transformer/#linkml_map.transformer.object_transformer.ObjectTransformer.transform_object","text":"Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] Source code in src\\linkml_map\\transformer\\object_transformer.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def transform_object ( self , source_obj : Union [ YAMLRoot , BaseModel ], target_class : Optional [ Union [ Type [ YAMLRoot ], Type [ BaseModel ]]] = None , ) -> Union [ YAMLRoot , BaseModel ]: \"\"\" Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] \"\"\" if not target_class : raise ValueError ( \"No target_class specified for transform_object\" ) source_type = type ( source_obj ) source_type_name = source_type . __name__ # if isinstance(source_obj, YAMLRoot): # source_obj_dict = json_dumper.to_dict(source_obj) # elif isinstance(source_obj, BaseModel): # source_obj_dict = source_obj.dict() # else: # raise ValueError(f\"Do not know how to handle type: {typ}\") tr_obj_dict = self . map_object ( source_obj , source_type_name ) return target_class ( ** tr_obj_dict )","title":"transform_object"},{"location":"examples/MetamodelMapping/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); LinkML Metamodel Mappings The primary use case of LinkML is to map data to data . However, because the LinkML metamodel is expressed as a LinkML schema, it is possible to map to and from the metamodel itself. NOTE this workflow is not yet fully matured, and is subject to change. Creation of ad-hoc metamodel Let's assume that we have data represented using models conforming to an ad-hoc metamodel with core constructs: Schema , Table , and Column . We can create a LinkML schema that represents this metamodel as follows: import yaml from linkml_runtime.linkml_model import SlotDefinition from linkml.utils.schema_builder import SchemaBuilder sb = SchemaBuilder () sb . add_class ( \"Schema\" , tree_root = True , slots = [ SlotDefinition ( \"id\" , required = True , description = \"The name of the schema\" ), SlotDefinition ( \"tables\" , range = \"Table\" , multivalued = True , inlined_as_list = True ), ], use_attributes = True , ) sb . add_class ( \"Table\" , slots = [ SlotDefinition ( \"id\" , required = True , description = \"The name of the table\" ), SlotDefinition ( \"columns\" , range = \"Column\" , multivalued = True , inlined_as_list = True ), ], use_attributes = True , ) sb . add_class ( \"Column\" , slots = [ SlotDefinition ( \"id\" , required = True , description = \"The name of the column\" ), SlotDefinition ( \"primary_key\" , range = \"boolean\" ), SlotDefinition ( \"datatype\" , range = \"string\" ), ], use_attributes = True , ) my_metamodel = sb . as_dict () print ( yaml . dump ( sb . as_dict (), sort_keys = False )) name: test-schema id: http://example.org/test-schema default_prefix: http://example.org/test-schema/ classes: Schema: attributes: id: description: The name of the schema required: true tables: multivalued: true range: Table inlined_as_list: true tree_root: true Table: attributes: id: description: The name of the table required: true columns: multivalued: true range: Column inlined_as_list: true Column: attributes: id: description: The name of the column required: true primary_key: range: boolean datatype: range: string prefixes: {} Example schema conforming to ad-hoc metamodel Now we'll make an example schema that conforms to this metamodel; this will be a fairly boring schema with a single table Person with three columns: id , name , and description : my_schema = { \"id\" : \"my_schema\" , \"tables\" : [ { \"id\" : \"Person\" , \"columns\" : [ { \"id\" : \"id\" , \"primary_key\" : True , \"datatype\" : \"integer\" }, { \"id\" : \"name\" , \"datatype\" : \"string\" }, { \"id\" : \"description\" , \"datatype\" : \"string\" } ] }, ] } Mapping to LinkML metamodel Now we'll create mappings from the ad-hoc metamodel to the LinkML metamodel, where Table maps to a LinkML ClassDefinition , Column maps to a LinkML * SlotDefinition . metamap = { \"class_derivations\" : { \"SchemaDefinition\" : { \"populated_from\" : \"Schema\" , \"slot_derivations\" : { \"name\" : { \"populated_from\" : \"id\" , }, \"id\" : { \"expr\" : \"'https://example.org/' + id\" , }, \"classes\" : { \"populated_from\" : \"tables\" , \"dictionary_key\" : \"name\" , \"cast_collection_as\" : \"MultiValuedDict\" , }, } }, \"ClassDefinition\" : { \"populated_from\" : \"Table\" , \"slot_derivations\" : { \"name\" : { \"populated_from\" : \"id\" , }, \"attributes\" : { \"populated_from\" : \"columns\" , \"dictionary_key\" : \"name\" , \"cast_collection_as\" : \"MultiValuedDict\" , }, } }, \"SlotDefinition\" : { \"populated_from\" : \"Column\" , \"slot_derivations\" : { \"name\" : { \"populated_from\" : \"id\" , }, \"identifier\" : { \"populated_from\" : \"primary_key\" , }, \"range\" : { \"populated_from\" : \"datatype\" , }, }, }, } } from linkml_map.session import Session session = Session () session . set_source_schema ( my_metamodel ) session . set_object_transformer ( metamap ) session . transform ( my_schema ) WARNING:linkml_map.transformer.object_transformer:Unexpected: my_schema for type Schema WARNING:linkml_map.transformer.object_transformer:Unexpected: Person for type Schema WARNING:linkml_map.transformer.object_transformer:Unexpected: id for type Schema WARNING:linkml_map.transformer.object_transformer:Unexpected: True for type boolean WARNING:linkml_map.transformer.object_transformer:Unexpected: integer for type string WARNING:linkml_map.transformer.object_transformer:Unexpected: name for type Schema WARNING:linkml_map.transformer.object_transformer:Unexpected: string for type string WARNING:linkml_map.transformer.object_transformer:Unexpected: description for type Schema WARNING:linkml_map.transformer.object_transformer:Unexpected: string for type string WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition {'name': 'my_schema', 'id': 'https://example.org/my_schema', 'classes': {'Person': {'attributes': {'id': {'identifier': True, 'range': 'integer'}, 'name': {'identifier': None, 'range': 'string'}, 'description': {'identifier': None, 'range': 'string'}}}}} Customizing the LinkML model A different scenario is where you might want to customize the existing LinkML metamodel, in particular, adding additional constraints. For example: class and names MUST be alphanumeric with no spaces every element MUST have a definition TODO","title":"Metamodel Mapping"},{"location":"examples/MetamodelMapping/#linkml-metamodel-mappings","text":"The primary use case of LinkML is to map data to data . However, because the LinkML metamodel is expressed as a LinkML schema, it is possible to map to and from the metamodel itself. NOTE this workflow is not yet fully matured, and is subject to change.","title":"LinkML Metamodel Mappings"},{"location":"examples/MetamodelMapping/#creation-of-ad-hoc-metamodel","text":"Let's assume that we have data represented using models conforming to an ad-hoc metamodel with core constructs: Schema , Table , and Column . We can create a LinkML schema that represents this metamodel as follows: import yaml from linkml_runtime.linkml_model import SlotDefinition from linkml.utils.schema_builder import SchemaBuilder sb = SchemaBuilder () sb . add_class ( \"Schema\" , tree_root = True , slots = [ SlotDefinition ( \"id\" , required = True , description = \"The name of the schema\" ), SlotDefinition ( \"tables\" , range = \"Table\" , multivalued = True , inlined_as_list = True ), ], use_attributes = True , ) sb . add_class ( \"Table\" , slots = [ SlotDefinition ( \"id\" , required = True , description = \"The name of the table\" ), SlotDefinition ( \"columns\" , range = \"Column\" , multivalued = True , inlined_as_list = True ), ], use_attributes = True , ) sb . add_class ( \"Column\" , slots = [ SlotDefinition ( \"id\" , required = True , description = \"The name of the column\" ), SlotDefinition ( \"primary_key\" , range = \"boolean\" ), SlotDefinition ( \"datatype\" , range = \"string\" ), ], use_attributes = True , ) my_metamodel = sb . as_dict () print ( yaml . dump ( sb . as_dict (), sort_keys = False )) name: test-schema id: http://example.org/test-schema default_prefix: http://example.org/test-schema/ classes: Schema: attributes: id: description: The name of the schema required: true tables: multivalued: true range: Table inlined_as_list: true tree_root: true Table: attributes: id: description: The name of the table required: true columns: multivalued: true range: Column inlined_as_list: true Column: attributes: id: description: The name of the column required: true primary_key: range: boolean datatype: range: string prefixes: {}","title":"Creation of ad-hoc metamodel"},{"location":"examples/MetamodelMapping/#example-schema-conforming-to-ad-hoc-metamodel","text":"Now we'll make an example schema that conforms to this metamodel; this will be a fairly boring schema with a single table Person with three columns: id , name , and description : my_schema = { \"id\" : \"my_schema\" , \"tables\" : [ { \"id\" : \"Person\" , \"columns\" : [ { \"id\" : \"id\" , \"primary_key\" : True , \"datatype\" : \"integer\" }, { \"id\" : \"name\" , \"datatype\" : \"string\" }, { \"id\" : \"description\" , \"datatype\" : \"string\" } ] }, ] }","title":"Example schema conforming to ad-hoc metamodel"},{"location":"examples/MetamodelMapping/#mapping-to-linkml-metamodel","text":"Now we'll create mappings from the ad-hoc metamodel to the LinkML metamodel, where Table maps to a LinkML ClassDefinition , Column maps to a LinkML * SlotDefinition . metamap = { \"class_derivations\" : { \"SchemaDefinition\" : { \"populated_from\" : \"Schema\" , \"slot_derivations\" : { \"name\" : { \"populated_from\" : \"id\" , }, \"id\" : { \"expr\" : \"'https://example.org/' + id\" , }, \"classes\" : { \"populated_from\" : \"tables\" , \"dictionary_key\" : \"name\" , \"cast_collection_as\" : \"MultiValuedDict\" , }, } }, \"ClassDefinition\" : { \"populated_from\" : \"Table\" , \"slot_derivations\" : { \"name\" : { \"populated_from\" : \"id\" , }, \"attributes\" : { \"populated_from\" : \"columns\" , \"dictionary_key\" : \"name\" , \"cast_collection_as\" : \"MultiValuedDict\" , }, } }, \"SlotDefinition\" : { \"populated_from\" : \"Column\" , \"slot_derivations\" : { \"name\" : { \"populated_from\" : \"id\" , }, \"identifier\" : { \"populated_from\" : \"primary_key\" , }, \"range\" : { \"populated_from\" : \"datatype\" , }, }, }, } } from linkml_map.session import Session session = Session () session . set_source_schema ( my_metamodel ) session . set_object_transformer ( metamap ) session . transform ( my_schema ) WARNING:linkml_map.transformer.object_transformer:Unexpected: my_schema for type Schema WARNING:linkml_map.transformer.object_transformer:Unexpected: Person for type Schema WARNING:linkml_map.transformer.object_transformer:Unexpected: id for type Schema WARNING:linkml_map.transformer.object_transformer:Unexpected: True for type boolean WARNING:linkml_map.transformer.object_transformer:Unexpected: integer for type string WARNING:linkml_map.transformer.object_transformer:Unexpected: name for type Schema WARNING:linkml_map.transformer.object_transformer:Unexpected: string for type string WARNING:linkml_map.transformer.object_transformer:Unexpected: description for type Schema WARNING:linkml_map.transformer.object_transformer:Unexpected: string for type string WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range SlotDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition WARNING:linkml_map.transformer.transformer:Unknown target range ClassDefinition {'name': 'my_schema', 'id': 'https://example.org/my_schema', 'classes': {'Person': {'attributes': {'id': {'identifier': True, 'range': 'integer'}, 'name': {'identifier': None, 'range': 'string'}, 'description': {'identifier': None, 'range': 'string'}}}}}","title":"Mapping to LinkML metamodel"},{"location":"examples/MetamodelMapping/#customizing-the-linkml-model","text":"A different scenario is where you might want to customize the existing LinkML metamodel, in particular, adding additional constraints. For example: class and names MUST be alphanumeric with no spaces every element MUST have a definition TODO","title":"Customizing the LinkML model"},{"location":"examples/Tutorial-SQLCompiler/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); LinkML-Map tutorial: Compiling to SQL This tutorial walks through use of the SQL compiler import yaml Creating an example schema We will use a LinkML SchemaBuilder object to progressively build up a schema, adding additional features as we go. We'll start with a simple Person schema, with a few single valued scalar slots: from linkml.utils.schema_builder import SchemaBuilder from linkml_runtime.linkml_model import SlotDefinition sb = SchemaBuilder () sb . add_class ( \"Person\" , slots = [ SlotDefinition ( \"family_name\" , range = \"string\" ), SlotDefinition ( \"given_name\" , range = \"string\" ), SlotDefinition ( \"age_in_years\" , range = \"integer\" ), SlotDefinition ( \"height_in_cm\" , range = \"float\" ), ]) sb . add_defaults () print ( yaml . dump ( sb . as_dict (), sort_keys = False )) name: test-schema id: http://example.org/test-schema imports: - linkml:types prefixes: linkml: https://w3id.org/linkml/ test_schema: http://example.org/test-schema/ default_prefix: test_schema default_range: string slots: family_name: range: string given_name: range: string age_in_years: range: integer height_in_cm: range: float classes: Person: slots: - family_name - given_name - age_in_years - height_in_cm Creating a Transformer Session object We will use a Session object which conveniently wraps a number of different capabilities; the first of these capabilities is to map (transform) data objects from one schema to another (implicit) schema using a transformer specification ). Our initial transformer specification will be a trivial isomorphic one that: maps the Person class to an Individual class passes through name fields as-is renames measurement fields ( age_in_years and height_in_cm to age and height ) from linkml_map.session import Session session = Session () session . set_source_schema ( sb . as_dict ()) # Transformer specification (in YAML) session . set_object_transformer ( \"\"\" class_derivations: Individual: populated_from: Person slot_derivations: family_name: populated_from: family_name given_name: populated_from: given_name age: populated_from: age_in_years height: populated_from: height_in_cm \"\"\" ) Compiling target schema to SQL INSERTs The LinkML-Map framework can infer the target schema from the mapping. We will take the inferred schema and write SQL INSERT statements for it. from linkml_map.compiler.sql_compiler import SQLCompiler compiler = SQLCompiler ( source_schemaview = session . source_schemaview ) print ( compiler . create_target_ddl ( session . transformer_specification )) CREATE TABLE IF NOT EXISTS Individual ( family_name TEXT, given_name TEXT, age INTEGER, height REAL ); print ( compiler . create_ddl ( session . source_schemaview )) CREATE TABLE IF NOT EXISTS Person ( family_name TEXT, given_name TEXT, age_in_years INTEGER, height_in_cm REAL ); compiled = compiler . compile ( session . transformer_specification ) print ( compiled . serialization ) INSERT INTO Individual SELECT family_name AS family_name, given_name AS given_name, age AS age_in_years, height AS height_in_cm FROM Individual; compiler . new_table_when_transforming = True compiled = compiler . compile ( session . transformer_specification ) print ( compiled . serialization ) CREATE TABLE IF NOT EXISTS Individual family_name AS family_name, given_name AS given_name, age AS age_in_years, height AS height_in_cm); FROM Individual; import duckdb con = duckdb . connect ( database = ':memory:' )","title":"Compilation to SQL"},{"location":"examples/Tutorial-SQLCompiler/#linkml-map-tutorial-compiling-to-sql","text":"This tutorial walks through use of the SQL compiler import yaml","title":"LinkML-Map tutorial: Compiling to SQL"},{"location":"examples/Tutorial-SQLCompiler/#creating-an-example-schema","text":"We will use a LinkML SchemaBuilder object to progressively build up a schema, adding additional features as we go. We'll start with a simple Person schema, with a few single valued scalar slots: from linkml.utils.schema_builder import SchemaBuilder from linkml_runtime.linkml_model import SlotDefinition sb = SchemaBuilder () sb . add_class ( \"Person\" , slots = [ SlotDefinition ( \"family_name\" , range = \"string\" ), SlotDefinition ( \"given_name\" , range = \"string\" ), SlotDefinition ( \"age_in_years\" , range = \"integer\" ), SlotDefinition ( \"height_in_cm\" , range = \"float\" ), ]) sb . add_defaults () print ( yaml . dump ( sb . as_dict (), sort_keys = False )) name: test-schema id: http://example.org/test-schema imports: - linkml:types prefixes: linkml: https://w3id.org/linkml/ test_schema: http://example.org/test-schema/ default_prefix: test_schema default_range: string slots: family_name: range: string given_name: range: string age_in_years: range: integer height_in_cm: range: float classes: Person: slots: - family_name - given_name - age_in_years - height_in_cm","title":"Creating an example schema"},{"location":"examples/Tutorial-SQLCompiler/#creating-a-transformer-session-object","text":"We will use a Session object which conveniently wraps a number of different capabilities; the first of these capabilities is to map (transform) data objects from one schema to another (implicit) schema using a transformer specification ). Our initial transformer specification will be a trivial isomorphic one that: maps the Person class to an Individual class passes through name fields as-is renames measurement fields ( age_in_years and height_in_cm to age and height ) from linkml_map.session import Session session = Session () session . set_source_schema ( sb . as_dict ()) # Transformer specification (in YAML) session . set_object_transformer ( \"\"\" class_derivations: Individual: populated_from: Person slot_derivations: family_name: populated_from: family_name given_name: populated_from: given_name age: populated_from: age_in_years height: populated_from: height_in_cm \"\"\" )","title":"Creating a Transformer Session object"},{"location":"examples/Tutorial-SQLCompiler/#compiling-target-schema-to-sql-inserts","text":"The LinkML-Map framework can infer the target schema from the mapping. We will take the inferred schema and write SQL INSERT statements for it. from linkml_map.compiler.sql_compiler import SQLCompiler compiler = SQLCompiler ( source_schemaview = session . source_schemaview ) print ( compiler . create_target_ddl ( session . transformer_specification )) CREATE TABLE IF NOT EXISTS Individual ( family_name TEXT, given_name TEXT, age INTEGER, height REAL ); print ( compiler . create_ddl ( session . source_schemaview )) CREATE TABLE IF NOT EXISTS Person ( family_name TEXT, given_name TEXT, age_in_years INTEGER, height_in_cm REAL ); compiled = compiler . compile ( session . transformer_specification ) print ( compiled . serialization ) INSERT INTO Individual SELECT family_name AS family_name, given_name AS given_name, age AS age_in_years, height AS height_in_cm FROM Individual; compiler . new_table_when_transforming = True compiled = compiler . compile ( session . transformer_specification ) print ( compiled . serialization ) CREATE TABLE IF NOT EXISTS Individual family_name AS family_name, given_name AS given_name, age AS age_in_years, height AS height_in_cm); FROM Individual; import duckdb con = duckdb . connect ( database = ':memory:' )","title":"Compiling target schema to SQL INSERTs"},{"location":"examples/Tutorial/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); LinkML-Map tutorial This tutorial walks through basic programmatic use of the LinkML-Map framework. This is intended for Python developers - note that many of the operations here can also be performed at the command line. import yaml Creating an example schema We will use a LinkML SchemaBuilder object to progressively build up a schema, adding additional features as we go. We'll start with a simple Person schema, with a few single valued scalar slots: from linkml.utils.schema_builder import SchemaBuilder from linkml_runtime.linkml_model import SlotDefinition sb = SchemaBuilder () sb . add_class ( \"Person\" , slots = [ SlotDefinition ( \"family_name\" , range = \"string\" ), SlotDefinition ( \"given_name\" , range = \"string\" ), SlotDefinition ( \"age_in_years\" , range = \"integer\" ), SlotDefinition ( \"height_in_cm\" , range = \"float\" ), ]) sb . add_defaults () print ( yaml . dump ( sb . as_dict (), sort_keys = False )) name: test-schema id: http://example.org/test-schema imports: - linkml:types prefixes: linkml: https://w3id.org/linkml/ test_schema: http://example.org/test-schema/ default_prefix: test_schema default_range: string slots: family_name: range: string given_name: range: string age_in_years: range: integer height_in_cm: range: float classes: Person: slots: - family_name - given_name - age_in_years - height_in_cm Creating a Transformer Session object We will use a Session object which conveniently wraps a number of different capabilities; the first of these capabilities is to map (transform) data objects from one schema to another (implicit) schema using a transformer specification ). Our initial transformer specification will be a trivial isomorphic one that: maps the Person class to an Individual class passes through name fields as-is renames measurement fields ( age_in_years and height_in_cm to age and height ) from linkml_map.session import Session session = Session () session . set_source_schema ( sb . as_dict ()) # Transformer specification (in YAML) session . set_object_transformer ( \"\"\" class_derivations: Individual: populated_from: Person slot_derivations: family_name: populated_from: family_name given_name: populated_from: given_name age: populated_from: age_in_years height: populated_from: height_in_cm \"\"\" ) Visualizing transformer specifications We can visualize the transformer specification using graphviz: session . graphviz () sourcePerson Person family_name : string given_name : string age_in_years : integer height_in_cm : float targetIndividual Individual family_name : string given_name : string age : integer height : float sourcePerson:family_name->targetIndividual:family_name sourcePerson:given_name->targetIndividual:given_name sourcePerson:age_in_years->targetIndividual:age sourcePerson:height_in_cm->targetIndividual:height Transforming objects We'll next make a simple Person object. Note that for simplicity we are specifying this using a Python dictionary. The framework also works with objects instantiating either Pydantic or Dataclasses classes (use the transform_object method instead of transform ). obj = { \"given_name\" : \"Jane\" , \"family_name\" : \"Doe\" , \"age_in_years\" : 42 , \"height_in_cm\" : 180.0 , } session . transform ( obj ) {'family_name': 'Doe', 'given_name': 'Jane', 'age': 42, 'height': 180.0} This does what we expect - it renames the two fields, but leaves all values intact. Note that because we use using dictionaries here, the renaming of the class has no effect, as this is implicit with JSON/dictionaries. TODO: docs on type designator fields For command line users, the same thing can be achieved with the map-data command. Deriving target schemas LinkML-Transformer is intended as a declarative framework, in contrast to writing Python transformation code. This allows tools to introspect mappings and perform other kinds of inference. An example of this is deriving the (implicit) target schema Here we use the target_schema method on the session object to derive the target schema: from linkml_runtime.dumpers import yaml_dumper print ( yaml_dumper . dumps ( session . target_schema )) name: test-schema-derived id: http://example.org/test-schema-derived imports: - linkml:types prefixes: linkml: prefix_prefix: linkml prefix_reference: https://w3id.org/linkml/ test_schema: prefix_prefix: test_schema prefix_reference: http://example.org/test-schema/ default_prefix: http://example.org/test-schema-derived/ default_range: string classes: Individual: name: Individual attributes: family_name: name: family_name domain_of: - Person range: string given_name: name: given_name domain_of: - Person range: string age: name: age domain_of: - Person range: integer height: name: height domain_of: - Person range: float As expected, this is isomorphic to the original (source) schema, with fields and classes renamed. Using Expressions In addition to renaming fields, we can derive field values via evaluation of function expressions . You are encouraged to follow the subset of Python defined by the LinkML expression language. This provides both safety, and declarativity. However, if you need to, you can include arbitrary Python code, provided you configure the session to allow this. We'll keep the original schema, and will provide a new Transformer specification, giving an example of both string manipulation functions and arithmetic functions; the latter perform unit conversions (later on we will see more flexible and declarative ways to perform unit conversions). session . set_object_transformer ( \"\"\" class_derivations: Individual: populated_from: Person slot_derivations: name: expr: \" {given_name} + ' ' + {family_name} \" description: Concatenating given and family names note this is a bad assumption for names in general, this is just for demonstration age_in_months: expr: age_in_years * 12 height_in_meters: expr: height_in_cm / 100 \"\"\" ) Note that when we visualize this specification, dotted lines are shown indicating a relationship between source and target that is different from direct copy: session . graphviz () sourcePerson Person family_name : string given_name : string age_in_years : integer height_in_cm : float targetIndividual Individual name : string age_in_months : string height_in_meters : string sourcePerson:given_name->targetIndividual:name sourcePerson:family_name->targetIndividual:name sourcePerson:age_in_years->targetIndividual:age_in_months sourcePerson:height_in_cm->targetIndividual:height_in_meters Now we'll transform the same object as before, and see the results: session . transform ( obj ) {'name': 'Jane Doe', 'age_in_months': 504, 'height_in_meters': 1.8} As expected, we concatenated the name fields, and converted the age and height fields to different units. Let's take a look at the derived schema for this new transformation: print ( yaml_dumper . dumps ( session . target_schema )) name: test-schema-derived id: http://example.org/test-schema-derived imports: - linkml:types prefixes: linkml: prefix_prefix: linkml prefix_reference: https://w3id.org/linkml/ test_schema: prefix_prefix: test_schema prefix_reference: http://example.org/test-schema/ default_prefix: http://example.org/test-schema-derived/ default_range: string classes: Individual: name: Individual attributes: name: name: name age_in_months: name: age_in_months height_in_meters: name: height_in_meters Note that at this time, deriving ranges using expressions is not supported, so the two measurement fields are erroneously typed as having the default_range of string . However, in principle, if you use the linkml subset of Python it should be possible to infer the range of the derived field, and this may be added in future versions. Currently the tool chain is at an early stage of development. Unit conversions Next we will look at a different way of doing unit conversions. The LinkML specification allows schemas to explicitly declare the units of slots, so let's modify our schema to do this, adding a UCUM code for our height_in_cm slot: from linkml_runtime.linkml_model.units import UnitOfMeasure sb . schema . slots [ 'height_in_cm' ] . unit = UnitOfMeasure ( ucum_code = 'cm' ) session . set_source_schema ( sb . as_dict ()) print ( yaml . dump ( sb . as_dict (), sort_keys = False )) name: test-schema id: http://example.org/test-schema imports: - linkml:types prefixes: linkml: https://w3id.org/linkml/ test_schema: http://example.org/test-schema/ default_prefix: test_schema default_range: string slots: family_name: range: string given_name: range: string age_in_years: range: integer height_in_cm: range: float unit: ucum_code: cm classes: Person: slots: - family_name - given_name - age_in_years - height_in_cm Adding target_unit to transformer specification We will create a new transformer specification, focusing on the height_in_cm field. We will transform this into a height_in_meters field, and will use the target_unit field to specify the target unit. session . set_object_transformer ( \"\"\" class_derivations: Individual: populated_from: Person slot_derivations: name: expr: \" {given_name} + ' ' + {family_name} \" height_in_meters: populated_from: height_in_cm unit_conversion: target_unit: m \"\"\" ) session . transform ( obj ) {'name': 'Jane Doe', 'height_in_meters': 1.8} Units in derived schema Next we'll look at the derived target schema, and as expected we see that it has inferred the target unit for the height_in_meters field: print ( yaml_dumper . dumps ( session . target_schema )) name: test-schema-derived id: http://example.org/test-schema-derived imports: - linkml:types prefixes: linkml: prefix_prefix: linkml prefix_reference: https://w3id.org/linkml/ test_schema: prefix_prefix: test_schema prefix_reference: http://example.org/test-schema/ default_prefix: http://example.org/test-schema-derived/ default_range: string classes: Individual: name: Individual attributes: name: name: name height_in_meters: name: height_in_meters domain_of: - Person range: float unit: ucum_code: m Tabular serialization slot = sb . add_slot ( \"aliases\" , multivalued = True , range = \"string\" , replace_if_present = True ) sb . schema . classes [ 'Person' ] . slots . append ( slot . name ) session . set_source_schema ( sb . as_dict ()) session . set_object_transformer ( \"\"\" class_derivations: Individual: populated_from: Person slot_derivations: family_name: populated_from: family_name given_name: populated_from: given_name age: populated_from: age_in_years height: populated_from: height_in_cm aliases: populated_from: aliases stringification: delimiter: '|' \"\"\" ) obj = { \"given_name\" : \"Jane\" , \"family_name\" : \"Doe\" , \"age_in_years\" : 42 , \"height_in_cm\" : 180.0 , \"aliases\" : [ \"Jane\" , \"Janie\" , \"Janey\" ] } flattened = session . transform ( obj ) flattened {'family_name': 'Doe', 'given_name': 'Jane', 'age': 42, 'height': 180.0, 'aliases': 'Jane|Janie|Janey'} this can easily be serialized to a CSV/TSV Reverse transform If a transform does not contain one-way functions, it can be reversed . In this case, reversing the transform allows us to map from the tabular form back to the richer original representation. session . reverse_transform ( flattened ) {'family_name': 'Doe', 'given_name': 'Jane', 'age_in_years': 42, 'height_in_cm': 180.0, 'aliases': ['Jane', 'Janie', 'Janey']}","title":"Tutorial"},{"location":"examples/Tutorial/#linkml-map-tutorial","text":"This tutorial walks through basic programmatic use of the LinkML-Map framework. This is intended for Python developers - note that many of the operations here can also be performed at the command line. import yaml","title":"LinkML-Map tutorial"},{"location":"examples/Tutorial/#creating-an-example-schema","text":"We will use a LinkML SchemaBuilder object to progressively build up a schema, adding additional features as we go. We'll start with a simple Person schema, with a few single valued scalar slots: from linkml.utils.schema_builder import SchemaBuilder from linkml_runtime.linkml_model import SlotDefinition sb = SchemaBuilder () sb . add_class ( \"Person\" , slots = [ SlotDefinition ( \"family_name\" , range = \"string\" ), SlotDefinition ( \"given_name\" , range = \"string\" ), SlotDefinition ( \"age_in_years\" , range = \"integer\" ), SlotDefinition ( \"height_in_cm\" , range = \"float\" ), ]) sb . add_defaults () print ( yaml . dump ( sb . as_dict (), sort_keys = False )) name: test-schema id: http://example.org/test-schema imports: - linkml:types prefixes: linkml: https://w3id.org/linkml/ test_schema: http://example.org/test-schema/ default_prefix: test_schema default_range: string slots: family_name: range: string given_name: range: string age_in_years: range: integer height_in_cm: range: float classes: Person: slots: - family_name - given_name - age_in_years - height_in_cm","title":"Creating an example schema"},{"location":"examples/Tutorial/#creating-a-transformer-session-object","text":"We will use a Session object which conveniently wraps a number of different capabilities; the first of these capabilities is to map (transform) data objects from one schema to another (implicit) schema using a transformer specification ). Our initial transformer specification will be a trivial isomorphic one that: maps the Person class to an Individual class passes through name fields as-is renames measurement fields ( age_in_years and height_in_cm to age and height ) from linkml_map.session import Session session = Session () session . set_source_schema ( sb . as_dict ()) # Transformer specification (in YAML) session . set_object_transformer ( \"\"\" class_derivations: Individual: populated_from: Person slot_derivations: family_name: populated_from: family_name given_name: populated_from: given_name age: populated_from: age_in_years height: populated_from: height_in_cm \"\"\" )","title":"Creating a Transformer Session object"},{"location":"examples/Tutorial/#visualizing-transformer-specifications","text":"We can visualize the transformer specification using graphviz: session . graphviz () sourcePerson Person family_name : string given_name : string age_in_years : integer height_in_cm : float targetIndividual Individual family_name : string given_name : string age : integer height : float sourcePerson:family_name->targetIndividual:family_name sourcePerson:given_name->targetIndividual:given_name sourcePerson:age_in_years->targetIndividual:age sourcePerson:height_in_cm->targetIndividual:height","title":"Visualizing transformer specifications"},{"location":"examples/Tutorial/#transforming-objects","text":"We'll next make a simple Person object. Note that for simplicity we are specifying this using a Python dictionary. The framework also works with objects instantiating either Pydantic or Dataclasses classes (use the transform_object method instead of transform ). obj = { \"given_name\" : \"Jane\" , \"family_name\" : \"Doe\" , \"age_in_years\" : 42 , \"height_in_cm\" : 180.0 , } session . transform ( obj ) {'family_name': 'Doe', 'given_name': 'Jane', 'age': 42, 'height': 180.0} This does what we expect - it renames the two fields, but leaves all values intact. Note that because we use using dictionaries here, the renaming of the class has no effect, as this is implicit with JSON/dictionaries. TODO: docs on type designator fields For command line users, the same thing can be achieved with the map-data command.","title":"Transforming objects"},{"location":"examples/Tutorial/#deriving-target-schemas","text":"LinkML-Transformer is intended as a declarative framework, in contrast to writing Python transformation code. This allows tools to introspect mappings and perform other kinds of inference. An example of this is deriving the (implicit) target schema Here we use the target_schema method on the session object to derive the target schema: from linkml_runtime.dumpers import yaml_dumper print ( yaml_dumper . dumps ( session . target_schema )) name: test-schema-derived id: http://example.org/test-schema-derived imports: - linkml:types prefixes: linkml: prefix_prefix: linkml prefix_reference: https://w3id.org/linkml/ test_schema: prefix_prefix: test_schema prefix_reference: http://example.org/test-schema/ default_prefix: http://example.org/test-schema-derived/ default_range: string classes: Individual: name: Individual attributes: family_name: name: family_name domain_of: - Person range: string given_name: name: given_name domain_of: - Person range: string age: name: age domain_of: - Person range: integer height: name: height domain_of: - Person range: float As expected, this is isomorphic to the original (source) schema, with fields and classes renamed.","title":"Deriving target schemas"},{"location":"examples/Tutorial/#using-expressions","text":"In addition to renaming fields, we can derive field values via evaluation of function expressions . You are encouraged to follow the subset of Python defined by the LinkML expression language. This provides both safety, and declarativity. However, if you need to, you can include arbitrary Python code, provided you configure the session to allow this. We'll keep the original schema, and will provide a new Transformer specification, giving an example of both string manipulation functions and arithmetic functions; the latter perform unit conversions (later on we will see more flexible and declarative ways to perform unit conversions). session . set_object_transformer ( \"\"\" class_derivations: Individual: populated_from: Person slot_derivations: name: expr: \" {given_name} + ' ' + {family_name} \" description: Concatenating given and family names note this is a bad assumption for names in general, this is just for demonstration age_in_months: expr: age_in_years * 12 height_in_meters: expr: height_in_cm / 100 \"\"\" ) Note that when we visualize this specification, dotted lines are shown indicating a relationship between source and target that is different from direct copy: session . graphviz () sourcePerson Person family_name : string given_name : string age_in_years : integer height_in_cm : float targetIndividual Individual name : string age_in_months : string height_in_meters : string sourcePerson:given_name->targetIndividual:name sourcePerson:family_name->targetIndividual:name sourcePerson:age_in_years->targetIndividual:age_in_months sourcePerson:height_in_cm->targetIndividual:height_in_meters Now we'll transform the same object as before, and see the results: session . transform ( obj ) {'name': 'Jane Doe', 'age_in_months': 504, 'height_in_meters': 1.8} As expected, we concatenated the name fields, and converted the age and height fields to different units. Let's take a look at the derived schema for this new transformation: print ( yaml_dumper . dumps ( session . target_schema )) name: test-schema-derived id: http://example.org/test-schema-derived imports: - linkml:types prefixes: linkml: prefix_prefix: linkml prefix_reference: https://w3id.org/linkml/ test_schema: prefix_prefix: test_schema prefix_reference: http://example.org/test-schema/ default_prefix: http://example.org/test-schema-derived/ default_range: string classes: Individual: name: Individual attributes: name: name: name age_in_months: name: age_in_months height_in_meters: name: height_in_meters Note that at this time, deriving ranges using expressions is not supported, so the two measurement fields are erroneously typed as having the default_range of string . However, in principle, if you use the linkml subset of Python it should be possible to infer the range of the derived field, and this may be added in future versions. Currently the tool chain is at an early stage of development.","title":"Using Expressions"},{"location":"examples/Tutorial/#unit-conversions","text":"Next we will look at a different way of doing unit conversions. The LinkML specification allows schemas to explicitly declare the units of slots, so let's modify our schema to do this, adding a UCUM code for our height_in_cm slot: from linkml_runtime.linkml_model.units import UnitOfMeasure sb . schema . slots [ 'height_in_cm' ] . unit = UnitOfMeasure ( ucum_code = 'cm' ) session . set_source_schema ( sb . as_dict ()) print ( yaml . dump ( sb . as_dict (), sort_keys = False )) name: test-schema id: http://example.org/test-schema imports: - linkml:types prefixes: linkml: https://w3id.org/linkml/ test_schema: http://example.org/test-schema/ default_prefix: test_schema default_range: string slots: family_name: range: string given_name: range: string age_in_years: range: integer height_in_cm: range: float unit: ucum_code: cm classes: Person: slots: - family_name - given_name - age_in_years - height_in_cm","title":"Unit conversions"},{"location":"examples/Tutorial/#adding-target_unit-to-transformer-specification","text":"We will create a new transformer specification, focusing on the height_in_cm field. We will transform this into a height_in_meters field, and will use the target_unit field to specify the target unit. session . set_object_transformer ( \"\"\" class_derivations: Individual: populated_from: Person slot_derivations: name: expr: \" {given_name} + ' ' + {family_name} \" height_in_meters: populated_from: height_in_cm unit_conversion: target_unit: m \"\"\" ) session . transform ( obj ) {'name': 'Jane Doe', 'height_in_meters': 1.8}","title":"Adding target_unit to transformer specification"},{"location":"examples/Tutorial/#units-in-derived-schema","text":"Next we'll look at the derived target schema, and as expected we see that it has inferred the target unit for the height_in_meters field: print ( yaml_dumper . dumps ( session . target_schema )) name: test-schema-derived id: http://example.org/test-schema-derived imports: - linkml:types prefixes: linkml: prefix_prefix: linkml prefix_reference: https://w3id.org/linkml/ test_schema: prefix_prefix: test_schema prefix_reference: http://example.org/test-schema/ default_prefix: http://example.org/test-schema-derived/ default_range: string classes: Individual: name: Individual attributes: name: name: name height_in_meters: name: height_in_meters domain_of: - Person range: float unit: ucum_code: m","title":"Units in derived schema"},{"location":"examples/Tutorial/#tabular-serialization","text":"slot = sb . add_slot ( \"aliases\" , multivalued = True , range = \"string\" , replace_if_present = True ) sb . schema . classes [ 'Person' ] . slots . append ( slot . name ) session . set_source_schema ( sb . as_dict ()) session . set_object_transformer ( \"\"\" class_derivations: Individual: populated_from: Person slot_derivations: family_name: populated_from: family_name given_name: populated_from: given_name age: populated_from: age_in_years height: populated_from: height_in_cm aliases: populated_from: aliases stringification: delimiter: '|' \"\"\" ) obj = { \"given_name\" : \"Jane\" , \"family_name\" : \"Doe\" , \"age_in_years\" : 42 , \"height_in_cm\" : 180.0 , \"aliases\" : [ \"Jane\" , \"Janie\" , \"Janey\" ] } flattened = session . transform ( obj ) flattened {'family_name': 'Doe', 'given_name': 'Jane', 'age': 42, 'height': 180.0, 'aliases': 'Jane|Janie|Janey'} this can easily be serialized to a CSV/TSV","title":"Tabular serialization"},{"location":"examples/Tutorial/#reverse-transform","text":"If a transform does not contain one-way functions, it can be reversed . In this case, reversing the transform allows us to map from the tabular form back to the richer original representation. session . reverse_transform ( flattened ) {'family_name': 'Doe', 'given_name': 'Jane', 'age_in_years': 42, 'height_in_cm': 180.0, 'aliases': ['Jane', 'Janie', 'Janey']}","title":"Reverse transform"},{"location":"examples/biolink-subsetting/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Biolink Model Subsetting This notebook demonstrates how to subset the Biolink Model using the Biolink Model schema and a transformation specification in two different ways: first using a transformation specification defined manually in YAML and loaded from the filesystem, and second, using a subset of classes retrieved using SchemaView dynamically. First, we import several LinkML helper packages including SchemaView: https://linkml.io/linkml/developers/schemaview.html SchemaView is a LinkML schema introspection tool that provides helpful functions to retrieve model elements by name. It also supports navigating ancestors and descendants of any model element, including classes, slots, types, and permissible values in enumerations. from pathlib import Path from pytest import fixture from linkml_runtime.dumpers import yaml_dumper from linkml_map.datamodel.transformer_model import TransformationSpecification , ClassDerivation , SlotDerivation , CopyDirective from linkml_map.inference.schema_mapper import SchemaMapper from linkml_map.session import Session from linkml_runtime.utils.schemaview import SchemaView from linkml_map.utils.loaders import load_specification from linkml_runtime.utils.formatutils import camelcase , underscore from pprint import pprint REPO_ROOT = Path . cwd () . parent . parent SchemaView can accept a variety of imports to initialize, including a Path or string representation of a Path or (as we do in this case), a URL of a raw LinkML schema. schema_url = \"https://raw.githubusercontent.com/biolink/biolink-model/master/biolink-model.yaml\" sv = SchemaView ( schema_url ) Creating a Transformation Specification Manually in YAML format. In our first example, we develop a \"Transform Specification\" for Biolink Model using Class and Slot Derivations as defined by the linkml-map transformation language. More about that here: https://linkml.io/linkml-map/#TransformationSpecification/ transform_file = REPO_ROOT / \"tests/input/examples/biolink/transform/biolink-example-profile.transform.yaml\" # Initialize Session and SchemaBuilder session = Session () # Set the source schema in the session session . set_source_schema ( sv ) tr_spec = load_specification ( transform_file ) mapper = SchemaMapper () mapper . source_schemaview = sv target_schema_obj = mapper . derive_schema ( specification = tr_spec , target_schema_id = \"biolink-profile\" , target_schema_name = \"BiolinkProfile\" ) yaml_dumper . dump ( target_schema_obj , \"biolink-profile.yaml\" ) transformed_sv = SchemaView ( \"biolink-profile.yaml\" ) for class_name in transformed_sv . all_classes (): print ( class_name ) print () for slot_name in transformed_sv . all_slots (): print ( slot_name ) NamedThing Gene Disease PhenotypicFeature Association GeneToPhenotypicFeatureAssociation id name category symbol subject predicate object ! gen - pydantic biolink - profile . yaml Exception: range: label type Note: * Still in development is the tracing of provenance between a source schema and a destination schema. Right now there is no provenance. * If a class, slot, enum, or type is not included at all in the Derivation, it will not be pushed forward to the destination schema. In development is an option to pull all non-specified components of the source model into the destination model. * You can do transformations on a derivation as well, see: https://linkml.io/linkml-map/#examples/Tutorial/#using-expressions * You can transform data as well as schemas, but this is currently \"beta\" level development. * Custom types are not pulled forward; this is a result of an error at the moment. Creating a TransformationSpecification using SchemaView and an existing model. In our second example, we use the Biolink Model directly to derive classes and slots programmatically according to a simple list of \"subset classes\" that we want to extract from the main model in order to produce a subset model according to our specification. First, we write a method to extract the classes and slots from Biolink Model using SchemaView def get_biolink_class_derivations ( sv , subset_classes ) -& gt ; dict : \"\"\" Function to get Biolink class definitions :param sv: SchemaView object :param subset_classes: List of classes to subset :return: Dictionary of class derivations incl slot derivations \"\"\" # Example implementation to fetch class definitions # This should be replaced with the actual implementation class_derivations = {} for class_name in subset_classes : class_derivation = ClassDerivation ( populated_from = class_name , name = camelcase ( class_name )) induced_slots = sv . class_induced_slots ( class_name ) for slot in induced_slots : slot_derivation = SlotDerivation ( populated_from = slot . name , name = underscore ( slot . name )) class_derivation . slot_derivations [ underscore ( slot . name )] = slot_derivation class_derivations [ camelcase ( class_name )] = class_derivation return class_derivations def get_biolink_class_derivations_direct ( sv , subset_classes ) -& gt ; dict : \"\"\" Function to get Biolink class definitions :param sv: SchemaView object :param subset_classes: List of classes to subset :return: Dictionary of class derivations incl slot derivations \"\"\" # Example implementation to fetch class definitions # This should be replaced with the actual implementation class_derivations = {} for class_name in subset_classes : class_derivation = ClassDerivation ( populated_from = class_name , name = camelcase ( class_name )) for slot in sv . get_class ( class_name ) . slots : slot_derivation = SlotDerivation ( populated_from = slot , name = underscore ( slot )) class_derivation . slot_derivations [ underscore ( slot )] = slot_derivation class_derivations [ camelcase ( class_name )] = class_derivation return class_derivations session = Session () # Set the source schema in the session session . set_source_schema ( sv ) subset_classes = [ \"gene\" , \"disease\" , \"case to phenotypic feature association\" , \"gene to disease association\" , \"gene to phenotypic feature association\" , \"case\" , \"phenotypic feature\" , ] class_derivations = get_biolink_class_derivations_direct ( sv , subset_classes ) copy_type_directives = { type_name : CopyDirective ( element_name = type_name , copy_all = False ) for type_name , type_def in sv . all_types () . items () } ts = TransformationSpecification ( class_derivations = class_derivations , copy_directives = copy_type_directives ) mapper = SchemaMapper () mapper . source_schemaview = sv target_schema_obj = mapper . derive_schema ( specification = ts , target_schema_id = \"biolink-subset\" , target_schema_name = \"BiolinkSubset\" ) # ugly bit of hacking to demonstrate end-to-end functionality target_schema_obj . types = sv . all_types () yaml_dumper . dump ( target_schema_obj , \"biolink-subset.yaml\" ) transformed_sv = SchemaView ( \"biolink-subset.yaml\" ) for class_name in transformed_sv . all_classes (): print ( \"class derived: \" , class_name ) for slot_name in transformed_sv . all_slots (): print ( \"slot derived: \" , slot_name ) for type_name in transformed_sv . all_types (): print ( \"type copied: \" , type_name ) class derived: Gene class derived: Disease class derived: CaseToPhenotypicFeatureAssociation class derived: GeneToDiseaseAssociation class derived: GeneToPhenotypicFeatureAssociation class derived: Case class derived: PhenotypicFeature slot derived: symbol slot derived: xref slot derived: has_biological_sequence slot derived: id slot derived: in_taxon slot derived: in_taxon_label slot derived: provided_by slot derived: full_name slot derived: synonym slot derived: iri slot derived: category slot derived: type slot derived: name slot derived: description slot derived: has_attribute slot derived: deprecated slot derived: subject slot derived: predicate slot derived: object slot derived: sex_qualifier slot derived: disease_context_qualifier slot derived: subject_specialization_qualifier slot derived: object_specialization_qualifier slot derived: anatomical_context_qualifier slot derived: negated slot derived: qualifier slot derived: qualifiers slot derived: publications slot derived: has_evidence slot derived: knowledge_source slot derived: primary_knowledge_source slot derived: aggregator_knowledge_source slot derived: knowledge_level slot derived: agent_type slot derived: timepoint slot derived: original_subject slot derived: original_predicate slot derived: original_object slot derived: subject_category slot derived: object_category slot derived: subject_closure slot derived: object_closure slot derived: subject_category_closure slot derived: object_category_closure slot derived: subject_namespace slot derived: object_namespace slot derived: subject_label_closure slot derived: object_label_closure slot derived: retrieval_source_ids slot derived: p_value slot derived: adjusted_p_value slot derived: has_supporting_studies slot derived: has_count slot derived: has_total slot derived: has_quotient slot derived: has_percentage slot derived: subject_aspect_qualifier slot derived: subject_direction_qualifier slot derived: object_aspect_qualifier slot derived: object_direction_qualifier slot derived: qualified_predicate slot derived: frequency_qualifier type copied: string type copied: integer type copied: boolean type copied: float type copied: double type copied: decimal type copied: time type copied: date type copied: datetime type copied: date_or_datetime type copied: uriorcurie type copied: curie type copied: uri type copied: ncname type copied: objectidentifier type copied: nodeidentifier type copied: jsonpointer type copied: jsonpath type copied: sparqlpath type copied: chemical formula value type copied: iri type type copied: label type type copied: predicate type type copied: narrative text type copied: symbol type type copied: frequency value type copied: percentage frequency value type copied: quotient type copied: unit type copied: time type type copied: biological sequence # print the content of the new schema in LinkML YAML format to view here in the notebook yaml_content = yaml_dumper . dumps ( target_schema_obj ) # Serialize to a string print ( yaml_content ) name: BiolinkSubset id: biolink-subset imports: - linkml:types prefixes: AGRKB: prefix_prefix: AGRKB prefix_reference: https://www.alliancegenome.org/ apollo: prefix_prefix: apollo prefix_reference: https://github.com/GMOD/Apollo AspGD: prefix_prefix: AspGD prefix_reference: http://www.aspergillusgenome.org/cgi-bin/locus.pl?dbid= biolink: prefix_prefix: biolink prefix_reference: https://w3id.org/biolink/vocab/ bioschemas: prefix_prefix: bioschemas prefix_reference: https://bioschemas.org/ linkml: prefix_prefix: linkml prefix_reference: https://w3id.org/linkml/ CAID: prefix_prefix: CAID prefix_reference: http://reg.clinicalgenome.org/redmine/projects/registry/genboree_registry/by_caid?caid= CHADO: prefix_prefix: CHADO prefix_reference: http://gmod.org/wiki/Chado/ ChemBank: prefix_prefix: ChemBank prefix_reference: http://chembank.broadinstitute.org/chemistry/viewMolecule.htm?cbid= CHEMBL.MECHANISM: prefix_prefix: CHEMBL.MECHANISM prefix_reference: https://www.ebi.ac.uk/chembl/mechanism/inspect/ CID: prefix_prefix: CID prefix_reference: http://pubchem.ncbi.nlm.nih.gov/compound/ CLINVAR: prefix_prefix: CLINVAR prefix_reference: http://identifiers.org/clinvar COAR_RESOURCE: prefix_prefix: COAR_RESOURCE prefix_reference: http://purl.org/coar/resource_type/ COG: prefix_prefix: COG prefix_reference: https://www.ncbi.nlm.nih.gov/research/cog-project/ ComplexPortal: prefix_prefix: ComplexPortal prefix_reference: https://www.ebi.ac.uk/complexportal/complex/ CPT: prefix_prefix: CPT prefix_reference: https://www.ama-assn.org/practice-management/cpt/ CTD.CHEMICAL: prefix_prefix: CTD.CHEMICAL prefix_reference: http://ctdbase.org/detail.go?type=chem&acc= CTD.DISEASE: prefix_prefix: CTD.DISEASE prefix_reference: http://ctdbase.org/detail.go?type=disease&db=MESH&acc= CTD.GENE: prefix_prefix: CTD.GENE prefix_reference: http://ctdbase.org/detail.go?type=gene&acc= CTD: prefix_prefix: CTD prefix_reference: http://ctdbase.org/ DGIdb: prefix_prefix: DGIdb prefix_reference: https://www.dgidb.org/interaction_types dcat: prefix_prefix: dcat prefix_reference: http://www.w3.org/ns/dcat# dct: prefix_prefix: dct prefix_reference: http://purl.org/dc/terms/ dcid: prefix_prefix: dcid prefix_reference: https://datacommons.org/browser/ doi: prefix_prefix: doi prefix_reference: https://doi.org/ DOID-PROPERTY: prefix_prefix: DOID-PROPERTY prefix_reference: http://purl.obolibrary.org/obo/doid# DrugCentral: prefix_prefix: DrugCentral prefix_reference: http://drugcentral.org/drugcard/ ECTO: prefix_prefix: ECTO prefix_reference: http://purl.obolibrary.org/obo/ECTO_ EDAM-DATA: prefix_prefix: EDAM-DATA prefix_reference: http://edamontology.org/data_ EDAM-FORMAT: prefix_prefix: EDAM-FORMAT prefix_reference: http://edamontology.org/format_ EDAM-OPERATION: prefix_prefix: EDAM-OPERATION prefix_reference: http://edamontology.org/operation_ EDAM-TOPIC: prefix_prefix: EDAM-TOPIC prefix_reference: http://edamontology.org/topic_ EFO: prefix_prefix: EFO prefix_reference: http://www.ebi.ac.uk/efo/EFO_ ExO: prefix_prefix: ExO prefix_reference: http://purl.obolibrary.org/obo/ExO_ fabio: prefix_prefix: fabio prefix_reference: http://purl.org/spar/fabio/ foaf: prefix_prefix: foaf prefix_reference: http://xmlns.com/foaf/0.1/ foodb.compound: prefix_prefix: foodb.compound prefix_reference: http://foodb.ca/compounds/ foodb.food: prefix_prefix: foodb.food prefix_reference: http://foodb.ca/foods/ FYECO: prefix_prefix: FYECO prefix_reference: https://www.pombase.org/term/ FYPO: prefix_prefix: FYPO prefix_reference: http://purl.obolibrary.org/obo/FYPO_ gff3: prefix_prefix: gff3 prefix_reference: https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md# GOREL: prefix_prefix: GOREL prefix_reference: http://purl.obolibrary.org/obo/GOREL_ GOP: prefix_prefix: GOP prefix_reference: http://purl.obolibrary.org/obo/go# gpi: prefix_prefix: gpi prefix_reference: https://github.com/geneontology/go-annotation/blob/master/specs/gpad-gpi-2-0.md# GSID: prefix_prefix: GSID prefix_reference: https://scholar.google.com/citations?user= GTEx: prefix_prefix: GTEx prefix_reference: https://www.gtexportal.org/home/gene/ GTOPDB: prefix_prefix: GTOPDB prefix_reference: https://www.guidetopharmacology.org/GRAC/LigandDisplayForward?ligandId= gtpo: prefix_prefix: gtpo prefix_reference: https://rdf.guidetopharmacology.org/ns/gtpo# HANCESTRO: prefix_prefix: HANCESTRO prefix_reference: http://www.ebi.ac.uk/ancestro/ancestro_ HCPCS: prefix_prefix: HCPCS prefix_reference: http://purl.bioontology.org/ontology/HCPCS/ HsapDv: prefix_prefix: HsapDv prefix_reference: http://purl.obolibrary.org/obo/HsapDv_ ICD10: prefix_prefix: ICD10 prefix_reference: https://icd.codes/icd9cm/ ICD9: prefix_prefix: ICD9 prefix_reference: http://translator.ncats.nih.gov/ICD9_ interpro: prefix_prefix: interpro prefix_reference: https://www.ebi.ac.uk/interpro/entry/ INO: prefix_prefix: INO prefix_reference: http://purl.obolibrary.org/obo/INO_ isbn: prefix_prefix: isbn prefix_reference: https://www.isbn-international.org/identifier/ isni: prefix_prefix: isni prefix_reference: https://isni.org/isni/ issn: prefix_prefix: issn prefix_reference: https://portal.issn.org/resource/ISSN/ ncats.drug: prefix_prefix: ncats.drug prefix_reference: https://drugs.ncats.io/drug/ KEGG.BRITE: prefix_prefix: KEGG.BRITE prefix_reference: 'https://bioregistry.io/kegg.brite:' KEGG: prefix_prefix: KEGG prefix_reference: http://www.kegg.jp/entry/ KEGG.GENES: prefix_prefix: KEGG.GENES prefix_reference: 'https://bioregistry.io/kegg.genes:bsu:' KEGG.PATHWAY: prefix_prefix: KEGG.PATHWAY prefix_reference: 'https://bioregistry.io/kegg.pathway:' KEGG.RCLASS: prefix_prefix: KEGG.RCLASS prefix_reference: 'https://www.genome.jp/dbget-bin/www_bget?rc:' LOINC: prefix_prefix: LOINC prefix_reference: http://loinc.org/rdf/ MAXO: prefix_prefix: MAXO prefix_reference: http://purl.obolibrary.org/obo/MAXO_ medgen: prefix_prefix: medgen prefix_reference: https://www.ncbi.nlm.nih.gov/medgen/ metacyc.reaction: prefix_prefix: metacyc.reaction prefix_reference: 'http://identifiers.org/metacyc.reaction:' METANETX.REACTION: prefix_prefix: METANETX.REACTION prefix_reference: https://www.metanetx.org/equa_info/ MESH: prefix_prefix: MESH prefix_reference: http://id.nlm.nih.gov/mesh/ MI: prefix_prefix: MI prefix_reference: http://purl.obolibrary.org/obo/MI_ mirbase: prefix_prefix: mirbase prefix_reference: http://identifiers.org/mirbase mmmp.biomaps: prefix_prefix: mmmp.biomaps prefix_reference: 'https://bioregistry.io/mmmp.biomaps:' MmusDv: prefix_prefix: MmusDv prefix_reference: http://purl.obolibrary.org/obo/MMUSDV_ MSigDB: prefix_prefix: MSigDB prefix_reference: https://www.gsea-msigdb.org/gsea/msigdb/ NBO-PROPERTY: prefix_prefix: NBO-PROPERTY prefix_reference: http://purl.obolibrary.org/obo/nbo# ncats.bioplanet: prefix_prefix: ncats.bioplanet prefix_reference: https://tripod.nih.gov/bioplanet/detail.jsp?pid= NCBIGene: prefix_prefix: NCBIGene prefix_reference: http://identifiers.org/ncbigene/ NCIT-OBO: prefix_prefix: NCIT-OBO prefix_reference: http://purl.obolibrary.org/obo/ncit# NDDF: prefix_prefix: NDDF prefix_reference: http://purl.bioontology.org/ontology/NDDF/ NLMID: prefix_prefix: NLMID prefix_reference: https://www.ncbi.nlm.nih.gov/nlmcatalog/?term= OBAN: prefix_prefix: OBAN prefix_reference: http://purl.org/oban/ OMIM.PS: prefix_prefix: OMIM.PS prefix_reference: https://www.omim.org/phenotypicSeries/ ORCID: prefix_prefix: ORCID prefix_reference: https://orcid.org/ orphanet: prefix_prefix: orphanet prefix_reference: http://www.orpha.net/ORDO/Orphanet_ os: prefix_prefix: os prefix_reference: https://github.com/cmungall/owlstar/blob/master/owlstar.ttl PANTHER.FAMILY: prefix_prefix: PANTHER.FAMILY prefix_reference: http://www.pantherdb.org/panther/family.do?clsAccession= PathWhiz: prefix_prefix: PathWhiz prefix_reference: http://smpdb.ca/pathways/# pav: prefix_prefix: pav prefix_reference: http://purl.org/pav/ PHARMGKB.DRUG: prefix_prefix: PHARMGKB.DRUG prefix_reference: https://www.pharmgkb.org/chemical/ PHARMGKB.DISEASE: prefix_prefix: PHARMGKB.DISEASE prefix_reference: https://www.pharmgkb.org/disease/ PHARMGKB.GENE: prefix_prefix: PHARMGKB.GENE prefix_reference: https://www.pharmgkb.org/gene/ PHARMGKB.PATHWAYS: prefix_prefix: PHARMGKB.PATHWAYS prefix_reference: https://www.pharmgkb.org/pathway/ PHARMGKB.VARIANT: prefix_prefix: PHARMGKB.VARIANT prefix_reference: https://www.pharmgkb.org/variant/ PHAROS: prefix_prefix: PHAROS prefix_reference: http://pharos.nih.gov PomBase: prefix_prefix: PomBase prefix_reference: https://www.pombase.org/gene/ prov: prefix_prefix: prov prefix_reference: http://www.w3.org/ns/prov# qud: prefix_prefix: qud prefix_reference: http://qudt.org/1.1/schema/qudt# REPODB: prefix_prefix: REPODB prefix_reference: http://apps.chiragjpgroup.org/repoDB/ ResearchID: prefix_prefix: ResearchID prefix_reference: https://publons.com/researcher/ RO: prefix_prefix: RO prefix_reference: http://purl.obolibrary.org/obo/RO_ RXNORM: prefix_prefix: RXNORM prefix_reference: http://purl.bioontology.org/ontology/RXNORM/ RXCUI: prefix_prefix: RXCUI prefix_reference: https://mor.nlm.nih.gov/RxNav/search?searchBy=RXCUI&searchTerm= schema: prefix_prefix: schema prefix_reference: http://schema.org/ ScopusID: prefix_prefix: ScopusID prefix_reference: https://www.scopus.com/authid/detail.uri?authorId= SEED.REACTION: prefix_prefix: SEED.REACTION prefix_reference: https://modelseed.org/biochem/reactions/ SEMMEDDB: prefix_prefix: SEMMEDDB prefix_reference: https://skr3.nlm.nih.gov/SemMedDB SIO: prefix_prefix: SIO prefix_reference: http://semanticscience.org/resource/SIO_ SNOMEDCT: prefix_prefix: SNOMEDCT prefix_reference: http://snomed.info/id/ SPDI: prefix_prefix: SPDI prefix_reference: https://api.ncbi.nlm.nih.gov/variation/v0/spdi/ UBERGRAPH: prefix_prefix: UBERGRAPH prefix_reference: http://translator.renci.org/ubergraph-axioms.ofn# UBERON_CORE: prefix_prefix: UBERON_CORE prefix_reference: http://purl.obolibrary.org/obo/uberon/core# UBERON_NONAMESPACE: prefix_prefix: UBERON_NONAMESPACE prefix_reference: http://purl.obolibrary.org/obo/core# STY: prefix_prefix: STY prefix_reference: http://purl.bioontology.org/ontology/STY/ UMLSSG: prefix_prefix: UMLSSG prefix_reference: https://lhncbc.nlm.nih.gov/semanticnetwork/download/sg_archive/SemGroups-v04.txt UniProtKB: prefix_prefix: UniProtKB prefix_reference: http://purl.uniprot.org/uniprot/ UNIPROT.ISOFORM: prefix_prefix: UNIPROT.ISOFORM prefix_reference: http://purl.uniprot.org/isoforms/ VANDF: prefix_prefix: VANDF prefix_reference: https://www.nlm.nih.gov/research/umls/sourcereleasedocs/current/VANDF/ UO-PROPERTY: prefix_prefix: UO-PROPERTY prefix_reference: http://purl.obolibrary.org/obo/uo# VMC: prefix_prefix: VMC prefix_reference: https://github.com/ga4gh/vr-spec/ WBls: prefix_prefix: WBls prefix_reference: http://purl.obolibrary.org/obo/WBls_ WBbt: prefix_prefix: WBbt prefix_reference: http://purl.obolibrary.org/obo/WBbt_ WBVocab: prefix_prefix: WBVocab prefix_reference: http://bio2rdf.org/wormbase_vocabulary WIKIDATA: prefix_prefix: WIKIDATA prefix_reference: https://www.wikidata.org/entity/ WIKIDATA_PROPERTY: prefix_prefix: WIKIDATA_PROPERTY prefix_reference: https://www.wikidata.org/prop/ wgs: prefix_prefix: wgs prefix_reference: http://www.w3.org/2003/01/geo/wgs84_pos XPO: prefix_prefix: XPO prefix_reference: http://purl.obolibrary.org/obo/XPO_ Xenbase: prefix_prefix: Xenbase prefix_reference: http://www.xenbase.org/gene/showgene.do?method=display&geneId= PMC: prefix_prefix: PMC prefix_reference: http://europepmc.org/articles/PMC default_prefix: biolink-subset/ default_range: string types: string: name: string description: A character string notes: - In RDF serializations, a slot with range of string is treated as a literal or type xsd:string. If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"string\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Text base: str uri: xsd:string integer: name: integer description: An integer notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"integer\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Integer base: int uri: xsd:integer boolean: name: boolean description: A binary (true or false) value notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"boolean\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Boolean base: Bool uri: xsd:boolean repr: bool float: name: float description: A real number that conforms to the xsd:float specification notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"float\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Float base: float uri: xsd:float double: name: double description: A real number that conforms to the xsd:double specification notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"double\". from_schema: https://w3id.org/linkml/types close_mappings: - schema:Float base: float uri: xsd:double decimal: name: decimal description: A real number with arbitrary precision that conforms to the xsd:decimal specification notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"decimal\". from_schema: https://w3id.org/linkml/types broad_mappings: - schema:Number base: Decimal uri: xsd:decimal time: name: time description: A time object represents a (local) time of day, independent of any particular day notes: - URI is dateTime because OWL reasoners do not work with straight date or time - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"time\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Time base: XSDTime uri: xsd:time repr: str date: name: date description: a date (year, month and day) in an idealized calendar notes: - URI is dateTime because OWL reasoners don't work with straight date or time - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"date\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Date base: XSDDate uri: xsd:date repr: str datetime: name: datetime description: The combination of a date and time notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"datetime\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:DateTime base: XSDDateTime uri: xsd:dateTime repr: str date_or_datetime: name: date_or_datetime description: Either a date or a datetime notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"date_or_datetime\". from_schema: https://w3id.org/linkml/types base: str uri: linkml:DateOrDatetime repr: str uriorcurie: name: uriorcurie description: a URI or a CURIE notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"uriorcurie\". from_schema: https://w3id.org/linkml/types base: URIorCURIE uri: xsd:anyURI repr: str curie: name: curie conforms_to: https://www.w3.org/TR/curie/ description: a compact URI notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"curie\". comments: - in RDF serializations this MUST be expanded to a URI - in non-RDF serializations MAY be serialized as the compact representation from_schema: https://w3id.org/linkml/types base: Curie uri: xsd:string repr: str uri: name: uri conforms_to: https://www.ietf.org/rfc/rfc3987.txt description: a complete URI notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"uri\". comments: - in RDF serializations a slot with range of uri is treated as a literal or type xsd:anyURI unless it is an identifier or a reference to an identifier, in which case it is translated directly to a node from_schema: https://w3id.org/linkml/types close_mappings: - schema:URL base: URI uri: xsd:anyURI repr: str ncname: name: ncname description: Prefix part of CURIE notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"ncname\". from_schema: https://w3id.org/linkml/types base: NCName uri: xsd:string repr: str objectidentifier: name: objectidentifier description: A URI or CURIE that represents an object in the model. notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"objectidentifier\". comments: - Used for inheritance and type checking from_schema: https://w3id.org/linkml/types base: ElementIdentifier uri: shex:iri repr: str nodeidentifier: name: nodeidentifier description: A URI, CURIE or BNODE that represents a node in a model. notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"nodeidentifier\". from_schema: https://w3id.org/linkml/types base: NodeIdentifier uri: shex:nonLiteral repr: str jsonpointer: name: jsonpointer conforms_to: https://datatracker.ietf.org/doc/html/rfc6901 description: A string encoding a JSON Pointer. The value of the string MUST conform to JSON Point syntax and SHOULD dereference to a valid object within the current instance document when encoded in tree form. notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"jsonpointer\". from_schema: https://w3id.org/linkml/types base: str uri: xsd:string repr: str jsonpath: name: jsonpath conforms_to: https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html description: A string encoding a JSON Path. The value of the string MUST conform to JSON Point syntax and SHOULD dereference to zero or more valid objects within the current instance document when encoded in tree form. notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"jsonpath\". from_schema: https://w3id.org/linkml/types base: str uri: xsd:string repr: str sparqlpath: name: sparqlpath conforms_to: https://www.w3.org/TR/sparql11-query/#propertypaths description: A string encoding a SPARQL Property Path. The value of the string MUST conform to SPARQL syntax and SHOULD dereference to zero or more valid objects within the current instance document when encoded as RDF. notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"sparqlpath\". from_schema: https://w3id.org/linkml/types base: str uri: xsd:string repr: str chemical formula value: name: chemical formula value description: A chemical formula notes: - Should be implemented as a stronger type from_schema: https://w3id.org/biolink/biolink-model base: str uri: xsd:string iri type: name: iri type description: An IRI from_schema: https://w3id.org/biolink/biolink-model typeof: uriorcurie uri: xsd:string label type: name: label type description: A string that provides a human-readable name for an entity from_schema: https://w3id.org/biolink/biolink-model typeof: string uri: xsd:string predicate type: name: predicate type description: A CURIE from the biolink related_to hierarchy. For example, biolink:related_to, biolink:causes, biolink:treats. from_schema: https://w3id.org/biolink/biolink-model typeof: uriorcurie uri: xsd:string narrative text: name: narrative text description: A string that provides a human-readable description of something from_schema: https://w3id.org/biolink/biolink-model typeof: string uri: xsd:string symbol type: name: symbol type from_schema: https://w3id.org/biolink/biolink-model typeof: string uri: xsd:string frequency value: name: frequency value from_schema: https://w3id.org/biolink/biolink-model typeof: string uri: UO:0000105 percentage frequency value: name: percentage frequency value from_schema: https://w3id.org/biolink/biolink-model typeof: double uri: UO:0000187 quotient: name: quotient from_schema: https://w3id.org/biolink/biolink-model aliases: - ratio typeof: double uri: UO:0010006 unit: name: unit id_prefixes: - UO from_schema: https://w3id.org/biolink/biolink-model exact_mappings: - qud:Unit typeof: string uri: UO:0000000 time type: name: time type from_schema: https://w3id.org/biolink/biolink-model typeof: time uri: xsd:time biological sequence: name: biological sequence from_schema: https://w3id.org/biolink/biolink-model typeof: string uri: xsd:string classes: Gene: name: Gene id_prefixes: - NCBIGene - ENSEMBL - HGNC - MGI - ZFIN - dictyBase - WB - WormBase - FB - RGD - SGD - PomBase - OMIM - KEGG.GENES - UMLS - Xenbase - AspGD - PHARMGKB.GENE description: A region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene locus may include regulatory regions, transcribed regions and/or other functional sequence regions. in_subset: - translator_minimal - model_organism_database exact_mappings: - SO:0000704 - SIO:010035 - WIKIDATA:Q7187 - dcid:Gene narrow_mappings: - bioschemas:gene broad_mappings: - NCIT:C45822 attributes: symbol: name: symbol description: Symbol for a particular thing exact_mappings: - AGRKB:symbol - gpi:DB_Object_Symbol is_a: node property domain: named thing domain_of: - gene xref: name: xref description: A database cross reference or alternative identifier for a NamedThing or edge between two NamedThings. This property should point to a database record or webpage that supports the existence of the edge, or gives more detail about the edge. This property can be used on a node or edge to provide multiple URIs or CURIE cross references. in_subset: - translator_minimal aliases: - dbxref - Dbxref - DbXref - record_url - source_record_urls narrow_mappings: - gff3:Dbxref - gpi:DB_Xrefs domain: named thing domain_of: - named thing - publication - retrieval source - gene - gene product mixin range: uriorcurie multivalued: true Disease: name: Disease id_prefixes: - MONDO - DOID - OMIM - OMIM.PS - orphanet - EFO - UMLS - MESH - MEDDRA - NCIT - SNOMEDCT - medgen - ICD10 - ICD9 - KEGG.DISEASE - HP - MP - PHARMGKB.DISEASE description: A disorder of structure or function, especially one that produces specific signs, phenotypes or symptoms or that affects a specific location and is not simply a direct result of physical injury. A disposition to undergo pathological processes that exists in an organism because of one or more disorders in that organism. in_subset: - model_organism_database - translator_minimal aliases: - condition - disorder - medical condition exact_mappings: - MONDO:0000001 - DOID:4 - NCIT:C2991 - WIKIDATA:Q12136 - SIO:010299 - UMLSSG:DISO - STY:T047 - dcid:Disease narrow_mappings: - STY:T019 - STY:T020 - STY:T048 - STY:T049 - STY:T191 - MONDO:0042489 CaseToPhenotypicFeatureAssociation: name: CaseToPhenotypicFeatureAssociation description: An association between a case (e.g. individual patient) and a phenotypic feature in which the individual has or has had the phenotype. defining_slots: - subject - object GeneToDiseaseAssociation: name: GeneToDiseaseAssociation comments: - NCIT:R176 refers to the inverse relationship exact_mappings: - SIO:000983 close_mappings: - dcid:DiseaseGeneAssociation defining_slots: - subject - object GeneToPhenotypicFeatureAssociation: name: GeneToPhenotypicFeatureAssociation exact_mappings: - WBVocab:Gene-Phenotype-Association defining_slots: - subject - object Case: name: Case description: An individual (human) organism that has a patient role in some clinical context. aliases: - patient - proband PhenotypicFeature: name: PhenotypicFeature id_prefixes: - HP - EFO - NCIT - UMLS - MEDDRA - MP - ZP - UPHENO - APO - FBcv - WBPhenotype - SNOMEDCT - MESH - XPO - FYPO - TO description: A combination of entity and quality that makes up a phenotyping statement. An observable characteristic of an individual resulting from the interaction of its genotype with its molecular and physical environment. examples: - value: MP:0001262 description: decreased body weight in_subset: - model_organism_database aliases: - sign - symptom - phenotype - trait - endophenotype exact_mappings: - UPHENO:0001001 - SIO:010056 - WIKIDATA:Q104053 - UMLS:C4021819 - NCIT:C16977 - SNOMEDCT:8116006 - MESH:D010641 narrow_mappings: - STY:T184 - WIKIDATA:Q169872 - WIKIDATA:Q25203551 - ZP:00000000 - FBcv:0001347 - HP:0000118 - MP:0000001 - WBPhenotype:0000886 - XPO:00000000 - FYPO:0000001 - APO:0000017 - TO:0000387 - STY:T190 broad_mappings: - BFO:0000019 - PATO:0000001 Notes: * notice that if we remove a parent class from this, e.g. remove \"NamedThing\" - the is_a path in the descendent classes will be absent. this is to prevent unreachable element errors. * notice that helpful defaults are brought in like prefixes, descriptions, aliases, mappings, etc. * there will likely be cases where metamodel elements in LinkML are not automatically transferred to the derived schema (as will all our generators, we are working towards feature parity). * notice that the transformation automatically makes what were, independent slot definitions in Biolink Model into attributes . These are more or less functionally equivalent in LinkML, however if you want to specify a slot that can be reused outside of a particular class, it is still best practice to do so with a slot definition rather than an attribute as to not repeat slot definitions. Use derived schema to generate different serializations of the derived model Now that we have a YAML dump of our derived model, we can use standard LinkML tooling to produce: * python dataclasses and pydantic models of our derived schema * navigate our derived schema with a SchemaView instance * create and deploy automated documentation with the derived schema (see https://github.com/linkml/linkml-project-cookiecutter for more details on using the derived schema in a standard setup) ! gen - pydantic biolink - subset . yaml from __future__ import annotations from datetime import ( datetime, date ) from decimal import Decimal from enum import Enum import re import sys from typing import ( Any, ClassVar, List, Literal, Dict, Optional, Union ) from pydantic.version import VERSION as PYDANTIC_VERSION if int(PYDANTIC_VERSION[0])>=2: from pydantic import ( BaseModel, ConfigDict, Field, RootModel, field_validator ) else: from pydantic import ( BaseModel, Field, validator ) metamodel_version = \"None\" version = \"None\" class ConfiguredBaseModel(BaseModel): model_config = ConfigDict( validate_assignment = True, validate_default = True, extra = \"forbid\", arbitrary_types_allowed = True, use_enum_values = True, strict = False, ) pass class LinkMLMeta(RootModel): root: Dict[str, Any] = {} model_config = ConfigDict(frozen=True) def __getattr__(self, key:str): return getattr(self.root, key) def __getitem__(self, key:str): return self.root[key] def __setitem__(self, key:str, value): self.root[key] = value linkml_meta = LinkMLMeta({'default_prefix': 'biolink-subset/', 'id': 'biolink-subset', 'name': 'BiolinkSubset'} ) class Gene(ConfiguredBaseModel): \"\"\" A region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene locus may include regulatory regions, transcribed regions and/or other functional sequence regions. \"\"\" linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'broad_mappings': ['NCIT:C45822'], 'exact_mappings': ['SO:0000704', 'SIO:010035', 'WIKIDATA:Q7187', 'dcid:Gene'], 'from_schema': 'biolink-subset', 'id_prefixes': ['NCBIGene', 'ENSEMBL', 'HGNC', 'MGI', 'ZFIN', 'dictyBase', 'WB', 'WormBase', 'FB', 'RGD', 'SGD', 'PomBase', 'OMIM', 'KEGG.GENES', 'UMLS', 'Xenbase', 'AspGD', 'PHARMGKB.GENE'], 'in_subset': ['translator_minimal', 'model_organism_database'], 'narrow_mappings': ['bioschemas:gene']}) symbol: Optional[str] = Field(None, description=\"\"\"Symbol for a particular thing\"\"\", json_schema_extra = { \"linkml_meta\": {'alias': 'symbol', 'domain': 'named thing', 'domain_of': ['gene', 'Gene'], 'exact_mappings': ['AGRKB:symbol', 'gpi:DB_Object_Symbol'], 'is_a': 'node property'} }) xref: Optional[List[str]] = Field(default_factory=list, description=\"\"\"A database cross reference or alternative identifier for a NamedThing or edge between two NamedThings. This property should point to a database record or webpage that supports the existence of the edge, or gives more detail about the edge. This property can be used on a node or edge to provide multiple URIs or CURIE cross references.\"\"\", json_schema_extra = { \"linkml_meta\": {'alias': 'xref', 'aliases': ['dbxref', 'Dbxref', 'DbXref', 'record_url', 'source_record_urls'], 'domain': 'named thing', 'domain_of': ['named thing', 'publication', 'retrieval source', 'gene', 'gene product mixin', 'Gene'], 'in_subset': ['translator_minimal'], 'narrow_mappings': ['gff3:Dbxref', 'gpi:DB_Xrefs']} }) class Disease(ConfiguredBaseModel): \"\"\" A disorder of structure or function, especially one that produces specific signs, phenotypes or symptoms or that affects a specific location and is not simply a direct result of physical injury. A disposition to undergo pathological processes that exists in an organism because of one or more disorders in that organism. \"\"\" linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'aliases': ['condition', 'disorder', 'medical condition'], 'exact_mappings': ['MONDO:0000001', 'DOID:4', 'NCIT:C2991', 'WIKIDATA:Q12136', 'SIO:010299', 'UMLSSG:DISO', 'STY:T047', 'dcid:Disease'], 'from_schema': 'biolink-subset', 'id_prefixes': ['MONDO', 'DOID', 'OMIM', 'OMIM.PS', 'orphanet', 'EFO', 'UMLS', 'MESH', 'MEDDRA', 'NCIT', 'SNOMEDCT', 'medgen', 'ICD10', 'ICD9', 'KEGG.DISEASE', 'HP', 'MP', 'PHARMGKB.DISEASE'], 'in_subset': ['model_organism_database', 'translator_minimal'], 'narrow_mappings': ['STY:T019', 'STY:T020', 'STY:T048', 'STY:T049', 'STY:T191', 'MONDO:0042489']}) pass class CaseToPhenotypicFeatureAssociation(ConfiguredBaseModel): \"\"\" An association between a case (e.g. individual patient) and a phenotypic feature in which the individual has or has had the phenotype. \"\"\" linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'defining_slots': ['subject', 'object'], 'from_schema': 'biolink-subset'}) pass class GeneToDiseaseAssociation(ConfiguredBaseModel): linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'close_mappings': ['dcid:DiseaseGeneAssociation'], 'comments': ['NCIT:R176 refers to the inverse relationship'], 'defining_slots': ['subject', 'object'], 'exact_mappings': ['SIO:000983'], 'from_schema': 'biolink-subset'}) pass class GeneToPhenotypicFeatureAssociation(ConfiguredBaseModel): linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'defining_slots': ['subject', 'object'], 'exact_mappings': ['WBVocab:Gene-Phenotype-Association'], 'from_schema': 'biolink-subset'}) pass class Case(ConfiguredBaseModel): \"\"\" An individual (human) organism that has a patient role in some clinical context. \"\"\" linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'aliases': ['patient', 'proband'], 'from_schema': 'biolink-subset'}) pass class PhenotypicFeature(ConfiguredBaseModel): \"\"\" A combination of entity and quality that makes up a phenotyping statement. An observable characteristic of an individual resulting from the interaction of its genotype with its molecular and physical environment. \"\"\" linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'aliases': ['sign', 'symptom', 'phenotype', 'trait', 'endophenotype'], 'broad_mappings': ['BFO:0000019', 'PATO:0000001'], 'exact_mappings': ['UPHENO:0001001', 'SIO:010056', 'WIKIDATA:Q104053', 'UMLS:C4021819', 'NCIT:C16977', 'SNOMEDCT:8116006', 'MESH:D010641'], 'examples': [{'description': 'decreased body weight', 'value': 'MP:0001262'}], 'from_schema': 'biolink-subset', 'id_prefixes': ['HP', 'EFO', 'NCIT', 'UMLS', 'MEDDRA', 'MP', 'ZP', 'UPHENO', 'APO', 'FBcv', 'WBPhenotype', 'SNOMEDCT', 'MESH', 'XPO', 'FYPO', 'TO'], 'in_subset': ['model_organism_database'], 'narrow_mappings': ['STY:T184', 'WIKIDATA:Q169872', 'WIKIDATA:Q25203551', 'ZP:00000000', 'FBcv:0001347', 'HP:0000118', 'MP:0000001', 'WBPhenotype:0000886', 'XPO:00000000', 'FYPO:0000001', 'APO:0000017', 'TO:0000387', 'STY:T190']}) pass # Model rebuild # see https://pydantic-docs.helpmanual.io/usage/models/#rebuilding-a-model Gene.model_rebuild() Disease.model_rebuild() CaseToPhenotypicFeatureAssociation.model_rebuild() GeneToDiseaseAssociation.model_rebuild() GeneToPhenotypicFeatureAssociation.model_rebuild() Case.model_rebuild() PhenotypicFeature.model_rebuild() ! gen - doc biolink - subset . yaml - d docs ValueError: No such slot as \"node property\"","title":"Biolink subsetting"},{"location":"examples/biolink-subsetting/#biolink-model-subsetting","text":"This notebook demonstrates how to subset the Biolink Model using the Biolink Model schema and a transformation specification in two different ways: first using a transformation specification defined manually in YAML and loaded from the filesystem, and second, using a subset of classes retrieved using SchemaView dynamically. First, we import several LinkML helper packages including SchemaView: https://linkml.io/linkml/developers/schemaview.html SchemaView is a LinkML schema introspection tool that provides helpful functions to retrieve model elements by name. It also supports navigating ancestors and descendants of any model element, including classes, slots, types, and permissible values in enumerations. from pathlib import Path from pytest import fixture from linkml_runtime.dumpers import yaml_dumper from linkml_map.datamodel.transformer_model import TransformationSpecification , ClassDerivation , SlotDerivation , CopyDirective from linkml_map.inference.schema_mapper import SchemaMapper from linkml_map.session import Session from linkml_runtime.utils.schemaview import SchemaView from linkml_map.utils.loaders import load_specification from linkml_runtime.utils.formatutils import camelcase , underscore from pprint import pprint REPO_ROOT = Path . cwd () . parent . parent SchemaView can accept a variety of imports to initialize, including a Path or string representation of a Path or (as we do in this case), a URL of a raw LinkML schema. schema_url = \"https://raw.githubusercontent.com/biolink/biolink-model/master/biolink-model.yaml\" sv = SchemaView ( schema_url )","title":"Biolink Model Subsetting"},{"location":"examples/biolink-subsetting/#creating-a-transformation-specification-manually-in-yaml-format","text":"In our first example, we develop a \"Transform Specification\" for Biolink Model using Class and Slot Derivations as defined by the linkml-map transformation language. More about that here: https://linkml.io/linkml-map/#TransformationSpecification/ transform_file = REPO_ROOT / \"tests/input/examples/biolink/transform/biolink-example-profile.transform.yaml\" # Initialize Session and SchemaBuilder session = Session () # Set the source schema in the session session . set_source_schema ( sv ) tr_spec = load_specification ( transform_file ) mapper = SchemaMapper () mapper . source_schemaview = sv target_schema_obj = mapper . derive_schema ( specification = tr_spec , target_schema_id = \"biolink-profile\" , target_schema_name = \"BiolinkProfile\" ) yaml_dumper . dump ( target_schema_obj , \"biolink-profile.yaml\" ) transformed_sv = SchemaView ( \"biolink-profile.yaml\" ) for class_name in transformed_sv . all_classes (): print ( class_name ) print () for slot_name in transformed_sv . all_slots (): print ( slot_name ) NamedThing Gene Disease PhenotypicFeature Association GeneToPhenotypicFeatureAssociation id name category symbol subject predicate object ! gen - pydantic biolink - profile . yaml Exception: range: label type Note: * Still in development is the tracing of provenance between a source schema and a destination schema. Right now there is no provenance. * If a class, slot, enum, or type is not included at all in the Derivation, it will not be pushed forward to the destination schema. In development is an option to pull all non-specified components of the source model into the destination model. * You can do transformations on a derivation as well, see: https://linkml.io/linkml-map/#examples/Tutorial/#using-expressions * You can transform data as well as schemas, but this is currently \"beta\" level development. * Custom types are not pulled forward; this is a result of an error at the moment.","title":"Creating a Transformation Specification Manually in YAML format."},{"location":"examples/biolink-subsetting/#creating-a-transformationspecification-using-schemaview-and-an-existing-model","text":"In our second example, we use the Biolink Model directly to derive classes and slots programmatically according to a simple list of \"subset classes\" that we want to extract from the main model in order to produce a subset model according to our specification. First, we write a method to extract the classes and slots from Biolink Model using SchemaView def get_biolink_class_derivations ( sv , subset_classes ) -& gt ; dict : \"\"\" Function to get Biolink class definitions :param sv: SchemaView object :param subset_classes: List of classes to subset :return: Dictionary of class derivations incl slot derivations \"\"\" # Example implementation to fetch class definitions # This should be replaced with the actual implementation class_derivations = {} for class_name in subset_classes : class_derivation = ClassDerivation ( populated_from = class_name , name = camelcase ( class_name )) induced_slots = sv . class_induced_slots ( class_name ) for slot in induced_slots : slot_derivation = SlotDerivation ( populated_from = slot . name , name = underscore ( slot . name )) class_derivation . slot_derivations [ underscore ( slot . name )] = slot_derivation class_derivations [ camelcase ( class_name )] = class_derivation return class_derivations def get_biolink_class_derivations_direct ( sv , subset_classes ) -& gt ; dict : \"\"\" Function to get Biolink class definitions :param sv: SchemaView object :param subset_classes: List of classes to subset :return: Dictionary of class derivations incl slot derivations \"\"\" # Example implementation to fetch class definitions # This should be replaced with the actual implementation class_derivations = {} for class_name in subset_classes : class_derivation = ClassDerivation ( populated_from = class_name , name = camelcase ( class_name )) for slot in sv . get_class ( class_name ) . slots : slot_derivation = SlotDerivation ( populated_from = slot , name = underscore ( slot )) class_derivation . slot_derivations [ underscore ( slot )] = slot_derivation class_derivations [ camelcase ( class_name )] = class_derivation return class_derivations session = Session () # Set the source schema in the session session . set_source_schema ( sv ) subset_classes = [ \"gene\" , \"disease\" , \"case to phenotypic feature association\" , \"gene to disease association\" , \"gene to phenotypic feature association\" , \"case\" , \"phenotypic feature\" , ] class_derivations = get_biolink_class_derivations_direct ( sv , subset_classes ) copy_type_directives = { type_name : CopyDirective ( element_name = type_name , copy_all = False ) for type_name , type_def in sv . all_types () . items () } ts = TransformationSpecification ( class_derivations = class_derivations , copy_directives = copy_type_directives ) mapper = SchemaMapper () mapper . source_schemaview = sv target_schema_obj = mapper . derive_schema ( specification = ts , target_schema_id = \"biolink-subset\" , target_schema_name = \"BiolinkSubset\" ) # ugly bit of hacking to demonstrate end-to-end functionality target_schema_obj . types = sv . all_types () yaml_dumper . dump ( target_schema_obj , \"biolink-subset.yaml\" ) transformed_sv = SchemaView ( \"biolink-subset.yaml\" ) for class_name in transformed_sv . all_classes (): print ( \"class derived: \" , class_name ) for slot_name in transformed_sv . all_slots (): print ( \"slot derived: \" , slot_name ) for type_name in transformed_sv . all_types (): print ( \"type copied: \" , type_name ) class derived: Gene class derived: Disease class derived: CaseToPhenotypicFeatureAssociation class derived: GeneToDiseaseAssociation class derived: GeneToPhenotypicFeatureAssociation class derived: Case class derived: PhenotypicFeature slot derived: symbol slot derived: xref slot derived: has_biological_sequence slot derived: id slot derived: in_taxon slot derived: in_taxon_label slot derived: provided_by slot derived: full_name slot derived: synonym slot derived: iri slot derived: category slot derived: type slot derived: name slot derived: description slot derived: has_attribute slot derived: deprecated slot derived: subject slot derived: predicate slot derived: object slot derived: sex_qualifier slot derived: disease_context_qualifier slot derived: subject_specialization_qualifier slot derived: object_specialization_qualifier slot derived: anatomical_context_qualifier slot derived: negated slot derived: qualifier slot derived: qualifiers slot derived: publications slot derived: has_evidence slot derived: knowledge_source slot derived: primary_knowledge_source slot derived: aggregator_knowledge_source slot derived: knowledge_level slot derived: agent_type slot derived: timepoint slot derived: original_subject slot derived: original_predicate slot derived: original_object slot derived: subject_category slot derived: object_category slot derived: subject_closure slot derived: object_closure slot derived: subject_category_closure slot derived: object_category_closure slot derived: subject_namespace slot derived: object_namespace slot derived: subject_label_closure slot derived: object_label_closure slot derived: retrieval_source_ids slot derived: p_value slot derived: adjusted_p_value slot derived: has_supporting_studies slot derived: has_count slot derived: has_total slot derived: has_quotient slot derived: has_percentage slot derived: subject_aspect_qualifier slot derived: subject_direction_qualifier slot derived: object_aspect_qualifier slot derived: object_direction_qualifier slot derived: qualified_predicate slot derived: frequency_qualifier type copied: string type copied: integer type copied: boolean type copied: float type copied: double type copied: decimal type copied: time type copied: date type copied: datetime type copied: date_or_datetime type copied: uriorcurie type copied: curie type copied: uri type copied: ncname type copied: objectidentifier type copied: nodeidentifier type copied: jsonpointer type copied: jsonpath type copied: sparqlpath type copied: chemical formula value type copied: iri type type copied: label type type copied: predicate type type copied: narrative text type copied: symbol type type copied: frequency value type copied: percentage frequency value type copied: quotient type copied: unit type copied: time type type copied: biological sequence # print the content of the new schema in LinkML YAML format to view here in the notebook yaml_content = yaml_dumper . dumps ( target_schema_obj ) # Serialize to a string print ( yaml_content ) name: BiolinkSubset id: biolink-subset imports: - linkml:types prefixes: AGRKB: prefix_prefix: AGRKB prefix_reference: https://www.alliancegenome.org/ apollo: prefix_prefix: apollo prefix_reference: https://github.com/GMOD/Apollo AspGD: prefix_prefix: AspGD prefix_reference: http://www.aspergillusgenome.org/cgi-bin/locus.pl?dbid= biolink: prefix_prefix: biolink prefix_reference: https://w3id.org/biolink/vocab/ bioschemas: prefix_prefix: bioschemas prefix_reference: https://bioschemas.org/ linkml: prefix_prefix: linkml prefix_reference: https://w3id.org/linkml/ CAID: prefix_prefix: CAID prefix_reference: http://reg.clinicalgenome.org/redmine/projects/registry/genboree_registry/by_caid?caid= CHADO: prefix_prefix: CHADO prefix_reference: http://gmod.org/wiki/Chado/ ChemBank: prefix_prefix: ChemBank prefix_reference: http://chembank.broadinstitute.org/chemistry/viewMolecule.htm?cbid= CHEMBL.MECHANISM: prefix_prefix: CHEMBL.MECHANISM prefix_reference: https://www.ebi.ac.uk/chembl/mechanism/inspect/ CID: prefix_prefix: CID prefix_reference: http://pubchem.ncbi.nlm.nih.gov/compound/ CLINVAR: prefix_prefix: CLINVAR prefix_reference: http://identifiers.org/clinvar COAR_RESOURCE: prefix_prefix: COAR_RESOURCE prefix_reference: http://purl.org/coar/resource_type/ COG: prefix_prefix: COG prefix_reference: https://www.ncbi.nlm.nih.gov/research/cog-project/ ComplexPortal: prefix_prefix: ComplexPortal prefix_reference: https://www.ebi.ac.uk/complexportal/complex/ CPT: prefix_prefix: CPT prefix_reference: https://www.ama-assn.org/practice-management/cpt/ CTD.CHEMICAL: prefix_prefix: CTD.CHEMICAL prefix_reference: http://ctdbase.org/detail.go?type=chem&acc= CTD.DISEASE: prefix_prefix: CTD.DISEASE prefix_reference: http://ctdbase.org/detail.go?type=disease&db=MESH&acc= CTD.GENE: prefix_prefix: CTD.GENE prefix_reference: http://ctdbase.org/detail.go?type=gene&acc= CTD: prefix_prefix: CTD prefix_reference: http://ctdbase.org/ DGIdb: prefix_prefix: DGIdb prefix_reference: https://www.dgidb.org/interaction_types dcat: prefix_prefix: dcat prefix_reference: http://www.w3.org/ns/dcat# dct: prefix_prefix: dct prefix_reference: http://purl.org/dc/terms/ dcid: prefix_prefix: dcid prefix_reference: https://datacommons.org/browser/ doi: prefix_prefix: doi prefix_reference: https://doi.org/ DOID-PROPERTY: prefix_prefix: DOID-PROPERTY prefix_reference: http://purl.obolibrary.org/obo/doid# DrugCentral: prefix_prefix: DrugCentral prefix_reference: http://drugcentral.org/drugcard/ ECTO: prefix_prefix: ECTO prefix_reference: http://purl.obolibrary.org/obo/ECTO_ EDAM-DATA: prefix_prefix: EDAM-DATA prefix_reference: http://edamontology.org/data_ EDAM-FORMAT: prefix_prefix: EDAM-FORMAT prefix_reference: http://edamontology.org/format_ EDAM-OPERATION: prefix_prefix: EDAM-OPERATION prefix_reference: http://edamontology.org/operation_ EDAM-TOPIC: prefix_prefix: EDAM-TOPIC prefix_reference: http://edamontology.org/topic_ EFO: prefix_prefix: EFO prefix_reference: http://www.ebi.ac.uk/efo/EFO_ ExO: prefix_prefix: ExO prefix_reference: http://purl.obolibrary.org/obo/ExO_ fabio: prefix_prefix: fabio prefix_reference: http://purl.org/spar/fabio/ foaf: prefix_prefix: foaf prefix_reference: http://xmlns.com/foaf/0.1/ foodb.compound: prefix_prefix: foodb.compound prefix_reference: http://foodb.ca/compounds/ foodb.food: prefix_prefix: foodb.food prefix_reference: http://foodb.ca/foods/ FYECO: prefix_prefix: FYECO prefix_reference: https://www.pombase.org/term/ FYPO: prefix_prefix: FYPO prefix_reference: http://purl.obolibrary.org/obo/FYPO_ gff3: prefix_prefix: gff3 prefix_reference: https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md# GOREL: prefix_prefix: GOREL prefix_reference: http://purl.obolibrary.org/obo/GOREL_ GOP: prefix_prefix: GOP prefix_reference: http://purl.obolibrary.org/obo/go# gpi: prefix_prefix: gpi prefix_reference: https://github.com/geneontology/go-annotation/blob/master/specs/gpad-gpi-2-0.md# GSID: prefix_prefix: GSID prefix_reference: https://scholar.google.com/citations?user= GTEx: prefix_prefix: GTEx prefix_reference: https://www.gtexportal.org/home/gene/ GTOPDB: prefix_prefix: GTOPDB prefix_reference: https://www.guidetopharmacology.org/GRAC/LigandDisplayForward?ligandId= gtpo: prefix_prefix: gtpo prefix_reference: https://rdf.guidetopharmacology.org/ns/gtpo# HANCESTRO: prefix_prefix: HANCESTRO prefix_reference: http://www.ebi.ac.uk/ancestro/ancestro_ HCPCS: prefix_prefix: HCPCS prefix_reference: http://purl.bioontology.org/ontology/HCPCS/ HsapDv: prefix_prefix: HsapDv prefix_reference: http://purl.obolibrary.org/obo/HsapDv_ ICD10: prefix_prefix: ICD10 prefix_reference: https://icd.codes/icd9cm/ ICD9: prefix_prefix: ICD9 prefix_reference: http://translator.ncats.nih.gov/ICD9_ interpro: prefix_prefix: interpro prefix_reference: https://www.ebi.ac.uk/interpro/entry/ INO: prefix_prefix: INO prefix_reference: http://purl.obolibrary.org/obo/INO_ isbn: prefix_prefix: isbn prefix_reference: https://www.isbn-international.org/identifier/ isni: prefix_prefix: isni prefix_reference: https://isni.org/isni/ issn: prefix_prefix: issn prefix_reference: https://portal.issn.org/resource/ISSN/ ncats.drug: prefix_prefix: ncats.drug prefix_reference: https://drugs.ncats.io/drug/ KEGG.BRITE: prefix_prefix: KEGG.BRITE prefix_reference: 'https://bioregistry.io/kegg.brite:' KEGG: prefix_prefix: KEGG prefix_reference: http://www.kegg.jp/entry/ KEGG.GENES: prefix_prefix: KEGG.GENES prefix_reference: 'https://bioregistry.io/kegg.genes:bsu:' KEGG.PATHWAY: prefix_prefix: KEGG.PATHWAY prefix_reference: 'https://bioregistry.io/kegg.pathway:' KEGG.RCLASS: prefix_prefix: KEGG.RCLASS prefix_reference: 'https://www.genome.jp/dbget-bin/www_bget?rc:' LOINC: prefix_prefix: LOINC prefix_reference: http://loinc.org/rdf/ MAXO: prefix_prefix: MAXO prefix_reference: http://purl.obolibrary.org/obo/MAXO_ medgen: prefix_prefix: medgen prefix_reference: https://www.ncbi.nlm.nih.gov/medgen/ metacyc.reaction: prefix_prefix: metacyc.reaction prefix_reference: 'http://identifiers.org/metacyc.reaction:' METANETX.REACTION: prefix_prefix: METANETX.REACTION prefix_reference: https://www.metanetx.org/equa_info/ MESH: prefix_prefix: MESH prefix_reference: http://id.nlm.nih.gov/mesh/ MI: prefix_prefix: MI prefix_reference: http://purl.obolibrary.org/obo/MI_ mirbase: prefix_prefix: mirbase prefix_reference: http://identifiers.org/mirbase mmmp.biomaps: prefix_prefix: mmmp.biomaps prefix_reference: 'https://bioregistry.io/mmmp.biomaps:' MmusDv: prefix_prefix: MmusDv prefix_reference: http://purl.obolibrary.org/obo/MMUSDV_ MSigDB: prefix_prefix: MSigDB prefix_reference: https://www.gsea-msigdb.org/gsea/msigdb/ NBO-PROPERTY: prefix_prefix: NBO-PROPERTY prefix_reference: http://purl.obolibrary.org/obo/nbo# ncats.bioplanet: prefix_prefix: ncats.bioplanet prefix_reference: https://tripod.nih.gov/bioplanet/detail.jsp?pid= NCBIGene: prefix_prefix: NCBIGene prefix_reference: http://identifiers.org/ncbigene/ NCIT-OBO: prefix_prefix: NCIT-OBO prefix_reference: http://purl.obolibrary.org/obo/ncit# NDDF: prefix_prefix: NDDF prefix_reference: http://purl.bioontology.org/ontology/NDDF/ NLMID: prefix_prefix: NLMID prefix_reference: https://www.ncbi.nlm.nih.gov/nlmcatalog/?term= OBAN: prefix_prefix: OBAN prefix_reference: http://purl.org/oban/ OMIM.PS: prefix_prefix: OMIM.PS prefix_reference: https://www.omim.org/phenotypicSeries/ ORCID: prefix_prefix: ORCID prefix_reference: https://orcid.org/ orphanet: prefix_prefix: orphanet prefix_reference: http://www.orpha.net/ORDO/Orphanet_ os: prefix_prefix: os prefix_reference: https://github.com/cmungall/owlstar/blob/master/owlstar.ttl PANTHER.FAMILY: prefix_prefix: PANTHER.FAMILY prefix_reference: http://www.pantherdb.org/panther/family.do?clsAccession= PathWhiz: prefix_prefix: PathWhiz prefix_reference: http://smpdb.ca/pathways/# pav: prefix_prefix: pav prefix_reference: http://purl.org/pav/ PHARMGKB.DRUG: prefix_prefix: PHARMGKB.DRUG prefix_reference: https://www.pharmgkb.org/chemical/ PHARMGKB.DISEASE: prefix_prefix: PHARMGKB.DISEASE prefix_reference: https://www.pharmgkb.org/disease/ PHARMGKB.GENE: prefix_prefix: PHARMGKB.GENE prefix_reference: https://www.pharmgkb.org/gene/ PHARMGKB.PATHWAYS: prefix_prefix: PHARMGKB.PATHWAYS prefix_reference: https://www.pharmgkb.org/pathway/ PHARMGKB.VARIANT: prefix_prefix: PHARMGKB.VARIANT prefix_reference: https://www.pharmgkb.org/variant/ PHAROS: prefix_prefix: PHAROS prefix_reference: http://pharos.nih.gov PomBase: prefix_prefix: PomBase prefix_reference: https://www.pombase.org/gene/ prov: prefix_prefix: prov prefix_reference: http://www.w3.org/ns/prov# qud: prefix_prefix: qud prefix_reference: http://qudt.org/1.1/schema/qudt# REPODB: prefix_prefix: REPODB prefix_reference: http://apps.chiragjpgroup.org/repoDB/ ResearchID: prefix_prefix: ResearchID prefix_reference: https://publons.com/researcher/ RO: prefix_prefix: RO prefix_reference: http://purl.obolibrary.org/obo/RO_ RXNORM: prefix_prefix: RXNORM prefix_reference: http://purl.bioontology.org/ontology/RXNORM/ RXCUI: prefix_prefix: RXCUI prefix_reference: https://mor.nlm.nih.gov/RxNav/search?searchBy=RXCUI&searchTerm= schema: prefix_prefix: schema prefix_reference: http://schema.org/ ScopusID: prefix_prefix: ScopusID prefix_reference: https://www.scopus.com/authid/detail.uri?authorId= SEED.REACTION: prefix_prefix: SEED.REACTION prefix_reference: https://modelseed.org/biochem/reactions/ SEMMEDDB: prefix_prefix: SEMMEDDB prefix_reference: https://skr3.nlm.nih.gov/SemMedDB SIO: prefix_prefix: SIO prefix_reference: http://semanticscience.org/resource/SIO_ SNOMEDCT: prefix_prefix: SNOMEDCT prefix_reference: http://snomed.info/id/ SPDI: prefix_prefix: SPDI prefix_reference: https://api.ncbi.nlm.nih.gov/variation/v0/spdi/ UBERGRAPH: prefix_prefix: UBERGRAPH prefix_reference: http://translator.renci.org/ubergraph-axioms.ofn# UBERON_CORE: prefix_prefix: UBERON_CORE prefix_reference: http://purl.obolibrary.org/obo/uberon/core# UBERON_NONAMESPACE: prefix_prefix: UBERON_NONAMESPACE prefix_reference: http://purl.obolibrary.org/obo/core# STY: prefix_prefix: STY prefix_reference: http://purl.bioontology.org/ontology/STY/ UMLSSG: prefix_prefix: UMLSSG prefix_reference: https://lhncbc.nlm.nih.gov/semanticnetwork/download/sg_archive/SemGroups-v04.txt UniProtKB: prefix_prefix: UniProtKB prefix_reference: http://purl.uniprot.org/uniprot/ UNIPROT.ISOFORM: prefix_prefix: UNIPROT.ISOFORM prefix_reference: http://purl.uniprot.org/isoforms/ VANDF: prefix_prefix: VANDF prefix_reference: https://www.nlm.nih.gov/research/umls/sourcereleasedocs/current/VANDF/ UO-PROPERTY: prefix_prefix: UO-PROPERTY prefix_reference: http://purl.obolibrary.org/obo/uo# VMC: prefix_prefix: VMC prefix_reference: https://github.com/ga4gh/vr-spec/ WBls: prefix_prefix: WBls prefix_reference: http://purl.obolibrary.org/obo/WBls_ WBbt: prefix_prefix: WBbt prefix_reference: http://purl.obolibrary.org/obo/WBbt_ WBVocab: prefix_prefix: WBVocab prefix_reference: http://bio2rdf.org/wormbase_vocabulary WIKIDATA: prefix_prefix: WIKIDATA prefix_reference: https://www.wikidata.org/entity/ WIKIDATA_PROPERTY: prefix_prefix: WIKIDATA_PROPERTY prefix_reference: https://www.wikidata.org/prop/ wgs: prefix_prefix: wgs prefix_reference: http://www.w3.org/2003/01/geo/wgs84_pos XPO: prefix_prefix: XPO prefix_reference: http://purl.obolibrary.org/obo/XPO_ Xenbase: prefix_prefix: Xenbase prefix_reference: http://www.xenbase.org/gene/showgene.do?method=display&geneId= PMC: prefix_prefix: PMC prefix_reference: http://europepmc.org/articles/PMC default_prefix: biolink-subset/ default_range: string types: string: name: string description: A character string notes: - In RDF serializations, a slot with range of string is treated as a literal or type xsd:string. If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"string\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Text base: str uri: xsd:string integer: name: integer description: An integer notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"integer\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Integer base: int uri: xsd:integer boolean: name: boolean description: A binary (true or false) value notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"boolean\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Boolean base: Bool uri: xsd:boolean repr: bool float: name: float description: A real number that conforms to the xsd:float specification notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"float\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Float base: float uri: xsd:float double: name: double description: A real number that conforms to the xsd:double specification notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"double\". from_schema: https://w3id.org/linkml/types close_mappings: - schema:Float base: float uri: xsd:double decimal: name: decimal description: A real number with arbitrary precision that conforms to the xsd:decimal specification notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"decimal\". from_schema: https://w3id.org/linkml/types broad_mappings: - schema:Number base: Decimal uri: xsd:decimal time: name: time description: A time object represents a (local) time of day, independent of any particular day notes: - URI is dateTime because OWL reasoners do not work with straight date or time - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"time\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Time base: XSDTime uri: xsd:time repr: str date: name: date description: a date (year, month and day) in an idealized calendar notes: - URI is dateTime because OWL reasoners don't work with straight date or time - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"date\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:Date base: XSDDate uri: xsd:date repr: str datetime: name: datetime description: The combination of a date and time notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"datetime\". from_schema: https://w3id.org/linkml/types exact_mappings: - schema:DateTime base: XSDDateTime uri: xsd:dateTime repr: str date_or_datetime: name: date_or_datetime description: Either a date or a datetime notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"date_or_datetime\". from_schema: https://w3id.org/linkml/types base: str uri: linkml:DateOrDatetime repr: str uriorcurie: name: uriorcurie description: a URI or a CURIE notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"uriorcurie\". from_schema: https://w3id.org/linkml/types base: URIorCURIE uri: xsd:anyURI repr: str curie: name: curie conforms_to: https://www.w3.org/TR/curie/ description: a compact URI notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"curie\". comments: - in RDF serializations this MUST be expanded to a URI - in non-RDF serializations MAY be serialized as the compact representation from_schema: https://w3id.org/linkml/types base: Curie uri: xsd:string repr: str uri: name: uri conforms_to: https://www.ietf.org/rfc/rfc3987.txt description: a complete URI notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"uri\". comments: - in RDF serializations a slot with range of uri is treated as a literal or type xsd:anyURI unless it is an identifier or a reference to an identifier, in which case it is translated directly to a node from_schema: https://w3id.org/linkml/types close_mappings: - schema:URL base: URI uri: xsd:anyURI repr: str ncname: name: ncname description: Prefix part of CURIE notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"ncname\". from_schema: https://w3id.org/linkml/types base: NCName uri: xsd:string repr: str objectidentifier: name: objectidentifier description: A URI or CURIE that represents an object in the model. notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"objectidentifier\". comments: - Used for inheritance and type checking from_schema: https://w3id.org/linkml/types base: ElementIdentifier uri: shex:iri repr: str nodeidentifier: name: nodeidentifier description: A URI, CURIE or BNODE that represents a node in a model. notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"nodeidentifier\". from_schema: https://w3id.org/linkml/types base: NodeIdentifier uri: shex:nonLiteral repr: str jsonpointer: name: jsonpointer conforms_to: https://datatracker.ietf.org/doc/html/rfc6901 description: A string encoding a JSON Pointer. The value of the string MUST conform to JSON Point syntax and SHOULD dereference to a valid object within the current instance document when encoded in tree form. notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"jsonpointer\". from_schema: https://w3id.org/linkml/types base: str uri: xsd:string repr: str jsonpath: name: jsonpath conforms_to: https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html description: A string encoding a JSON Path. The value of the string MUST conform to JSON Point syntax and SHOULD dereference to zero or more valid objects within the current instance document when encoded in tree form. notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"jsonpath\". from_schema: https://w3id.org/linkml/types base: str uri: xsd:string repr: str sparqlpath: name: sparqlpath conforms_to: https://www.w3.org/TR/sparql11-query/#propertypaths description: A string encoding a SPARQL Property Path. The value of the string MUST conform to SPARQL syntax and SHOULD dereference to zero or more valid objects within the current instance document when encoded as RDF. notes: - If you are authoring schemas in LinkML YAML, the type is referenced with the lower case \"sparqlpath\". from_schema: https://w3id.org/linkml/types base: str uri: xsd:string repr: str chemical formula value: name: chemical formula value description: A chemical formula notes: - Should be implemented as a stronger type from_schema: https://w3id.org/biolink/biolink-model base: str uri: xsd:string iri type: name: iri type description: An IRI from_schema: https://w3id.org/biolink/biolink-model typeof: uriorcurie uri: xsd:string label type: name: label type description: A string that provides a human-readable name for an entity from_schema: https://w3id.org/biolink/biolink-model typeof: string uri: xsd:string predicate type: name: predicate type description: A CURIE from the biolink related_to hierarchy. For example, biolink:related_to, biolink:causes, biolink:treats. from_schema: https://w3id.org/biolink/biolink-model typeof: uriorcurie uri: xsd:string narrative text: name: narrative text description: A string that provides a human-readable description of something from_schema: https://w3id.org/biolink/biolink-model typeof: string uri: xsd:string symbol type: name: symbol type from_schema: https://w3id.org/biolink/biolink-model typeof: string uri: xsd:string frequency value: name: frequency value from_schema: https://w3id.org/biolink/biolink-model typeof: string uri: UO:0000105 percentage frequency value: name: percentage frequency value from_schema: https://w3id.org/biolink/biolink-model typeof: double uri: UO:0000187 quotient: name: quotient from_schema: https://w3id.org/biolink/biolink-model aliases: - ratio typeof: double uri: UO:0010006 unit: name: unit id_prefixes: - UO from_schema: https://w3id.org/biolink/biolink-model exact_mappings: - qud:Unit typeof: string uri: UO:0000000 time type: name: time type from_schema: https://w3id.org/biolink/biolink-model typeof: time uri: xsd:time biological sequence: name: biological sequence from_schema: https://w3id.org/biolink/biolink-model typeof: string uri: xsd:string classes: Gene: name: Gene id_prefixes: - NCBIGene - ENSEMBL - HGNC - MGI - ZFIN - dictyBase - WB - WormBase - FB - RGD - SGD - PomBase - OMIM - KEGG.GENES - UMLS - Xenbase - AspGD - PHARMGKB.GENE description: A region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene locus may include regulatory regions, transcribed regions and/or other functional sequence regions. in_subset: - translator_minimal - model_organism_database exact_mappings: - SO:0000704 - SIO:010035 - WIKIDATA:Q7187 - dcid:Gene narrow_mappings: - bioschemas:gene broad_mappings: - NCIT:C45822 attributes: symbol: name: symbol description: Symbol for a particular thing exact_mappings: - AGRKB:symbol - gpi:DB_Object_Symbol is_a: node property domain: named thing domain_of: - gene xref: name: xref description: A database cross reference or alternative identifier for a NamedThing or edge between two NamedThings. This property should point to a database record or webpage that supports the existence of the edge, or gives more detail about the edge. This property can be used on a node or edge to provide multiple URIs or CURIE cross references. in_subset: - translator_minimal aliases: - dbxref - Dbxref - DbXref - record_url - source_record_urls narrow_mappings: - gff3:Dbxref - gpi:DB_Xrefs domain: named thing domain_of: - named thing - publication - retrieval source - gene - gene product mixin range: uriorcurie multivalued: true Disease: name: Disease id_prefixes: - MONDO - DOID - OMIM - OMIM.PS - orphanet - EFO - UMLS - MESH - MEDDRA - NCIT - SNOMEDCT - medgen - ICD10 - ICD9 - KEGG.DISEASE - HP - MP - PHARMGKB.DISEASE description: A disorder of structure or function, especially one that produces specific signs, phenotypes or symptoms or that affects a specific location and is not simply a direct result of physical injury. A disposition to undergo pathological processes that exists in an organism because of one or more disorders in that organism. in_subset: - model_organism_database - translator_minimal aliases: - condition - disorder - medical condition exact_mappings: - MONDO:0000001 - DOID:4 - NCIT:C2991 - WIKIDATA:Q12136 - SIO:010299 - UMLSSG:DISO - STY:T047 - dcid:Disease narrow_mappings: - STY:T019 - STY:T020 - STY:T048 - STY:T049 - STY:T191 - MONDO:0042489 CaseToPhenotypicFeatureAssociation: name: CaseToPhenotypicFeatureAssociation description: An association between a case (e.g. individual patient) and a phenotypic feature in which the individual has or has had the phenotype. defining_slots: - subject - object GeneToDiseaseAssociation: name: GeneToDiseaseAssociation comments: - NCIT:R176 refers to the inverse relationship exact_mappings: - SIO:000983 close_mappings: - dcid:DiseaseGeneAssociation defining_slots: - subject - object GeneToPhenotypicFeatureAssociation: name: GeneToPhenotypicFeatureAssociation exact_mappings: - WBVocab:Gene-Phenotype-Association defining_slots: - subject - object Case: name: Case description: An individual (human) organism that has a patient role in some clinical context. aliases: - patient - proband PhenotypicFeature: name: PhenotypicFeature id_prefixes: - HP - EFO - NCIT - UMLS - MEDDRA - MP - ZP - UPHENO - APO - FBcv - WBPhenotype - SNOMEDCT - MESH - XPO - FYPO - TO description: A combination of entity and quality that makes up a phenotyping statement. An observable characteristic of an individual resulting from the interaction of its genotype with its molecular and physical environment. examples: - value: MP:0001262 description: decreased body weight in_subset: - model_organism_database aliases: - sign - symptom - phenotype - trait - endophenotype exact_mappings: - UPHENO:0001001 - SIO:010056 - WIKIDATA:Q104053 - UMLS:C4021819 - NCIT:C16977 - SNOMEDCT:8116006 - MESH:D010641 narrow_mappings: - STY:T184 - WIKIDATA:Q169872 - WIKIDATA:Q25203551 - ZP:00000000 - FBcv:0001347 - HP:0000118 - MP:0000001 - WBPhenotype:0000886 - XPO:00000000 - FYPO:0000001 - APO:0000017 - TO:0000387 - STY:T190 broad_mappings: - BFO:0000019 - PATO:0000001 Notes: * notice that if we remove a parent class from this, e.g. remove \"NamedThing\" - the is_a path in the descendent classes will be absent. this is to prevent unreachable element errors. * notice that helpful defaults are brought in like prefixes, descriptions, aliases, mappings, etc. * there will likely be cases where metamodel elements in LinkML are not automatically transferred to the derived schema (as will all our generators, we are working towards feature parity). * notice that the transformation automatically makes what were, independent slot definitions in Biolink Model into attributes . These are more or less functionally equivalent in LinkML, however if you want to specify a slot that can be reused outside of a particular class, it is still best practice to do so with a slot definition rather than an attribute as to not repeat slot definitions.","title":"Creating a TransformationSpecification using SchemaView and an existing model."},{"location":"examples/biolink-subsetting/#use-derived-schema-to-generate-different-serializations-of-the-derived-model","text":"Now that we have a YAML dump of our derived model, we can use standard LinkML tooling to produce: * python dataclasses and pydantic models of our derived schema * navigate our derived schema with a SchemaView instance * create and deploy automated documentation with the derived schema (see https://github.com/linkml/linkml-project-cookiecutter for more details on using the derived schema in a standard setup) ! gen - pydantic biolink - subset . yaml from __future__ import annotations from datetime import ( datetime, date ) from decimal import Decimal from enum import Enum import re import sys from typing import ( Any, ClassVar, List, Literal, Dict, Optional, Union ) from pydantic.version import VERSION as PYDANTIC_VERSION if int(PYDANTIC_VERSION[0])>=2: from pydantic import ( BaseModel, ConfigDict, Field, RootModel, field_validator ) else: from pydantic import ( BaseModel, Field, validator ) metamodel_version = \"None\" version = \"None\" class ConfiguredBaseModel(BaseModel): model_config = ConfigDict( validate_assignment = True, validate_default = True, extra = \"forbid\", arbitrary_types_allowed = True, use_enum_values = True, strict = False, ) pass class LinkMLMeta(RootModel): root: Dict[str, Any] = {} model_config = ConfigDict(frozen=True) def __getattr__(self, key:str): return getattr(self.root, key) def __getitem__(self, key:str): return self.root[key] def __setitem__(self, key:str, value): self.root[key] = value linkml_meta = LinkMLMeta({'default_prefix': 'biolink-subset/', 'id': 'biolink-subset', 'name': 'BiolinkSubset'} ) class Gene(ConfiguredBaseModel): \"\"\" A region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene locus may include regulatory regions, transcribed regions and/or other functional sequence regions. \"\"\" linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'broad_mappings': ['NCIT:C45822'], 'exact_mappings': ['SO:0000704', 'SIO:010035', 'WIKIDATA:Q7187', 'dcid:Gene'], 'from_schema': 'biolink-subset', 'id_prefixes': ['NCBIGene', 'ENSEMBL', 'HGNC', 'MGI', 'ZFIN', 'dictyBase', 'WB', 'WormBase', 'FB', 'RGD', 'SGD', 'PomBase', 'OMIM', 'KEGG.GENES', 'UMLS', 'Xenbase', 'AspGD', 'PHARMGKB.GENE'], 'in_subset': ['translator_minimal', 'model_organism_database'], 'narrow_mappings': ['bioschemas:gene']}) symbol: Optional[str] = Field(None, description=\"\"\"Symbol for a particular thing\"\"\", json_schema_extra = { \"linkml_meta\": {'alias': 'symbol', 'domain': 'named thing', 'domain_of': ['gene', 'Gene'], 'exact_mappings': ['AGRKB:symbol', 'gpi:DB_Object_Symbol'], 'is_a': 'node property'} }) xref: Optional[List[str]] = Field(default_factory=list, description=\"\"\"A database cross reference or alternative identifier for a NamedThing or edge between two NamedThings. This property should point to a database record or webpage that supports the existence of the edge, or gives more detail about the edge. This property can be used on a node or edge to provide multiple URIs or CURIE cross references.\"\"\", json_schema_extra = { \"linkml_meta\": {'alias': 'xref', 'aliases': ['dbxref', 'Dbxref', 'DbXref', 'record_url', 'source_record_urls'], 'domain': 'named thing', 'domain_of': ['named thing', 'publication', 'retrieval source', 'gene', 'gene product mixin', 'Gene'], 'in_subset': ['translator_minimal'], 'narrow_mappings': ['gff3:Dbxref', 'gpi:DB_Xrefs']} }) class Disease(ConfiguredBaseModel): \"\"\" A disorder of structure or function, especially one that produces specific signs, phenotypes or symptoms or that affects a specific location and is not simply a direct result of physical injury. A disposition to undergo pathological processes that exists in an organism because of one or more disorders in that organism. \"\"\" linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'aliases': ['condition', 'disorder', 'medical condition'], 'exact_mappings': ['MONDO:0000001', 'DOID:4', 'NCIT:C2991', 'WIKIDATA:Q12136', 'SIO:010299', 'UMLSSG:DISO', 'STY:T047', 'dcid:Disease'], 'from_schema': 'biolink-subset', 'id_prefixes': ['MONDO', 'DOID', 'OMIM', 'OMIM.PS', 'orphanet', 'EFO', 'UMLS', 'MESH', 'MEDDRA', 'NCIT', 'SNOMEDCT', 'medgen', 'ICD10', 'ICD9', 'KEGG.DISEASE', 'HP', 'MP', 'PHARMGKB.DISEASE'], 'in_subset': ['model_organism_database', 'translator_minimal'], 'narrow_mappings': ['STY:T019', 'STY:T020', 'STY:T048', 'STY:T049', 'STY:T191', 'MONDO:0042489']}) pass class CaseToPhenotypicFeatureAssociation(ConfiguredBaseModel): \"\"\" An association between a case (e.g. individual patient) and a phenotypic feature in which the individual has or has had the phenotype. \"\"\" linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'defining_slots': ['subject', 'object'], 'from_schema': 'biolink-subset'}) pass class GeneToDiseaseAssociation(ConfiguredBaseModel): linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'close_mappings': ['dcid:DiseaseGeneAssociation'], 'comments': ['NCIT:R176 refers to the inverse relationship'], 'defining_slots': ['subject', 'object'], 'exact_mappings': ['SIO:000983'], 'from_schema': 'biolink-subset'}) pass class GeneToPhenotypicFeatureAssociation(ConfiguredBaseModel): linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'defining_slots': ['subject', 'object'], 'exact_mappings': ['WBVocab:Gene-Phenotype-Association'], 'from_schema': 'biolink-subset'}) pass class Case(ConfiguredBaseModel): \"\"\" An individual (human) organism that has a patient role in some clinical context. \"\"\" linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'aliases': ['patient', 'proband'], 'from_schema': 'biolink-subset'}) pass class PhenotypicFeature(ConfiguredBaseModel): \"\"\" A combination of entity and quality that makes up a phenotyping statement. An observable characteristic of an individual resulting from the interaction of its genotype with its molecular and physical environment. \"\"\" linkml_meta: ClassVar[LinkMLMeta] = LinkMLMeta({'aliases': ['sign', 'symptom', 'phenotype', 'trait', 'endophenotype'], 'broad_mappings': ['BFO:0000019', 'PATO:0000001'], 'exact_mappings': ['UPHENO:0001001', 'SIO:010056', 'WIKIDATA:Q104053', 'UMLS:C4021819', 'NCIT:C16977', 'SNOMEDCT:8116006', 'MESH:D010641'], 'examples': [{'description': 'decreased body weight', 'value': 'MP:0001262'}], 'from_schema': 'biolink-subset', 'id_prefixes': ['HP', 'EFO', 'NCIT', 'UMLS', 'MEDDRA', 'MP', 'ZP', 'UPHENO', 'APO', 'FBcv', 'WBPhenotype', 'SNOMEDCT', 'MESH', 'XPO', 'FYPO', 'TO'], 'in_subset': ['model_organism_database'], 'narrow_mappings': ['STY:T184', 'WIKIDATA:Q169872', 'WIKIDATA:Q25203551', 'ZP:00000000', 'FBcv:0001347', 'HP:0000118', 'MP:0000001', 'WBPhenotype:0000886', 'XPO:00000000', 'FYPO:0000001', 'APO:0000017', 'TO:0000387', 'STY:T190']}) pass # Model rebuild # see https://pydantic-docs.helpmanual.io/usage/models/#rebuilding-a-model Gene.model_rebuild() Disease.model_rebuild() CaseToPhenotypicFeatureAssociation.model_rebuild() GeneToDiseaseAssociation.model_rebuild() GeneToPhenotypicFeatureAssociation.model_rebuild() Case.model_rebuild() PhenotypicFeature.model_rebuild() ! gen - doc biolink - subset . yaml - d docs ValueError: No such slot as \"node property\"","title":"Use derived schema to generate different serializations of the derived model"},{"location":"examples/denormalizing/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); from pathlib import Path from linkml_runtime.dumpers import yaml_dumper from linkml_runtime.utils.schemaview import SchemaView from linkml_map.inference.schema_mapper import SchemaMapper from linkml_map.session import Session from linkml_map.utils.loaders import load_specification REPO_ROOT = Path . cwd () . parent . parent input_schema = REPO_ROOT / \"tests/input/examples/flattening/source/normalized.yaml\" output_schema = REPO_ROOT / \"tests/input/examples/flattening/target/denormalized.yaml\" transformation_specification_file = REPO_ROOT / \"tests/input/examples/flattening/transform/denormalize.transform.yaml\" # Initialize Session and SchemaBuilder session = Session () source_schema_view = SchemaView ( input_schema ) target_schema_view = SchemaView ( output_schema ) # Set the source schema in the session session . set_source_schema ( source_schema_view ) tr_spec = load_specification ( transformation_specification_file ) mapper = SchemaMapper () mapper . source_schemaview = source_schema_view target_schema_obj = mapper . derive_schema ( specification = tr_spec , target_schema_id = \"denormalized-view\" , target_schema_name = \"DenormalizedView\" , ) yaml_dumper . dump ( target_schema_obj , str ( \"denormalized_view.yaml\" )) transformed_sv = SchemaView ( \"denormalized_view.yaml\" ) for class_name in transformed_sv . all_classes (): print ( class_name ) print () for slot_name in transformed_sv . all_slots (): print ( slot_name ) MappingSet Mapping mappings subject_id subject_name object_id object_name predicate_id","title":"Denormalizing"},{"location":"schema/","text":"LinkML Map Data Model Datamodel for LinkML schema mappings and transformations. A mapper generates instances of a target data model from instances of a source data model. This transformation process is guided by a TransformationSpecification . The specification is independent of any one method for transforming data. It allows different approaches, including: direct implementation, transforming python or json objects translation of the specification into SQL commands, to operate on relations translation of the specification into SPARQL CONSTRUCTs, to operate on triples translation into another specification language, such as R2RML URI: https://w3id.org/linkml/transformer Name: linkml-map Classes Class Description AliasedClass alias-class key value pairs for classes Any None CopyDirective Instructs a Schema Mapper in how to map to a target schema. Not used for data transformation. Inverse Used for back references in mapping to relational model KeyVal None SpecificationComponent None ElementDerivation An abstract grouping for classes that provide a specification of how to derive a target element from a source element. ClassDerivation A specification of how to derive a target class from a source class. EnumDerivation A specification of how to derive the value of a target enum from a source enum PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum PrefixDerivation None SlotDerivation A specification of how to derive the value of a target slot from a source slot TransformationSpecification A collection of mappings between source and target classes StringificationConfiguration None UnitConversionConfiguration None Slots Slot Description add alias name of the class to be aliased cast_collection_as class_derivations Instructions on how to derive a set of classes in the target schema from clas... class_name class_named local alias for the class comments A list of comments about this component copy_all copy_directives delimiter derived_from Source slots that are used to derive this slot description description of the specification component dictionary_key element_name enum_derivations Instructions on how to derive a set of enums in the target schema exclude exclude_all expr An expression to be evaluated on the source object to derive the target slot expression_to_expression_mappings A mapping table in which the keys and values are expressions expression_to_value_mappings A mapping table in which the keys are expressions hide True if this is suppressed id Unique identifier for this transformation specification implements A reference to a specification that this component implements include inverse_of Used to specify a class-slot tuple that is the inverse of the derived/target ... is_a joins Additional classes to be joined to derive instances of the target class key mirror_source mixins name Name of the element in the target schema over_slots overrides overrides source schema slots permissible_value_derivations Instructions on how to derive a set of PVs in the target schema populated_from Name of the class in the source schema prefixes maps prefixes to URL expansions range reversed slot_derivations Instructions on how to derive a set of top level slots in the target schema slot_name source_magnitude_slot source_schema name of the schema that describes the source (input) objects source_unit source_unit_scheme source_unit_slot sources stringification syntax target_magnitude_slot target_schema name of the schema that describes the target (output) objects target_unit target_unit_scheme target_unit_slot title human readable title for this transformation specification type_designator unit_conversion value value_mappings A mapping table that is applied directly to mappings, in order of precedence Enumerations Enumeration Description CollectionType SerializationSyntaxType Types Type Description Boolean A binary (true or false) value ClassReference Curie a compact URI Date a date (year, month and day) in an idealized calendar DateOrDatetime Either a date or a datetime Datetime The combination of a date and time Decimal A real number with arbitrary precision that conforms to the xsd:decimal speci... Double A real number that conforms to the xsd:double specification EnumReference Float A real number that conforms to the xsd:float specification Integer An integer Jsonpath A string encoding a JSON Path Jsonpointer A string encoding a JSON Pointer Ncname Prefix part of CURIE Nodeidentifier A URI, CURIE or BNODE that represents a node in a model Objectidentifier A URI or CURIE that represents an object in the model SlotReference Sparqlpath A string encoding a SPARQL Property Path String A character string Time A time object represents a (local) time of day, independent of any particular... Uri a complete URI Uriorcurie a URI or a CURIE Subsets Subset Description","title":"LinkML Map Data Model"},{"location":"schema/#linkml-map-data-model","text":"Datamodel for LinkML schema mappings and transformations. A mapper generates instances of a target data model from instances of a source data model. This transformation process is guided by a TransformationSpecification . The specification is independent of any one method for transforming data. It allows different approaches, including: direct implementation, transforming python or json objects translation of the specification into SQL commands, to operate on relations translation of the specification into SPARQL CONSTRUCTs, to operate on triples translation into another specification language, such as R2RML URI: https://w3id.org/linkml/transformer Name: linkml-map","title":"LinkML Map Data Model"},{"location":"schema/#classes","text":"Class Description AliasedClass alias-class key value pairs for classes Any None CopyDirective Instructs a Schema Mapper in how to map to a target schema. Not used for data transformation. Inverse Used for back references in mapping to relational model KeyVal None SpecificationComponent None ElementDerivation An abstract grouping for classes that provide a specification of how to derive a target element from a source element. ClassDerivation A specification of how to derive a target class from a source class. EnumDerivation A specification of how to derive the value of a target enum from a source enum PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum PrefixDerivation None SlotDerivation A specification of how to derive the value of a target slot from a source slot TransformationSpecification A collection of mappings between source and target classes StringificationConfiguration None UnitConversionConfiguration None","title":"Classes"},{"location":"schema/#slots","text":"Slot Description add alias name of the class to be aliased cast_collection_as class_derivations Instructions on how to derive a set of classes in the target schema from clas... class_name class_named local alias for the class comments A list of comments about this component copy_all copy_directives delimiter derived_from Source slots that are used to derive this slot description description of the specification component dictionary_key element_name enum_derivations Instructions on how to derive a set of enums in the target schema exclude exclude_all expr An expression to be evaluated on the source object to derive the target slot expression_to_expression_mappings A mapping table in which the keys and values are expressions expression_to_value_mappings A mapping table in which the keys are expressions hide True if this is suppressed id Unique identifier for this transformation specification implements A reference to a specification that this component implements include inverse_of Used to specify a class-slot tuple that is the inverse of the derived/target ... is_a joins Additional classes to be joined to derive instances of the target class key mirror_source mixins name Name of the element in the target schema over_slots overrides overrides source schema slots permissible_value_derivations Instructions on how to derive a set of PVs in the target schema populated_from Name of the class in the source schema prefixes maps prefixes to URL expansions range reversed slot_derivations Instructions on how to derive a set of top level slots in the target schema slot_name source_magnitude_slot source_schema name of the schema that describes the source (input) objects source_unit source_unit_scheme source_unit_slot sources stringification syntax target_magnitude_slot target_schema name of the schema that describes the target (output) objects target_unit target_unit_scheme target_unit_slot title human readable title for this transformation specification type_designator unit_conversion value value_mappings A mapping table that is applied directly to mappings, in order of precedence","title":"Slots"},{"location":"schema/#enumerations","text":"Enumeration Description CollectionType SerializationSyntaxType","title":"Enumerations"},{"location":"schema/#types","text":"Type Description Boolean A binary (true or false) value ClassReference Curie a compact URI Date a date (year, month and day) in an idealized calendar DateOrDatetime Either a date or a datetime Datetime The combination of a date and time Decimal A real number with arbitrary precision that conforms to the xsd:decimal speci... Double A real number that conforms to the xsd:double specification EnumReference Float A real number that conforms to the xsd:float specification Integer An integer Jsonpath A string encoding a JSON Path Jsonpointer A string encoding a JSON Pointer Ncname Prefix part of CURIE Nodeidentifier A URI, CURIE or BNODE that represents a node in a model Objectidentifier A URI or CURIE that represents an object in the model SlotReference Sparqlpath A string encoding a SPARQL Property Path String A character string Time A time object represents a (local) time of day, independent of any particular... Uri a complete URI Uriorcurie a URI or a CURIE","title":"Types"},{"location":"schema/#subsets","text":"Subset Description","title":"Subsets"},{"location":"schema/AliasedClass/","text":"Class: AliasedClass alias-class key value pairs for classes URI: linkmltr:AliasedClass classDiagram class AliasedClass AliasedClass : alias AliasedClass --> None : alias AliasedClass : class_named AliasedClass --> None : class_named Slots Name Cardinality and Range Description Inheritance alias 0..1 String name of the class to be aliased direct class_named 0..1 String local alias for the class direct Usages used by used in type used ClassDerivation joins range AliasedClass Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:AliasedClass native linkmltr:AliasedClass LinkML Source Direct name : AliasedClass description : alias-class key value pairs for classes from_schema : https://w3id.org/linkml/transformer attributes : alias : name : alias description : name of the class to be aliased from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true domain_of : - AliasedClass required : true class_named : name : class_named description : local alias for the class from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - AliasedClass Induced name : AliasedClass description : alias-class key value pairs for classes from_schema : https://w3id.org/linkml/transformer attributes : alias : name : alias description : name of the class to be aliased from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : alias owner : AliasedClass domain_of : - AliasedClass required : true class_named : name : class_named description : local alias for the class from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : class_named owner : AliasedClass domain_of : - AliasedClass","title":"Class: AliasedClass"},{"location":"schema/AliasedClass/#class-aliasedclass","text":"alias-class key value pairs for classes URI: linkmltr:AliasedClass classDiagram class AliasedClass AliasedClass : alias AliasedClass --> None : alias AliasedClass : class_named AliasedClass --> None : class_named","title":"Class: AliasedClass"},{"location":"schema/AliasedClass/#slots","text":"Name Cardinality and Range Description Inheritance alias 0..1 String name of the class to be aliased direct class_named 0..1 String local alias for the class direct","title":"Slots"},{"location":"schema/AliasedClass/#usages","text":"used by used in type used ClassDerivation joins range AliasedClass","title":"Usages"},{"location":"schema/AliasedClass/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/AliasedClass/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/AliasedClass/#mappings","text":"Mapping Type Mapped Value self linkmltr:AliasedClass native linkmltr:AliasedClass","title":"Mappings"},{"location":"schema/AliasedClass/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/AliasedClass/#direct","text":"name : AliasedClass description : alias-class key value pairs for classes from_schema : https://w3id.org/linkml/transformer attributes : alias : name : alias description : name of the class to be aliased from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true domain_of : - AliasedClass required : true class_named : name : class_named description : local alias for the class from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - AliasedClass","title":"Direct"},{"location":"schema/AliasedClass/#induced","text":"name : AliasedClass description : alias-class key value pairs for classes from_schema : https://w3id.org/linkml/transformer attributes : alias : name : alias description : name of the class to be aliased from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : alias owner : AliasedClass domain_of : - AliasedClass required : true class_named : name : class_named description : local alias for the class from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : class_named owner : AliasedClass domain_of : - AliasedClass","title":"Induced"},{"location":"schema/Any/","text":"Class: Any URI: linkml:Any classDiagram class Any click Any href \"../Any\" Slots Name Cardinality and Range Description Inheritance Usages used by used in type used ElementDerivation overrides range Any ClassDerivation target_definition range Any ClassDerivation overrides range Any SlotDerivation target_definition range Any SlotDerivation overrides range Any EnumDerivation overrides range Any PermissibleValueDerivation overrides range Any PrefixDerivation overrides range Any KeyVal value range Any CopyDirective exclude range Any CopyDirective include range Any CopyDirective add range Any Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkml:Any native linkmlmap:Any LinkML Source Direct name : Any from_schema : https://w3id.org/linkml/transformer class_uri : linkml:Any Induced name : Any from_schema : https://w3id.org/linkml/transformer class_uri : linkml:Any","title":"Class: Any"},{"location":"schema/Any/#class-any","text":"URI: linkml:Any classDiagram class Any click Any href \"../Any\"","title":"Class: Any"},{"location":"schema/Any/#slots","text":"Name Cardinality and Range Description Inheritance","title":"Slots"},{"location":"schema/Any/#usages","text":"used by used in type used ElementDerivation overrides range Any ClassDerivation target_definition range Any ClassDerivation overrides range Any SlotDerivation target_definition range Any SlotDerivation overrides range Any EnumDerivation overrides range Any PermissibleValueDerivation overrides range Any PrefixDerivation overrides range Any KeyVal value range Any CopyDirective exclude range Any CopyDirective include range Any CopyDirective add range Any","title":"Usages"},{"location":"schema/Any/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Any/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Any/#mappings","text":"Mapping Type Mapped Value self linkml:Any native linkmlmap:Any","title":"Mappings"},{"location":"schema/Any/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/Any/#direct","text":"name : Any from_schema : https://w3id.org/linkml/transformer class_uri : linkml:Any","title":"Direct"},{"location":"schema/Any/#induced","text":"name : Any from_schema : https://w3id.org/linkml/transformer class_uri : linkml:Any","title":"Induced"},{"location":"schema/Boolean/","text":"Type: Boolean A binary (true or false) value URI: xsd:boolean base : Bool uri : xsd:boolean repr : bool Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Boolean"},{"location":"schema/Boolean/#type-boolean","text":"A binary (true or false) value URI: xsd:boolean base : Bool uri : xsd:boolean repr : bool","title":"Type: Boolean"},{"location":"schema/Boolean/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Boolean/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/ClassDerivation/","text":"Class: ClassDerivation A specification of how to derive a target class from a source class. URI: linkmltr:ClassDerivation classDiagram class ClassDerivation ElementDerivation <|-- ClassDerivation ClassDerivation : comments ClassDerivation : copy_directives ClassDerivation --> CopyDirective : copy_directives ClassDerivation : description ClassDerivation --> None : description ClassDerivation : expression_to_expression_mappings ClassDerivation --> KeyVal : expression_to_expression_mappings ClassDerivation : expression_to_value_mappings ClassDerivation --> KeyVal : expression_to_value_mappings ClassDerivation : implements ClassDerivation : is_a ClassDerivation --> ElementDerivation : is_a ClassDerivation : joins ClassDerivation --> AliasedClass : joins ClassDerivation : mirror_source ClassDerivation : mixins ClassDerivation --> ElementDerivation : mixins ClassDerivation : name ClassDerivation --> None : name ClassDerivation : overrides ClassDerivation --> Any : overrides ClassDerivation : populated_from ClassDerivation : slot_derivations ClassDerivation --> SlotDerivation : slot_derivations ClassDerivation : sources ClassDerivation : value_mappings ClassDerivation --> KeyVal : value_mappings Inheritance SpecificationComponent ElementDerivation ClassDerivation Slots Name Cardinality and Range Description Inheritance populated_from 0..1 ClassReference Name of the class in the source schema direct sources 0..* ClassReference direct joins 0..* AliasedClass Additional classes to be joined to derive instances of the target class direct slot_derivations 0..* SlotDerivation direct name 1..1 String Name of the element in the target schema ElementDerivation copy_directives 0..* CopyDirective ElementDerivation overrides 0..1 Any overrides source schema slots ElementDerivation is_a 0..1 ElementDerivation ElementDerivation mixins 0..* ElementDerivation ElementDerivation value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence ElementDerivation expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions ElementDerivation expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions ElementDerivation mirror_source 0..1 Boolean ElementDerivation description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent Usages used by used in type used TransformationSpecification class_derivations range ClassDerivation Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:ClassDerivation native linkmltr:ClassDerivation LinkML Source Direct name : ClassDerivation description : A specification of how to derive a target class from a source class. from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : populated_from : name : populated_from description : Name of the class in the source schema from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : ClassReference sources : name : sources from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : ClassReference joins : name : joins description : Additional classes to be joined to derive instances of the target class comments : - not yet implemented from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ClassDerivation range : AliasedClass inlined : true slot_derivations : name : slot_derivations from_schema : https://w3id.org/linkml/transformer multivalued : true domain_of : - TransformationSpecification - ClassDerivation range : SlotDerivation inlined : true Induced name : ClassDerivation description : A specification of how to derive a target class from a source class. from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : populated_from : name : populated_from description : Name of the class in the source schema from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : populated_from owner : ClassDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : ClassReference sources : name : sources from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : sources owner : ClassDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : ClassReference joins : name : joins description : Additional classes to be joined to derive instances of the target class comments : - not yet implemented from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : joins owner : ClassDerivation domain_of : - ClassDerivation range : AliasedClass inlined : true slot_derivations : name : slot_derivations from_schema : https://w3id.org/linkml/transformer multivalued : true alias : slot_derivations owner : ClassDerivation domain_of : - TransformationSpecification - ClassDerivation range : SlotDerivation inlined : true name : name : name description : Name of the element in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : name owner : ClassDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string required : true copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : ClassDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : ClassDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : ClassDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : ClassDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : ClassDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : ClassDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : ClassDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : ClassDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : ClassDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : ClassDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : ClassDerivation domain_of : - SpecificationComponent range : string","title":"Class: ClassDerivation"},{"location":"schema/ClassDerivation/#class-classderivation","text":"A specification of how to derive a target class from a source class. URI: linkmltr:ClassDerivation classDiagram class ClassDerivation ElementDerivation <|-- ClassDerivation ClassDerivation : comments ClassDerivation : copy_directives ClassDerivation --> CopyDirective : copy_directives ClassDerivation : description ClassDerivation --> None : description ClassDerivation : expression_to_expression_mappings ClassDerivation --> KeyVal : expression_to_expression_mappings ClassDerivation : expression_to_value_mappings ClassDerivation --> KeyVal : expression_to_value_mappings ClassDerivation : implements ClassDerivation : is_a ClassDerivation --> ElementDerivation : is_a ClassDerivation : joins ClassDerivation --> AliasedClass : joins ClassDerivation : mirror_source ClassDerivation : mixins ClassDerivation --> ElementDerivation : mixins ClassDerivation : name ClassDerivation --> None : name ClassDerivation : overrides ClassDerivation --> Any : overrides ClassDerivation : populated_from ClassDerivation : slot_derivations ClassDerivation --> SlotDerivation : slot_derivations ClassDerivation : sources ClassDerivation : value_mappings ClassDerivation --> KeyVal : value_mappings","title":"Class: ClassDerivation"},{"location":"schema/ClassDerivation/#inheritance","text":"SpecificationComponent ElementDerivation ClassDerivation","title":"Inheritance"},{"location":"schema/ClassDerivation/#slots","text":"Name Cardinality and Range Description Inheritance populated_from 0..1 ClassReference Name of the class in the source schema direct sources 0..* ClassReference direct joins 0..* AliasedClass Additional classes to be joined to derive instances of the target class direct slot_derivations 0..* SlotDerivation direct name 1..1 String Name of the element in the target schema ElementDerivation copy_directives 0..* CopyDirective ElementDerivation overrides 0..1 Any overrides source schema slots ElementDerivation is_a 0..1 ElementDerivation ElementDerivation mixins 0..* ElementDerivation ElementDerivation value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence ElementDerivation expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions ElementDerivation expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions ElementDerivation mirror_source 0..1 Boolean ElementDerivation description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent","title":"Slots"},{"location":"schema/ClassDerivation/#usages","text":"used by used in type used TransformationSpecification class_derivations range ClassDerivation","title":"Usages"},{"location":"schema/ClassDerivation/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/ClassDerivation/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/ClassDerivation/#mappings","text":"Mapping Type Mapped Value self linkmltr:ClassDerivation native linkmltr:ClassDerivation","title":"Mappings"},{"location":"schema/ClassDerivation/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/ClassDerivation/#direct","text":"name : ClassDerivation description : A specification of how to derive a target class from a source class. from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : populated_from : name : populated_from description : Name of the class in the source schema from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : ClassReference sources : name : sources from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : ClassReference joins : name : joins description : Additional classes to be joined to derive instances of the target class comments : - not yet implemented from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ClassDerivation range : AliasedClass inlined : true slot_derivations : name : slot_derivations from_schema : https://w3id.org/linkml/transformer multivalued : true domain_of : - TransformationSpecification - ClassDerivation range : SlotDerivation inlined : true","title":"Direct"},{"location":"schema/ClassDerivation/#induced","text":"name : ClassDerivation description : A specification of how to derive a target class from a source class. from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : populated_from : name : populated_from description : Name of the class in the source schema from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : populated_from owner : ClassDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : ClassReference sources : name : sources from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : sources owner : ClassDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : ClassReference joins : name : joins description : Additional classes to be joined to derive instances of the target class comments : - not yet implemented from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : joins owner : ClassDerivation domain_of : - ClassDerivation range : AliasedClass inlined : true slot_derivations : name : slot_derivations from_schema : https://w3id.org/linkml/transformer multivalued : true alias : slot_derivations owner : ClassDerivation domain_of : - TransformationSpecification - ClassDerivation range : SlotDerivation inlined : true name : name : name description : Name of the element in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : name owner : ClassDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string required : true copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : ClassDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : ClassDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : ClassDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : ClassDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : ClassDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : ClassDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : ClassDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : ClassDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : ClassDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : ClassDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : ClassDerivation domain_of : - SpecificationComponent range : string","title":"Induced"},{"location":"schema/ClassReference/","text":"Type: ClassReference URI: xsd:string base : str uri : xsd:string typeof : string Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: ClassReference"},{"location":"schema/ClassReference/#type-classreference","text":"URI: xsd:string base : str uri : xsd:string typeof : string","title":"Type: ClassReference"},{"location":"schema/ClassReference/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/ClassReference/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/CollectionType/","text":"Enum: CollectionType URI: CollectionType Permissible Values Value Meaning Description SingleValued None MultiValued None MultiValuedList None MultiValuedDict None Slots Name Description cast_collection_as Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : CollectionType from_schema : https://w3id.org/linkml/transformer rank : 1000 permissible_values : SingleValued : text : SingleValued MultiValued : text : MultiValued MultiValuedList : text : MultiValuedList MultiValuedDict : text : MultiValuedDict","title":"Enum: CollectionType"},{"location":"schema/CollectionType/#enum-collectiontype","text":"URI: CollectionType","title":"Enum: CollectionType"},{"location":"schema/CollectionType/#permissible-values","text":"Value Meaning Description SingleValued None MultiValued None MultiValuedList None MultiValuedDict None","title":"Permissible Values"},{"location":"schema/CollectionType/#slots","text":"Name Description cast_collection_as","title":"Slots"},{"location":"schema/CollectionType/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/CollectionType/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/CollectionType/#linkml-source","text":"name : CollectionType from_schema : https://w3id.org/linkml/transformer rank : 1000 permissible_values : SingleValued : text : SingleValued MultiValued : text : MultiValued MultiValuedList : text : MultiValuedList MultiValuedDict : text : MultiValuedDict","title":"LinkML Source"},{"location":"schema/CopyDirective/","text":"Class: CopyDirective Instructs a Schema Mapper in how to map to a target schema. Not used for data transformation. URI: linkmltr:CopyDirective classDiagram class CopyDirective CopyDirective : add CopyDirective --> Any : add CopyDirective : copy_all CopyDirective : element_name CopyDirective --> None : element_name CopyDirective : exclude CopyDirective --> Any : exclude CopyDirective : exclude_all CopyDirective : include CopyDirective --> Any : include Slots Name Cardinality and Range Description Inheritance element_name 0..1 String direct copy_all 0..1 Boolean direct exclude_all 0..1 Boolean direct exclude 0..1 Any direct include 0..1 Any direct add 0..1 Any direct Usages used by used in type used ElementDerivation copy_directives range CopyDirective ClassDerivation copy_directives range CopyDirective SlotDerivation copy_directives range CopyDirective EnumDerivation copy_directives range CopyDirective PermissibleValueDerivation copy_directives range CopyDirective PrefixDerivation copy_directives range CopyDirective Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:CopyDirective native linkmltr:CopyDirective LinkML Source Direct name : CopyDirective description : Instructs a Schema Mapper in how to map to a target schema. Not used for data transformation. from_schema : https://w3id.org/linkml/transformer status : testing attributes : element_name : name : element_name from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true domain_of : - CopyDirective required : true copy_all : name : copy_all from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - CopyDirective range : boolean exclude_all : name : exclude_all from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - CopyDirective range : boolean exclude : name : exclude from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - CopyDirective range : Any include : name : include from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - CopyDirective range : Any add : name : add from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - CopyDirective range : Any Induced name : CopyDirective description : Instructs a Schema Mapper in how to map to a target schema. Not used for data transformation. from_schema : https://w3id.org/linkml/transformer status : testing attributes : element_name : name : element_name from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : element_name owner : CopyDirective domain_of : - CopyDirective required : true copy_all : name : copy_all from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : copy_all owner : CopyDirective domain_of : - CopyDirective range : boolean exclude_all : name : exclude_all from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : exclude_all owner : CopyDirective domain_of : - CopyDirective range : boolean exclude : name : exclude from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : exclude owner : CopyDirective domain_of : - CopyDirective range : Any include : name : include from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : include owner : CopyDirective domain_of : - CopyDirective range : Any add : name : add from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : add owner : CopyDirective domain_of : - CopyDirective range : Any","title":"Class: CopyDirective"},{"location":"schema/CopyDirective/#class-copydirective","text":"Instructs a Schema Mapper in how to map to a target schema. Not used for data transformation. URI: linkmltr:CopyDirective classDiagram class CopyDirective CopyDirective : add CopyDirective --> Any : add CopyDirective : copy_all CopyDirective : element_name CopyDirective --> None : element_name CopyDirective : exclude CopyDirective --> Any : exclude CopyDirective : exclude_all CopyDirective : include CopyDirective --> Any : include","title":"Class: CopyDirective"},{"location":"schema/CopyDirective/#slots","text":"Name Cardinality and Range Description Inheritance element_name 0..1 String direct copy_all 0..1 Boolean direct exclude_all 0..1 Boolean direct exclude 0..1 Any direct include 0..1 Any direct add 0..1 Any direct","title":"Slots"},{"location":"schema/CopyDirective/#usages","text":"used by used in type used ElementDerivation copy_directives range CopyDirective ClassDerivation copy_directives range CopyDirective SlotDerivation copy_directives range CopyDirective EnumDerivation copy_directives range CopyDirective PermissibleValueDerivation copy_directives range CopyDirective PrefixDerivation copy_directives range CopyDirective","title":"Usages"},{"location":"schema/CopyDirective/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/CopyDirective/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/CopyDirective/#mappings","text":"Mapping Type Mapped Value self linkmltr:CopyDirective native linkmltr:CopyDirective","title":"Mappings"},{"location":"schema/CopyDirective/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/CopyDirective/#direct","text":"name : CopyDirective description : Instructs a Schema Mapper in how to map to a target schema. Not used for data transformation. from_schema : https://w3id.org/linkml/transformer status : testing attributes : element_name : name : element_name from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true domain_of : - CopyDirective required : true copy_all : name : copy_all from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - CopyDirective range : boolean exclude_all : name : exclude_all from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - CopyDirective range : boolean exclude : name : exclude from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - CopyDirective range : Any include : name : include from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - CopyDirective range : Any add : name : add from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - CopyDirective range : Any","title":"Direct"},{"location":"schema/CopyDirective/#induced","text":"name : CopyDirective description : Instructs a Schema Mapper in how to map to a target schema. Not used for data transformation. from_schema : https://w3id.org/linkml/transformer status : testing attributes : element_name : name : element_name from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : element_name owner : CopyDirective domain_of : - CopyDirective required : true copy_all : name : copy_all from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : copy_all owner : CopyDirective domain_of : - CopyDirective range : boolean exclude_all : name : exclude_all from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : exclude_all owner : CopyDirective domain_of : - CopyDirective range : boolean exclude : name : exclude from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : exclude owner : CopyDirective domain_of : - CopyDirective range : Any include : name : include from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : include owner : CopyDirective domain_of : - CopyDirective range : Any add : name : add from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : add owner : CopyDirective domain_of : - CopyDirective range : Any","title":"Induced"},{"location":"schema/Curie/","text":"Type: Curie a compact URI URI: xsd:string base : Curie uri : xsd:string repr : str Comments in RDF serializations this MUST be expanded to a URI in non-RDF serializations MAY be serialized as the compact representation Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Curie"},{"location":"schema/Curie/#type-curie","text":"a compact URI URI: xsd:string base : Curie uri : xsd:string repr : str","title":"Type: Curie"},{"location":"schema/Curie/#comments","text":"in RDF serializations this MUST be expanded to a URI in non-RDF serializations MAY be serialized as the compact representation","title":"Comments"},{"location":"schema/Curie/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Curie/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Date/","text":"Type: Date a date (year, month and day) in an idealized calendar URI: xsd:date base : XSDDate uri : xsd:date repr : str Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Date"},{"location":"schema/Date/#type-date","text":"a date (year, month and day) in an idealized calendar URI: xsd:date base : XSDDate uri : xsd:date repr : str","title":"Type: Date"},{"location":"schema/Date/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Date/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/DateOrDatetime/","text":"Type: DateOrDatetime Either a date or a datetime URI: linkml:DateOrDatetime base : str uri : linkml:DateOrDatetime repr : str Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: DateOrDatetime"},{"location":"schema/DateOrDatetime/#type-dateordatetime","text":"Either a date or a datetime URI: linkml:DateOrDatetime base : str uri : linkml:DateOrDatetime repr : str","title":"Type: DateOrDatetime"},{"location":"schema/DateOrDatetime/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/DateOrDatetime/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Datetime/","text":"Type: Datetime The combination of a date and time URI: xsd:dateTime base : XSDDateTime uri : xsd:dateTime repr : str Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Datetime"},{"location":"schema/Datetime/#type-datetime","text":"The combination of a date and time URI: xsd:dateTime base : XSDDateTime uri : xsd:dateTime repr : str","title":"Type: Datetime"},{"location":"schema/Datetime/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Datetime/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Decimal/","text":"Type: Decimal A real number with arbitrary precision that conforms to the xsd:decimal specification URI: xsd:decimal base : Decimal uri : xsd:decimal Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Decimal"},{"location":"schema/Decimal/#type-decimal","text":"A real number with arbitrary precision that conforms to the xsd:decimal specification URI: xsd:decimal base : Decimal uri : xsd:decimal","title":"Type: Decimal"},{"location":"schema/Decimal/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Decimal/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Double/","text":"Type: Double A real number that conforms to the xsd:double specification URI: xsd:double base : float uri : xsd:double Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Double"},{"location":"schema/Double/#type-double","text":"A real number that conforms to the xsd:double specification URI: xsd:double base : float uri : xsd:double","title":"Type: Double"},{"location":"schema/Double/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Double/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/ElementDerivation/","text":"Class: ElementDerivation An abstract grouping for classes that provide a specification of how to derive a target element from a source element. NOTE : this is an abstract class and should not be instantiated directly URI: linkmltr:ElementDerivation classDiagram class ElementDerivation SpecificationComponent <|-- ElementDerivation ElementDerivation <|-- ClassDerivation ElementDerivation <|-- SlotDerivation ElementDerivation <|-- EnumDerivation ElementDerivation <|-- PermissibleValueDerivation ElementDerivation <|-- PrefixDerivation ElementDerivation : comments ElementDerivation : copy_directives ElementDerivation --> CopyDirective : copy_directives ElementDerivation : description ElementDerivation --> None : description ElementDerivation : expression_to_expression_mappings ElementDerivation --> KeyVal : expression_to_expression_mappings ElementDerivation : expression_to_value_mappings ElementDerivation --> KeyVal : expression_to_value_mappings ElementDerivation : implements ElementDerivation : is_a ElementDerivation --> ElementDerivation : is_a ElementDerivation : mirror_source ElementDerivation : mixins ElementDerivation --> ElementDerivation : mixins ElementDerivation : name ElementDerivation --> None : name ElementDerivation : overrides ElementDerivation --> Any : overrides ElementDerivation : value_mappings ElementDerivation --> KeyVal : value_mappings Inheritance SpecificationComponent ElementDerivation ClassDerivation SlotDerivation EnumDerivation PermissibleValueDerivation PrefixDerivation Slots Name Cardinality and Range Description Inheritance name 0..1 String Name of the element in the target schema direct copy_directives 0..* CopyDirective direct overrides 0..1 Any overrides source schema slots direct is_a 0..1 ElementDerivation direct mixins 0..* ElementDerivation direct value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence direct expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions direct expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions direct mirror_source 0..1 Boolean direct description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent Usages used by used in type used ElementDerivation is_a range ElementDerivation ElementDerivation mixins range ElementDerivation ClassDerivation is_a range ElementDerivation ClassDerivation mixins range ElementDerivation SlotDerivation is_a range ElementDerivation SlotDerivation mixins range ElementDerivation EnumDerivation is_a range ElementDerivation EnumDerivation mixins range ElementDerivation PermissibleValueDerivation is_a range ElementDerivation PermissibleValueDerivation mixins range ElementDerivation PrefixDerivation is_a range ElementDerivation PrefixDerivation mixins range ElementDerivation Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:ElementDerivation native linkmltr:ElementDerivation LinkML Source Direct name : ElementDerivation description : An abstract grouping for classes that provide a specification of how to derive a target element from a source element. from_schema : https://w3id.org/linkml/transformer is_a : SpecificationComponent abstract : true attributes : name : name : name description : Name of the element in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - ElementDerivation range : boolean Induced name : ElementDerivation description : An abstract grouping for classes that provide a specification of how to derive a target element from a source element. from_schema : https://w3id.org/linkml/transformer is_a : SpecificationComponent abstract : true attributes : name : name : name description : Name of the element in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : name owner : ElementDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : ElementDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : ElementDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : ElementDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : ElementDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : ElementDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : ElementDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : ElementDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : ElementDerivation domain_of : - SpecificationComponent range : string","title":"Class: ElementDerivation"},{"location":"schema/ElementDerivation/#class-elementderivation","text":"An abstract grouping for classes that provide a specification of how to derive a target element from a source element. NOTE : this is an abstract class and should not be instantiated directly URI: linkmltr:ElementDerivation classDiagram class ElementDerivation SpecificationComponent <|-- ElementDerivation ElementDerivation <|-- ClassDerivation ElementDerivation <|-- SlotDerivation ElementDerivation <|-- EnumDerivation ElementDerivation <|-- PermissibleValueDerivation ElementDerivation <|-- PrefixDerivation ElementDerivation : comments ElementDerivation : copy_directives ElementDerivation --> CopyDirective : copy_directives ElementDerivation : description ElementDerivation --> None : description ElementDerivation : expression_to_expression_mappings ElementDerivation --> KeyVal : expression_to_expression_mappings ElementDerivation : expression_to_value_mappings ElementDerivation --> KeyVal : expression_to_value_mappings ElementDerivation : implements ElementDerivation : is_a ElementDerivation --> ElementDerivation : is_a ElementDerivation : mirror_source ElementDerivation : mixins ElementDerivation --> ElementDerivation : mixins ElementDerivation : name ElementDerivation --> None : name ElementDerivation : overrides ElementDerivation --> Any : overrides ElementDerivation : value_mappings ElementDerivation --> KeyVal : value_mappings","title":"Class: ElementDerivation"},{"location":"schema/ElementDerivation/#inheritance","text":"SpecificationComponent ElementDerivation ClassDerivation SlotDerivation EnumDerivation PermissibleValueDerivation PrefixDerivation","title":"Inheritance"},{"location":"schema/ElementDerivation/#slots","text":"Name Cardinality and Range Description Inheritance name 0..1 String Name of the element in the target schema direct copy_directives 0..* CopyDirective direct overrides 0..1 Any overrides source schema slots direct is_a 0..1 ElementDerivation direct mixins 0..* ElementDerivation direct value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence direct expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions direct expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions direct mirror_source 0..1 Boolean direct description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent","title":"Slots"},{"location":"schema/ElementDerivation/#usages","text":"used by used in type used ElementDerivation is_a range ElementDerivation ElementDerivation mixins range ElementDerivation ClassDerivation is_a range ElementDerivation ClassDerivation mixins range ElementDerivation SlotDerivation is_a range ElementDerivation SlotDerivation mixins range ElementDerivation EnumDerivation is_a range ElementDerivation EnumDerivation mixins range ElementDerivation PermissibleValueDerivation is_a range ElementDerivation PermissibleValueDerivation mixins range ElementDerivation PrefixDerivation is_a range ElementDerivation PrefixDerivation mixins range ElementDerivation","title":"Usages"},{"location":"schema/ElementDerivation/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/ElementDerivation/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/ElementDerivation/#mappings","text":"Mapping Type Mapped Value self linkmltr:ElementDerivation native linkmltr:ElementDerivation","title":"Mappings"},{"location":"schema/ElementDerivation/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/ElementDerivation/#direct","text":"name : ElementDerivation description : An abstract grouping for classes that provide a specification of how to derive a target element from a source element. from_schema : https://w3id.org/linkml/transformer is_a : SpecificationComponent abstract : true attributes : name : name : name description : Name of the element in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - ElementDerivation range : boolean","title":"Direct"},{"location":"schema/ElementDerivation/#induced","text":"name : ElementDerivation description : An abstract grouping for classes that provide a specification of how to derive a target element from a source element. from_schema : https://w3id.org/linkml/transformer is_a : SpecificationComponent abstract : true attributes : name : name : name description : Name of the element in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : name owner : ElementDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : ElementDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : ElementDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : ElementDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : ElementDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : ElementDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : ElementDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : ElementDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : ElementDerivation domain_of : - SpecificationComponent range : string","title":"Induced"},{"location":"schema/EnumDerivation/","text":"Class: EnumDerivation A specification of how to derive the value of a target enum from a source enum URI: linkmltr:EnumDerivation classDiagram class EnumDerivation ElementDerivation <|-- EnumDerivation EnumDerivation : comments EnumDerivation : copy_directives EnumDerivation --> CopyDirective : copy_directives EnumDerivation : description EnumDerivation --> None : description EnumDerivation : expr EnumDerivation : expression_to_expression_mappings EnumDerivation --> KeyVal : expression_to_expression_mappings EnumDerivation : expression_to_value_mappings EnumDerivation --> KeyVal : expression_to_value_mappings EnumDerivation : hide EnumDerivation : implements EnumDerivation : is_a EnumDerivation --> ElementDerivation : is_a EnumDerivation : mirror_source EnumDerivation : mixins EnumDerivation --> ElementDerivation : mixins EnumDerivation : name EnumDerivation --> None : name EnumDerivation : overrides EnumDerivation --> Any : overrides EnumDerivation : permissible_value_derivations EnumDerivation --> PermissibleValueDerivation : permissible_value_derivations EnumDerivation : populated_from EnumDerivation : sources EnumDerivation : value_mappings EnumDerivation --> KeyVal : value_mappings Inheritance SpecificationComponent ElementDerivation EnumDerivation Slots Name Cardinality and Range Description Inheritance name 0..1 String Target enum name direct populated_from 0..1 EnumReference Source enum name direct sources 0..* EnumReference direct expr 0..1 String An expression to be evaluated on the source object to derive the target slot direct hide 0..1 Boolean True if this is suppressed direct permissible_value_derivations 0..* PermissibleValueDerivation Instructions on how to derive a set of PVs in the target schema direct copy_directives 0..* CopyDirective ElementDerivation overrides 0..1 Any overrides source schema slots ElementDerivation is_a 0..1 ElementDerivation ElementDerivation mixins 0..* ElementDerivation ElementDerivation value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence ElementDerivation expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions ElementDerivation expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions ElementDerivation mirror_source 0..1 Boolean ElementDerivation description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent Usages used by used in type used TransformationSpecification enum_derivations range EnumDerivation Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:EnumDerivation native linkmltr:EnumDerivation LinkML Source Direct name : EnumDerivation description : A specification of how to derive the value of a target enum from a source enum from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target enum name from_schema : https://w3id.org/linkml/transformer key : true domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true populated_from : name : populated_from description : Source enum name from_schema : https://w3id.org/linkml/transformer domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : EnumReference sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : EnumReference expr : name : expr description : An expression to be evaluated on the source object to derive the target slot. Should be specified using the LinkML expression language. from_schema : https://w3id.org/linkml/transformer domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string hide : name : hide description : True if this is suppressed from_schema : https://w3id.org/linkml/transformer domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean permissible_value_derivations : name : permissible_value_derivations description : Instructions on how to derive a set of PVs in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - EnumDerivation range : PermissibleValueDerivation inlined : true Induced name : EnumDerivation description : A specification of how to derive the value of a target enum from a source enum from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target enum name from_schema : https://w3id.org/linkml/transformer key : true alias : name owner : EnumDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true populated_from : name : populated_from description : Source enum name from_schema : https://w3id.org/linkml/transformer alias : populated_from owner : EnumDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : EnumReference sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true alias : sources owner : EnumDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : EnumReference expr : name : expr description : An expression to be evaluated on the source object to derive the target slot. Should be specified using the LinkML expression language. from_schema : https://w3id.org/linkml/transformer alias : expr owner : EnumDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string hide : name : hide description : True if this is suppressed from_schema : https://w3id.org/linkml/transformer alias : hide owner : EnumDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean permissible_value_derivations : name : permissible_value_derivations description : Instructions on how to derive a set of PVs in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : permissible_value_derivations owner : EnumDerivation domain_of : - EnumDerivation range : PermissibleValueDerivation inlined : true copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : EnumDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : EnumDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : EnumDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : EnumDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : EnumDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : EnumDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : EnumDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : EnumDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : EnumDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : EnumDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : EnumDerivation domain_of : - SpecificationComponent range : string","title":"Class: EnumDerivation"},{"location":"schema/EnumDerivation/#class-enumderivation","text":"A specification of how to derive the value of a target enum from a source enum URI: linkmltr:EnumDerivation classDiagram class EnumDerivation ElementDerivation <|-- EnumDerivation EnumDerivation : comments EnumDerivation : copy_directives EnumDerivation --> CopyDirective : copy_directives EnumDerivation : description EnumDerivation --> None : description EnumDerivation : expr EnumDerivation : expression_to_expression_mappings EnumDerivation --> KeyVal : expression_to_expression_mappings EnumDerivation : expression_to_value_mappings EnumDerivation --> KeyVal : expression_to_value_mappings EnumDerivation : hide EnumDerivation : implements EnumDerivation : is_a EnumDerivation --> ElementDerivation : is_a EnumDerivation : mirror_source EnumDerivation : mixins EnumDerivation --> ElementDerivation : mixins EnumDerivation : name EnumDerivation --> None : name EnumDerivation : overrides EnumDerivation --> Any : overrides EnumDerivation : permissible_value_derivations EnumDerivation --> PermissibleValueDerivation : permissible_value_derivations EnumDerivation : populated_from EnumDerivation : sources EnumDerivation : value_mappings EnumDerivation --> KeyVal : value_mappings","title":"Class: EnumDerivation"},{"location":"schema/EnumDerivation/#inheritance","text":"SpecificationComponent ElementDerivation EnumDerivation","title":"Inheritance"},{"location":"schema/EnumDerivation/#slots","text":"Name Cardinality and Range Description Inheritance name 0..1 String Target enum name direct populated_from 0..1 EnumReference Source enum name direct sources 0..* EnumReference direct expr 0..1 String An expression to be evaluated on the source object to derive the target slot direct hide 0..1 Boolean True if this is suppressed direct permissible_value_derivations 0..* PermissibleValueDerivation Instructions on how to derive a set of PVs in the target schema direct copy_directives 0..* CopyDirective ElementDerivation overrides 0..1 Any overrides source schema slots ElementDerivation is_a 0..1 ElementDerivation ElementDerivation mixins 0..* ElementDerivation ElementDerivation value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence ElementDerivation expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions ElementDerivation expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions ElementDerivation mirror_source 0..1 Boolean ElementDerivation description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent","title":"Slots"},{"location":"schema/EnumDerivation/#usages","text":"used by used in type used TransformationSpecification enum_derivations range EnumDerivation","title":"Usages"},{"location":"schema/EnumDerivation/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/EnumDerivation/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/EnumDerivation/#mappings","text":"Mapping Type Mapped Value self linkmltr:EnumDerivation native linkmltr:EnumDerivation","title":"Mappings"},{"location":"schema/EnumDerivation/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/EnumDerivation/#direct","text":"name : EnumDerivation description : A specification of how to derive the value of a target enum from a source enum from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target enum name from_schema : https://w3id.org/linkml/transformer key : true domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true populated_from : name : populated_from description : Source enum name from_schema : https://w3id.org/linkml/transformer domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : EnumReference sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : EnumReference expr : name : expr description : An expression to be evaluated on the source object to derive the target slot. Should be specified using the LinkML expression language. from_schema : https://w3id.org/linkml/transformer domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string hide : name : hide description : True if this is suppressed from_schema : https://w3id.org/linkml/transformer domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean permissible_value_derivations : name : permissible_value_derivations description : Instructions on how to derive a set of PVs in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - EnumDerivation range : PermissibleValueDerivation inlined : true","title":"Direct"},{"location":"schema/EnumDerivation/#induced","text":"name : EnumDerivation description : A specification of how to derive the value of a target enum from a source enum from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target enum name from_schema : https://w3id.org/linkml/transformer key : true alias : name owner : EnumDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true populated_from : name : populated_from description : Source enum name from_schema : https://w3id.org/linkml/transformer alias : populated_from owner : EnumDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : EnumReference sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true alias : sources owner : EnumDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : EnumReference expr : name : expr description : An expression to be evaluated on the source object to derive the target slot. Should be specified using the LinkML expression language. from_schema : https://w3id.org/linkml/transformer alias : expr owner : EnumDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string hide : name : hide description : True if this is suppressed from_schema : https://w3id.org/linkml/transformer alias : hide owner : EnumDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean permissible_value_derivations : name : permissible_value_derivations description : Instructions on how to derive a set of PVs in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : permissible_value_derivations owner : EnumDerivation domain_of : - EnumDerivation range : PermissibleValueDerivation inlined : true copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : EnumDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : EnumDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : EnumDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : EnumDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : EnumDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : EnumDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : EnumDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : EnumDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : EnumDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : EnumDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : EnumDerivation domain_of : - SpecificationComponent range : string","title":"Induced"},{"location":"schema/EnumReference/","text":"Type: EnumReference URI: xsd:string base : str uri : xsd:string typeof : string Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: EnumReference"},{"location":"schema/EnumReference/#type-enumreference","text":"URI: xsd:string base : str uri : xsd:string typeof : string","title":"Type: EnumReference"},{"location":"schema/EnumReference/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/EnumReference/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Float/","text":"Type: Float A real number that conforms to the xsd:float specification URI: xsd:float base : float uri : xsd:float Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Float"},{"location":"schema/Float/#type-float","text":"A real number that conforms to the xsd:float specification URI: xsd:float base : float uri : xsd:float","title":"Type: Float"},{"location":"schema/Float/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Float/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Integer/","text":"Type: Integer An integer URI: xsd:integer base : int uri : xsd:integer Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Integer"},{"location":"schema/Integer/#type-integer","text":"An integer URI: xsd:integer base : int uri : xsd:integer","title":"Type: Integer"},{"location":"schema/Integer/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Integer/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Inverse/","text":"Class: Inverse Used for back references in mapping to relational model URI: linkmltr:Inverse classDiagram class Inverse Inverse : class_name Inverse --> None : class_name Inverse : slot_name Inverse --> None : slot_name Slots Name Cardinality and Range Description Inheritance slot_name 0..1 String direct class_name 0..1 String direct Usages used by used in type used SlotDerivation inverse_of range Inverse Aliases backref back_references Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:Inverse native linkmltr:Inverse LinkML Source Direct name : Inverse description : Used for back references in mapping to relational model from_schema : https://w3id.org/linkml/transformer aliases : - backref - back_references attributes : slot_name : name : slot_name from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - Inverse class_name : name : class_name from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - Inverse Induced name : Inverse description : Used for back references in mapping to relational model from_schema : https://w3id.org/linkml/transformer aliases : - backref - back_references attributes : slot_name : name : slot_name from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : slot_name owner : Inverse domain_of : - Inverse class_name : name : class_name from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : class_name owner : Inverse domain_of : - Inverse","title":"Class: Inverse"},{"location":"schema/Inverse/#class-inverse","text":"Used for back references in mapping to relational model URI: linkmltr:Inverse classDiagram class Inverse Inverse : class_name Inverse --> None : class_name Inverse : slot_name Inverse --> None : slot_name","title":"Class: Inverse"},{"location":"schema/Inverse/#slots","text":"Name Cardinality and Range Description Inheritance slot_name 0..1 String direct class_name 0..1 String direct","title":"Slots"},{"location":"schema/Inverse/#usages","text":"used by used in type used SlotDerivation inverse_of range Inverse","title":"Usages"},{"location":"schema/Inverse/#aliases","text":"backref back_references","title":"Aliases"},{"location":"schema/Inverse/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Inverse/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Inverse/#mappings","text":"Mapping Type Mapped Value self linkmltr:Inverse native linkmltr:Inverse","title":"Mappings"},{"location":"schema/Inverse/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/Inverse/#direct","text":"name : Inverse description : Used for back references in mapping to relational model from_schema : https://w3id.org/linkml/transformer aliases : - backref - back_references attributes : slot_name : name : slot_name from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - Inverse class_name : name : class_name from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - Inverse","title":"Direct"},{"location":"schema/Inverse/#induced","text":"name : Inverse description : Used for back references in mapping to relational model from_schema : https://w3id.org/linkml/transformer aliases : - backref - back_references attributes : slot_name : name : slot_name from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : slot_name owner : Inverse domain_of : - Inverse class_name : name : class_name from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : class_name owner : Inverse domain_of : - Inverse","title":"Induced"},{"location":"schema/Jsonpath/","text":"Type: Jsonpath A string encoding a JSON Path. The value of the string MUST conform to JSON Point syntax and SHOULD dereference to zero or more valid objects within the current instance document when encoded in tree form. URI: xsd:string base : str uri : xsd:string repr : str Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Jsonpath"},{"location":"schema/Jsonpath/#type-jsonpath","text":"A string encoding a JSON Path. The value of the string MUST conform to JSON Point syntax and SHOULD dereference to zero or more valid objects within the current instance document when encoded in tree form. URI: xsd:string base : str uri : xsd:string repr : str","title":"Type: Jsonpath"},{"location":"schema/Jsonpath/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Jsonpath/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Jsonpointer/","text":"Type: Jsonpointer A string encoding a JSON Pointer. The value of the string MUST conform to JSON Point syntax and SHOULD dereference to a valid object within the current instance document when encoded in tree form. URI: xsd:string base : str uri : xsd:string repr : str Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Jsonpointer"},{"location":"schema/Jsonpointer/#type-jsonpointer","text":"A string encoding a JSON Pointer. The value of the string MUST conform to JSON Point syntax and SHOULD dereference to a valid object within the current instance document when encoded in tree form. URI: xsd:string base : str uri : xsd:string repr : str","title":"Type: Jsonpointer"},{"location":"schema/Jsonpointer/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Jsonpointer/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/KeyVal/","text":"Class: KeyVal URI: linkmltr:KeyVal classDiagram class KeyVal KeyVal : key KeyVal --> None : key KeyVal : value KeyVal --> Any : value Slots Name Cardinality and Range Description Inheritance key 0..1 String direct value 0..1 Any direct Usages used by used in type used TransformationSpecification prefixes range KeyVal ElementDerivation value_mappings range KeyVal ElementDerivation expression_to_value_mappings range KeyVal ElementDerivation expression_to_expression_mappings range KeyVal ClassDerivation value_mappings range KeyVal ClassDerivation expression_to_value_mappings range KeyVal ClassDerivation expression_to_expression_mappings range KeyVal SlotDerivation value_mappings range KeyVal SlotDerivation expression_to_value_mappings range KeyVal SlotDerivation expression_to_expression_mappings range KeyVal EnumDerivation value_mappings range KeyVal EnumDerivation expression_to_value_mappings range KeyVal EnumDerivation expression_to_expression_mappings range KeyVal PermissibleValueDerivation value_mappings range KeyVal PermissibleValueDerivation expression_to_value_mappings range KeyVal PermissibleValueDerivation expression_to_expression_mappings range KeyVal PrefixDerivation value_mappings range KeyVal PrefixDerivation expression_to_value_mappings range KeyVal PrefixDerivation expression_to_expression_mappings range KeyVal Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:KeyVal native linkmltr:KeyVal LinkML Source Direct name : KeyVal from_schema : https://w3id.org/linkml/transformer attributes : key : name : key from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true domain_of : - KeyVal required : true value : name : value from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - KeyVal range : Any Induced name : KeyVal from_schema : https://w3id.org/linkml/transformer attributes : key : name : key from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : key owner : KeyVal domain_of : - KeyVal required : true value : name : value from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : value owner : KeyVal domain_of : - KeyVal range : Any","title":"Class: KeyVal"},{"location":"schema/KeyVal/#class-keyval","text":"URI: linkmltr:KeyVal classDiagram class KeyVal KeyVal : key KeyVal --> None : key KeyVal : value KeyVal --> Any : value","title":"Class: KeyVal"},{"location":"schema/KeyVal/#slots","text":"Name Cardinality and Range Description Inheritance key 0..1 String direct value 0..1 Any direct","title":"Slots"},{"location":"schema/KeyVal/#usages","text":"used by used in type used TransformationSpecification prefixes range KeyVal ElementDerivation value_mappings range KeyVal ElementDerivation expression_to_value_mappings range KeyVal ElementDerivation expression_to_expression_mappings range KeyVal ClassDerivation value_mappings range KeyVal ClassDerivation expression_to_value_mappings range KeyVal ClassDerivation expression_to_expression_mappings range KeyVal SlotDerivation value_mappings range KeyVal SlotDerivation expression_to_value_mappings range KeyVal SlotDerivation expression_to_expression_mappings range KeyVal EnumDerivation value_mappings range KeyVal EnumDerivation expression_to_value_mappings range KeyVal EnumDerivation expression_to_expression_mappings range KeyVal PermissibleValueDerivation value_mappings range KeyVal PermissibleValueDerivation expression_to_value_mappings range KeyVal PermissibleValueDerivation expression_to_expression_mappings range KeyVal PrefixDerivation value_mappings range KeyVal PrefixDerivation expression_to_value_mappings range KeyVal PrefixDerivation expression_to_expression_mappings range KeyVal","title":"Usages"},{"location":"schema/KeyVal/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/KeyVal/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/KeyVal/#mappings","text":"Mapping Type Mapped Value self linkmltr:KeyVal native linkmltr:KeyVal","title":"Mappings"},{"location":"schema/KeyVal/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/KeyVal/#direct","text":"name : KeyVal from_schema : https://w3id.org/linkml/transformer attributes : key : name : key from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true domain_of : - KeyVal required : true value : name : value from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - KeyVal range : Any","title":"Direct"},{"location":"schema/KeyVal/#induced","text":"name : KeyVal from_schema : https://w3id.org/linkml/transformer attributes : key : name : key from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : key owner : KeyVal domain_of : - KeyVal required : true value : name : value from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : value owner : KeyVal domain_of : - KeyVal range : Any","title":"Induced"},{"location":"schema/Ncname/","text":"Type: Ncname Prefix part of CURIE URI: xsd:string base : NCName uri : xsd:string repr : str Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Ncname"},{"location":"schema/Ncname/#type-ncname","text":"Prefix part of CURIE URI: xsd:string base : NCName uri : xsd:string repr : str","title":"Type: Ncname"},{"location":"schema/Ncname/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Ncname/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Nodeidentifier/","text":"Type: Nodeidentifier A URI, CURIE or BNODE that represents a node in a model. URI: shex:nonLiteral base : NodeIdentifier uri : shex:nonLiteral repr : str Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Nodeidentifier"},{"location":"schema/Nodeidentifier/#type-nodeidentifier","text":"A URI, CURIE or BNODE that represents a node in a model. URI: shex:nonLiteral base : NodeIdentifier uri : shex:nonLiteral repr : str","title":"Type: Nodeidentifier"},{"location":"schema/Nodeidentifier/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Nodeidentifier/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Objectidentifier/","text":"Type: Objectidentifier A URI or CURIE that represents an object in the model. URI: shex:iri base : ElementIdentifier uri : shex:iri repr : str Comments Used for inheritance and type checking Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Objectidentifier"},{"location":"schema/Objectidentifier/#type-objectidentifier","text":"A URI or CURIE that represents an object in the model. URI: shex:iri base : ElementIdentifier uri : shex:iri repr : str","title":"Type: Objectidentifier"},{"location":"schema/Objectidentifier/#comments","text":"Used for inheritance and type checking","title":"Comments"},{"location":"schema/Objectidentifier/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Objectidentifier/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/PermissibleValueDerivation/","text":"Class: PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum URI: linkmltr:PermissibleValueDerivation classDiagram class PermissibleValueDerivation ElementDerivation <|-- PermissibleValueDerivation PermissibleValueDerivation : comments PermissibleValueDerivation : copy_directives PermissibleValueDerivation --> CopyDirective : copy_directives PermissibleValueDerivation : description PermissibleValueDerivation --> None : description PermissibleValueDerivation : expr PermissibleValueDerivation : expression_to_expression_mappings PermissibleValueDerivation --> KeyVal : expression_to_expression_mappings PermissibleValueDerivation : expression_to_value_mappings PermissibleValueDerivation --> KeyVal : expression_to_value_mappings PermissibleValueDerivation : hide PermissibleValueDerivation : implements PermissibleValueDerivation : is_a PermissibleValueDerivation --> ElementDerivation : is_a PermissibleValueDerivation : mirror_source PermissibleValueDerivation : mixins PermissibleValueDerivation --> ElementDerivation : mixins PermissibleValueDerivation : name PermissibleValueDerivation --> None : name PermissibleValueDerivation : overrides PermissibleValueDerivation --> Any : overrides PermissibleValueDerivation : populated_from PermissibleValueDerivation : sources PermissibleValueDerivation : value_mappings PermissibleValueDerivation --> KeyVal : value_mappings Inheritance SpecificationComponent ElementDerivation PermissibleValueDerivation Slots Name Cardinality and Range Description Inheritance name 0..1 String Target permissible value text direct expr 0..1 String direct populated_from 0..1 String Source permissible value direct sources 0..* String direct hide 0..1 Boolean direct copy_directives 0..* CopyDirective ElementDerivation overrides 0..1 Any overrides source schema slots ElementDerivation is_a 0..1 ElementDerivation ElementDerivation mixins 0..* ElementDerivation ElementDerivation value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence ElementDerivation expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions ElementDerivation expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions ElementDerivation mirror_source 0..1 Boolean ElementDerivation description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent Usages used by used in type used EnumDerivation permissible_value_derivations range PermissibleValueDerivation TODOs this is currently under-specified. We will need boolean combinators to express if-then-else Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:PermissibleValueDerivation native linkmltr:PermissibleValueDerivation LinkML Source Direct name : PermissibleValueDerivation description : A specification of how to derive the value of a PV from a source enum todos : - this is currently under-specified. We will need boolean combinators to express if-then-else from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target permissible value text from_schema : https://w3id.org/linkml/transformer key : true domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true expr : name : expr from_schema : https://w3id.org/linkml/transformer domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string populated_from : name : populated_from description : Source permissible value from_schema : https://w3id.org/linkml/transformer domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string hide : name : hide from_schema : https://w3id.org/linkml/transformer domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean Induced name : PermissibleValueDerivation description : A specification of how to derive the value of a PV from a source enum todos : - this is currently under-specified. We will need boolean combinators to express if-then-else from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target permissible value text from_schema : https://w3id.org/linkml/transformer key : true alias : name owner : PermissibleValueDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true expr : name : expr from_schema : https://w3id.org/linkml/transformer alias : expr owner : PermissibleValueDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string populated_from : name : populated_from description : Source permissible value from_schema : https://w3id.org/linkml/transformer alias : populated_from owner : PermissibleValueDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true alias : sources owner : PermissibleValueDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string hide : name : hide from_schema : https://w3id.org/linkml/transformer alias : hide owner : PermissibleValueDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : PermissibleValueDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : PermissibleValueDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : PermissibleValueDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : PermissibleValueDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : PermissibleValueDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : PermissibleValueDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : PermissibleValueDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : PermissibleValueDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : PermissibleValueDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : PermissibleValueDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : PermissibleValueDerivation domain_of : - SpecificationComponent range : string","title":"Class: PermissibleValueDerivation"},{"location":"schema/PermissibleValueDerivation/#class-permissiblevaluederivation","text":"A specification of how to derive the value of a PV from a source enum URI: linkmltr:PermissibleValueDerivation classDiagram class PermissibleValueDerivation ElementDerivation <|-- PermissibleValueDerivation PermissibleValueDerivation : comments PermissibleValueDerivation : copy_directives PermissibleValueDerivation --> CopyDirective : copy_directives PermissibleValueDerivation : description PermissibleValueDerivation --> None : description PermissibleValueDerivation : expr PermissibleValueDerivation : expression_to_expression_mappings PermissibleValueDerivation --> KeyVal : expression_to_expression_mappings PermissibleValueDerivation : expression_to_value_mappings PermissibleValueDerivation --> KeyVal : expression_to_value_mappings PermissibleValueDerivation : hide PermissibleValueDerivation : implements PermissibleValueDerivation : is_a PermissibleValueDerivation --> ElementDerivation : is_a PermissibleValueDerivation : mirror_source PermissibleValueDerivation : mixins PermissibleValueDerivation --> ElementDerivation : mixins PermissibleValueDerivation : name PermissibleValueDerivation --> None : name PermissibleValueDerivation : overrides PermissibleValueDerivation --> Any : overrides PermissibleValueDerivation : populated_from PermissibleValueDerivation : sources PermissibleValueDerivation : value_mappings PermissibleValueDerivation --> KeyVal : value_mappings","title":"Class: PermissibleValueDerivation"},{"location":"schema/PermissibleValueDerivation/#inheritance","text":"SpecificationComponent ElementDerivation PermissibleValueDerivation","title":"Inheritance"},{"location":"schema/PermissibleValueDerivation/#slots","text":"Name Cardinality and Range Description Inheritance name 0..1 String Target permissible value text direct expr 0..1 String direct populated_from 0..1 String Source permissible value direct sources 0..* String direct hide 0..1 Boolean direct copy_directives 0..* CopyDirective ElementDerivation overrides 0..1 Any overrides source schema slots ElementDerivation is_a 0..1 ElementDerivation ElementDerivation mixins 0..* ElementDerivation ElementDerivation value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence ElementDerivation expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions ElementDerivation expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions ElementDerivation mirror_source 0..1 Boolean ElementDerivation description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent","title":"Slots"},{"location":"schema/PermissibleValueDerivation/#usages","text":"used by used in type used EnumDerivation permissible_value_derivations range PermissibleValueDerivation","title":"Usages"},{"location":"schema/PermissibleValueDerivation/#todos","text":"this is currently under-specified. We will need boolean combinators to express if-then-else","title":"TODOs"},{"location":"schema/PermissibleValueDerivation/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/PermissibleValueDerivation/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/PermissibleValueDerivation/#mappings","text":"Mapping Type Mapped Value self linkmltr:PermissibleValueDerivation native linkmltr:PermissibleValueDerivation","title":"Mappings"},{"location":"schema/PermissibleValueDerivation/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/PermissibleValueDerivation/#direct","text":"name : PermissibleValueDerivation description : A specification of how to derive the value of a PV from a source enum todos : - this is currently under-specified. We will need boolean combinators to express if-then-else from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target permissible value text from_schema : https://w3id.org/linkml/transformer key : true domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true expr : name : expr from_schema : https://w3id.org/linkml/transformer domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string populated_from : name : populated_from description : Source permissible value from_schema : https://w3id.org/linkml/transformer domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string hide : name : hide from_schema : https://w3id.org/linkml/transformer domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean","title":"Direct"},{"location":"schema/PermissibleValueDerivation/#induced","text":"name : PermissibleValueDerivation description : A specification of how to derive the value of a PV from a source enum todos : - this is currently under-specified. We will need boolean combinators to express if-then-else from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target permissible value text from_schema : https://w3id.org/linkml/transformer key : true alias : name owner : PermissibleValueDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true expr : name : expr from_schema : https://w3id.org/linkml/transformer alias : expr owner : PermissibleValueDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string populated_from : name : populated_from description : Source permissible value from_schema : https://w3id.org/linkml/transformer alias : populated_from owner : PermissibleValueDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true alias : sources owner : PermissibleValueDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string hide : name : hide from_schema : https://w3id.org/linkml/transformer alias : hide owner : PermissibleValueDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : PermissibleValueDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : PermissibleValueDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : PermissibleValueDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : PermissibleValueDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : PermissibleValueDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : PermissibleValueDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : PermissibleValueDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : PermissibleValueDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : PermissibleValueDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : PermissibleValueDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : PermissibleValueDerivation domain_of : - SpecificationComponent range : string","title":"Induced"},{"location":"schema/PrefixDerivation/","text":"Class: PrefixDerivation URI: linkmltr:PrefixDerivation classDiagram class PrefixDerivation ElementDerivation <|-- PrefixDerivation PrefixDerivation : comments PrefixDerivation : copy_directives PrefixDerivation --> CopyDirective : copy_directives PrefixDerivation : description PrefixDerivation --> None : description PrefixDerivation : expression_to_expression_mappings PrefixDerivation --> KeyVal : expression_to_expression_mappings PrefixDerivation : expression_to_value_mappings PrefixDerivation --> KeyVal : expression_to_value_mappings PrefixDerivation : implements PrefixDerivation : is_a PrefixDerivation --> ElementDerivation : is_a PrefixDerivation : mirror_source PrefixDerivation : mixins PrefixDerivation --> ElementDerivation : mixins PrefixDerivation : name PrefixDerivation --> None : name PrefixDerivation : overrides PrefixDerivation --> Any : overrides PrefixDerivation : value_mappings PrefixDerivation --> KeyVal : value_mappings Inheritance SpecificationComponent ElementDerivation PrefixDerivation Slots Name Cardinality and Range Description Inheritance name 1..1 String Name of the element in the target schema ElementDerivation copy_directives 0..* CopyDirective ElementDerivation overrides 0..1 Any overrides source schema slots ElementDerivation is_a 0..1 ElementDerivation ElementDerivation mixins 0..* ElementDerivation ElementDerivation value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence ElementDerivation expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions ElementDerivation expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions ElementDerivation mirror_source 0..1 Boolean ElementDerivation description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:PrefixDerivation native linkmltr:PrefixDerivation LinkML Source Direct name : PrefixDerivation from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation Induced name : PrefixDerivation from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Name of the element in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : name owner : PrefixDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string required : true copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : PrefixDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : PrefixDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : PrefixDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : PrefixDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : PrefixDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : PrefixDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : PrefixDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : PrefixDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : PrefixDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : PrefixDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : PrefixDerivation domain_of : - SpecificationComponent range : string","title":"Class: PrefixDerivation"},{"location":"schema/PrefixDerivation/#class-prefixderivation","text":"URI: linkmltr:PrefixDerivation classDiagram class PrefixDerivation ElementDerivation <|-- PrefixDerivation PrefixDerivation : comments PrefixDerivation : copy_directives PrefixDerivation --> CopyDirective : copy_directives PrefixDerivation : description PrefixDerivation --> None : description PrefixDerivation : expression_to_expression_mappings PrefixDerivation --> KeyVal : expression_to_expression_mappings PrefixDerivation : expression_to_value_mappings PrefixDerivation --> KeyVal : expression_to_value_mappings PrefixDerivation : implements PrefixDerivation : is_a PrefixDerivation --> ElementDerivation : is_a PrefixDerivation : mirror_source PrefixDerivation : mixins PrefixDerivation --> ElementDerivation : mixins PrefixDerivation : name PrefixDerivation --> None : name PrefixDerivation : overrides PrefixDerivation --> Any : overrides PrefixDerivation : value_mappings PrefixDerivation --> KeyVal : value_mappings","title":"Class: PrefixDerivation"},{"location":"schema/PrefixDerivation/#inheritance","text":"SpecificationComponent ElementDerivation PrefixDerivation","title":"Inheritance"},{"location":"schema/PrefixDerivation/#slots","text":"Name Cardinality and Range Description Inheritance name 1..1 String Name of the element in the target schema ElementDerivation copy_directives 0..* CopyDirective ElementDerivation overrides 0..1 Any overrides source schema slots ElementDerivation is_a 0..1 ElementDerivation ElementDerivation mixins 0..* ElementDerivation ElementDerivation value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence ElementDerivation expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions ElementDerivation expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions ElementDerivation mirror_source 0..1 Boolean ElementDerivation description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent","title":"Slots"},{"location":"schema/PrefixDerivation/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/PrefixDerivation/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/PrefixDerivation/#mappings","text":"Mapping Type Mapped Value self linkmltr:PrefixDerivation native linkmltr:PrefixDerivation","title":"Mappings"},{"location":"schema/PrefixDerivation/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/PrefixDerivation/#direct","text":"name : PrefixDerivation from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation","title":"Direct"},{"location":"schema/PrefixDerivation/#induced","text":"name : PrefixDerivation from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Name of the element in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : name owner : PrefixDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string required : true copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : PrefixDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : PrefixDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : PrefixDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : PrefixDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : PrefixDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : PrefixDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : PrefixDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : PrefixDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : PrefixDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : PrefixDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : PrefixDerivation domain_of : - SpecificationComponent range : string","title":"Induced"},{"location":"schema/SerializationSyntaxType/","text":"Enum: SerializationSyntaxType URI: SerializationSyntaxType Permissible Values Value Meaning Description JSON None YAML None TURTLE None Slots Name Description syntax Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : SerializationSyntaxType from_schema : https://w3id.org/linkml/transformer rank : 1000 permissible_values : JSON : text : JSON YAML : text : YAML TURTLE : text : TURTLE","title":"Enum: SerializationSyntaxType"},{"location":"schema/SerializationSyntaxType/#enum-serializationsyntaxtype","text":"URI: SerializationSyntaxType","title":"Enum: SerializationSyntaxType"},{"location":"schema/SerializationSyntaxType/#permissible-values","text":"Value Meaning Description JSON None YAML None TURTLE None","title":"Permissible Values"},{"location":"schema/SerializationSyntaxType/#slots","text":"Name Description syntax","title":"Slots"},{"location":"schema/SerializationSyntaxType/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/SerializationSyntaxType/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/SerializationSyntaxType/#linkml-source","text":"name : SerializationSyntaxType from_schema : https://w3id.org/linkml/transformer rank : 1000 permissible_values : JSON : text : JSON YAML : text : YAML TURTLE : text : TURTLE","title":"LinkML Source"},{"location":"schema/SlotDerivation/","text":"Class: SlotDerivation A specification of how to derive the value of a target slot from a source slot URI: linkmltr:SlotDerivation classDiagram class SlotDerivation ElementDerivation <|-- SlotDerivation SlotDerivation : cast_collection_as SlotDerivation --> CollectionType : cast_collection_as SlotDerivation : comments SlotDerivation : copy_directives SlotDerivation --> CopyDirective : copy_directives SlotDerivation : derived_from SlotDerivation : description SlotDerivation --> None : description SlotDerivation : dictionary_key SlotDerivation : expr SlotDerivation : expression_to_expression_mappings SlotDerivation --> KeyVal : expression_to_expression_mappings SlotDerivation : expression_to_value_mappings SlotDerivation --> KeyVal : expression_to_value_mappings SlotDerivation : hide SlotDerivation : implements SlotDerivation : inverse_of SlotDerivation --> Inverse : inverse_of SlotDerivation : is_a SlotDerivation --> ElementDerivation : is_a SlotDerivation : mirror_source SlotDerivation : mixins SlotDerivation --> ElementDerivation : mixins SlotDerivation : name SlotDerivation --> None : name SlotDerivation : overrides SlotDerivation --> Any : overrides SlotDerivation : populated_from SlotDerivation : range SlotDerivation : sources SlotDerivation : stringification SlotDerivation --> StringificationConfiguration : stringification SlotDerivation : type_designator SlotDerivation : unit_conversion SlotDerivation --> UnitConversionConfiguration : unit_conversion SlotDerivation : value_mappings SlotDerivation --> KeyVal : value_mappings Inheritance SpecificationComponent ElementDerivation SlotDerivation Slots Name Cardinality and Range Description Inheritance name 0..1 String Target slot name direct populated_from 0..1 SlotReference Source slot name direct sources 0..* SlotReference direct derived_from 0..* SlotReference Source slots that are used to derive this slot direct expr 0..1 String An expression to be evaluated on the source object to derive the target slot direct range 0..1 String direct unit_conversion 0..1 UnitConversionConfiguration direct inverse_of 0..1 Inverse Used to specify a class-slot tuple that is the inverse of the derived/target ... direct hide 0..1 Boolean True if this is suppressed direct type_designator 0..1 Boolean direct cast_collection_as 0..1 CollectionType direct dictionary_key 0..1 String direct stringification 0..1 StringificationConfiguration direct copy_directives 0..* CopyDirective ElementDerivation overrides 0..1 Any overrides source schema slots ElementDerivation is_a 0..1 ElementDerivation ElementDerivation mixins 0..* ElementDerivation ElementDerivation value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence ElementDerivation expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions ElementDerivation expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions ElementDerivation mirror_source 0..1 Boolean ElementDerivation description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent Usages used by used in type used TransformationSpecification slot_derivations range SlotDerivation ClassDerivation slot_derivations range SlotDerivation Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:SlotDerivation native linkmltr:SlotDerivation LinkML Source Direct name : SlotDerivation description : A specification of how to derive the value of a target slot from a source slot from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target slot name from_schema : https://w3id.org/linkml/transformer key : true domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true populated_from : name : populated_from description : Source slot name from_schema : https://w3id.org/linkml/transformer domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : SlotReference sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : SlotReference derived_from : name : derived_from description : Source slots that are used to derive this slot. This can be computed from the expr, if the expr is declarative. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - SlotDerivation range : SlotReference expr : name : expr description : An expression to be evaluated on the source object to derive the target slot. Should be specified using the LinkML expression language. from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string range : name : range from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:range domain_of : - SlotDerivation range : string unit_conversion : name : unit_conversion from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : UnitConversionConfiguration inverse_of : name : inverse_of description : Used to specify a class-slot tuple that is the inverse of the derived/target slot. This is used primarily for mapping to relational databases or formalisms that do not allow multiple values. The class representing the repeated element has a foreign key slot inserted in that 'back references' the original multivalued slot. from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : Inverse hide : name : hide description : True if this is suppressed from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean type_designator : name : type_designator from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : boolean cast_collection_as : name : cast_collection_as from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : CollectionType dictionary_key : name : dictionary_key from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : string stringification : name : stringification from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : StringificationConfiguration Induced name : SlotDerivation description : A specification of how to derive the value of a target slot from a source slot from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target slot name from_schema : https://w3id.org/linkml/transformer key : true alias : name owner : SlotDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true populated_from : name : populated_from description : Source slot name from_schema : https://w3id.org/linkml/transformer alias : populated_from owner : SlotDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : SlotReference sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true alias : sources owner : SlotDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : SlotReference derived_from : name : derived_from description : Source slots that are used to derive this slot. This can be computed from the expr, if the expr is declarative. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : derived_from owner : SlotDerivation domain_of : - SlotDerivation range : SlotReference expr : name : expr description : An expression to be evaluated on the source object to derive the target slot. Should be specified using the LinkML expression language. from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : expr owner : SlotDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string range : name : range from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:range alias : range owner : SlotDerivation domain_of : - SlotDerivation range : string unit_conversion : name : unit_conversion from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : unit_conversion owner : SlotDerivation domain_of : - SlotDerivation range : UnitConversionConfiguration inverse_of : name : inverse_of description : Used to specify a class-slot tuple that is the inverse of the derived/target slot. This is used primarily for mapping to relational databases or formalisms that do not allow multiple values. The class representing the repeated element has a foreign key slot inserted in that 'back references' the original multivalued slot. from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : inverse_of owner : SlotDerivation domain_of : - SlotDerivation range : Inverse hide : name : hide description : True if this is suppressed from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : hide owner : SlotDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean type_designator : name : type_designator from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : type_designator owner : SlotDerivation domain_of : - SlotDerivation range : boolean cast_collection_as : name : cast_collection_as from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : cast_collection_as owner : SlotDerivation domain_of : - SlotDerivation range : CollectionType dictionary_key : name : dictionary_key from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : dictionary_key owner : SlotDerivation domain_of : - SlotDerivation range : string stringification : name : stringification from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : stringification owner : SlotDerivation domain_of : - SlotDerivation range : StringificationConfiguration copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : SlotDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : SlotDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : SlotDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : SlotDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : SlotDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : SlotDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : SlotDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : SlotDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : SlotDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : SlotDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : SlotDerivation domain_of : - SpecificationComponent range : string","title":"Class: SlotDerivation"},{"location":"schema/SlotDerivation/#class-slotderivation","text":"A specification of how to derive the value of a target slot from a source slot URI: linkmltr:SlotDerivation classDiagram class SlotDerivation ElementDerivation <|-- SlotDerivation SlotDerivation : cast_collection_as SlotDerivation --> CollectionType : cast_collection_as SlotDerivation : comments SlotDerivation : copy_directives SlotDerivation --> CopyDirective : copy_directives SlotDerivation : derived_from SlotDerivation : description SlotDerivation --> None : description SlotDerivation : dictionary_key SlotDerivation : expr SlotDerivation : expression_to_expression_mappings SlotDerivation --> KeyVal : expression_to_expression_mappings SlotDerivation : expression_to_value_mappings SlotDerivation --> KeyVal : expression_to_value_mappings SlotDerivation : hide SlotDerivation : implements SlotDerivation : inverse_of SlotDerivation --> Inverse : inverse_of SlotDerivation : is_a SlotDerivation --> ElementDerivation : is_a SlotDerivation : mirror_source SlotDerivation : mixins SlotDerivation --> ElementDerivation : mixins SlotDerivation : name SlotDerivation --> None : name SlotDerivation : overrides SlotDerivation --> Any : overrides SlotDerivation : populated_from SlotDerivation : range SlotDerivation : sources SlotDerivation : stringification SlotDerivation --> StringificationConfiguration : stringification SlotDerivation : type_designator SlotDerivation : unit_conversion SlotDerivation --> UnitConversionConfiguration : unit_conversion SlotDerivation : value_mappings SlotDerivation --> KeyVal : value_mappings","title":"Class: SlotDerivation"},{"location":"schema/SlotDerivation/#inheritance","text":"SpecificationComponent ElementDerivation SlotDerivation","title":"Inheritance"},{"location":"schema/SlotDerivation/#slots","text":"Name Cardinality and Range Description Inheritance name 0..1 String Target slot name direct populated_from 0..1 SlotReference Source slot name direct sources 0..* SlotReference direct derived_from 0..* SlotReference Source slots that are used to derive this slot direct expr 0..1 String An expression to be evaluated on the source object to derive the target slot direct range 0..1 String direct unit_conversion 0..1 UnitConversionConfiguration direct inverse_of 0..1 Inverse Used to specify a class-slot tuple that is the inverse of the derived/target ... direct hide 0..1 Boolean True if this is suppressed direct type_designator 0..1 Boolean direct cast_collection_as 0..1 CollectionType direct dictionary_key 0..1 String direct stringification 0..1 StringificationConfiguration direct copy_directives 0..* CopyDirective ElementDerivation overrides 0..1 Any overrides source schema slots ElementDerivation is_a 0..1 ElementDerivation ElementDerivation mixins 0..* ElementDerivation ElementDerivation value_mappings 0..* KeyVal A mapping table that is applied directly to mappings, in order of precedence ElementDerivation expression_to_value_mappings 0..* KeyVal A mapping table in which the keys are expressions ElementDerivation expression_to_expression_mappings 0..* KeyVal A mapping table in which the keys and values are expressions ElementDerivation mirror_source 0..1 Boolean ElementDerivation description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent","title":"Slots"},{"location":"schema/SlotDerivation/#usages","text":"used by used in type used TransformationSpecification slot_derivations range SlotDerivation ClassDerivation slot_derivations range SlotDerivation","title":"Usages"},{"location":"schema/SlotDerivation/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/SlotDerivation/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/SlotDerivation/#mappings","text":"Mapping Type Mapped Value self linkmltr:SlotDerivation native linkmltr:SlotDerivation","title":"Mappings"},{"location":"schema/SlotDerivation/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/SlotDerivation/#direct","text":"name : SlotDerivation description : A specification of how to derive the value of a target slot from a source slot from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target slot name from_schema : https://w3id.org/linkml/transformer key : true domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true populated_from : name : populated_from description : Source slot name from_schema : https://w3id.org/linkml/transformer domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : SlotReference sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : SlotReference derived_from : name : derived_from description : Source slots that are used to derive this slot. This can be computed from the expr, if the expr is declarative. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - SlotDerivation range : SlotReference expr : name : expr description : An expression to be evaluated on the source object to derive the target slot. Should be specified using the LinkML expression language. from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string range : name : range from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:range domain_of : - SlotDerivation range : string unit_conversion : name : unit_conversion from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : UnitConversionConfiguration inverse_of : name : inverse_of description : Used to specify a class-slot tuple that is the inverse of the derived/target slot. This is used primarily for mapping to relational databases or formalisms that do not allow multiple values. The class representing the repeated element has a foreign key slot inserted in that 'back references' the original multivalued slot. from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : Inverse hide : name : hide description : True if this is suppressed from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean type_designator : name : type_designator from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : boolean cast_collection_as : name : cast_collection_as from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : CollectionType dictionary_key : name : dictionary_key from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : string stringification : name : stringification from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - SlotDerivation range : StringificationConfiguration","title":"Direct"},{"location":"schema/SlotDerivation/#induced","text":"name : SlotDerivation description : A specification of how to derive the value of a target slot from a source slot from_schema : https://w3id.org/linkml/transformer is_a : ElementDerivation attributes : name : name : name description : Target slot name from_schema : https://w3id.org/linkml/transformer key : true alias : name owner : SlotDerivation domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation required : true populated_from : name : populated_from description : Source slot name from_schema : https://w3id.org/linkml/transformer alias : populated_from owner : SlotDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : SlotReference sources : name : sources from_schema : https://w3id.org/linkml/transformer multivalued : true alias : sources owner : SlotDerivation domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : SlotReference derived_from : name : derived_from description : Source slots that are used to derive this slot. This can be computed from the expr, if the expr is declarative. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : derived_from owner : SlotDerivation domain_of : - SlotDerivation range : SlotReference expr : name : expr description : An expression to be evaluated on the source object to derive the target slot. Should be specified using the LinkML expression language. from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : expr owner : SlotDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : string range : name : range from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:range alias : range owner : SlotDerivation domain_of : - SlotDerivation range : string unit_conversion : name : unit_conversion from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : unit_conversion owner : SlotDerivation domain_of : - SlotDerivation range : UnitConversionConfiguration inverse_of : name : inverse_of description : Used to specify a class-slot tuple that is the inverse of the derived/target slot. This is used primarily for mapping to relational databases or formalisms that do not allow multiple values. The class representing the repeated element has a foreign key slot inserted in that 'back references' the original multivalued slot. from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : inverse_of owner : SlotDerivation domain_of : - SlotDerivation range : Inverse hide : name : hide description : True if this is suppressed from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : hide owner : SlotDerivation domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation range : boolean type_designator : name : type_designator from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : type_designator owner : SlotDerivation domain_of : - SlotDerivation range : boolean cast_collection_as : name : cast_collection_as from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : cast_collection_as owner : SlotDerivation domain_of : - SlotDerivation range : CollectionType dictionary_key : name : dictionary_key from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : dictionary_key owner : SlotDerivation domain_of : - SlotDerivation range : string stringification : name : stringification from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : stringification owner : SlotDerivation domain_of : - SlotDerivation range : StringificationConfiguration copy_directives : name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : SlotDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true overrides : name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : SlotDerivation domain_of : - ElementDerivation range : Any is_a : name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : SlotDerivation domain_of : - ElementDerivation range : ElementDerivation mixins : name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : SlotDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false value_mappings : name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : SlotDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_value_mappings : name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : SlotDerivation domain_of : - ElementDerivation range : KeyVal inlined : true expression_to_expression_mappings : name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : SlotDerivation domain_of : - ElementDerivation range : KeyVal inlined : true mirror_source : name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : SlotDerivation domain_of : - ElementDerivation range : boolean description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : SlotDerivation domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : SlotDerivation domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : SlotDerivation domain_of : - SpecificationComponent range : string","title":"Induced"},{"location":"schema/SlotReference/","text":"Type: SlotReference URI: xsd:string base : str uri : xsd:string typeof : string Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: SlotReference"},{"location":"schema/SlotReference/#type-slotreference","text":"URI: xsd:string base : str uri : xsd:string typeof : string","title":"Type: SlotReference"},{"location":"schema/SlotReference/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/SlotReference/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Sparqlpath/","text":"Type: Sparqlpath A string encoding a SPARQL Property Path. The value of the string MUST conform to SPARQL syntax and SHOULD dereference to zero or more valid objects within the current instance document when encoded as RDF. URI: xsd:string base : str uri : xsd:string repr : str Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Sparqlpath"},{"location":"schema/Sparqlpath/#type-sparqlpath","text":"A string encoding a SPARQL Property Path. The value of the string MUST conform to SPARQL syntax and SHOULD dereference to zero or more valid objects within the current instance document when encoded as RDF. URI: xsd:string base : str uri : xsd:string repr : str","title":"Type: Sparqlpath"},{"location":"schema/Sparqlpath/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Sparqlpath/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/SpecificationComponent/","text":"Class: SpecificationComponent NOTE : this is an abstract class and should not be instantiated directly URI: linkmltr:SpecificationComponent classDiagram class SpecificationComponent SpecificationComponent <|-- TransformationSpecification SpecificationComponent <|-- ElementDerivation SpecificationComponent : comments SpecificationComponent : description SpecificationComponent --> None : description SpecificationComponent : implements Inheritance SpecificationComponent TransformationSpecification ElementDerivation Slots Name Cardinality and Range Description Inheritance description 0..1 String description of the specification component direct implements 0..* Uriorcurie A reference to a specification that this component implements direct comments 0..* String A list of comments about this component direct Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:SpecificationComponent native linkmltr:SpecificationComponent LinkML Source Direct name : SpecificationComponent from_schema : https://w3id.org/linkml/transformer abstract : true attributes : description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description domain_of : - SpecificationComponent implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true domain_of : - SpecificationComponent range : string Induced name : SpecificationComponent from_schema : https://w3id.org/linkml/transformer abstract : true attributes : description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : SpecificationComponent domain_of : - SpecificationComponent implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : SpecificationComponent domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : SpecificationComponent domain_of : - SpecificationComponent range : string","title":"Class: SpecificationComponent"},{"location":"schema/SpecificationComponent/#class-specificationcomponent","text":"NOTE : this is an abstract class and should not be instantiated directly URI: linkmltr:SpecificationComponent classDiagram class SpecificationComponent SpecificationComponent <|-- TransformationSpecification SpecificationComponent <|-- ElementDerivation SpecificationComponent : comments SpecificationComponent : description SpecificationComponent --> None : description SpecificationComponent : implements","title":"Class: SpecificationComponent"},{"location":"schema/SpecificationComponent/#inheritance","text":"SpecificationComponent TransformationSpecification ElementDerivation","title":"Inheritance"},{"location":"schema/SpecificationComponent/#slots","text":"Name Cardinality and Range Description Inheritance description 0..1 String description of the specification component direct implements 0..* Uriorcurie A reference to a specification that this component implements direct comments 0..* String A list of comments about this component direct","title":"Slots"},{"location":"schema/SpecificationComponent/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/SpecificationComponent/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/SpecificationComponent/#mappings","text":"Mapping Type Mapped Value self linkmltr:SpecificationComponent native linkmltr:SpecificationComponent","title":"Mappings"},{"location":"schema/SpecificationComponent/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/SpecificationComponent/#direct","text":"name : SpecificationComponent from_schema : https://w3id.org/linkml/transformer abstract : true attributes : description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description domain_of : - SpecificationComponent implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true domain_of : - SpecificationComponent range : string","title":"Direct"},{"location":"schema/SpecificationComponent/#induced","text":"name : SpecificationComponent from_schema : https://w3id.org/linkml/transformer abstract : true attributes : description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : SpecificationComponent domain_of : - SpecificationComponent implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : SpecificationComponent domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : SpecificationComponent domain_of : - SpecificationComponent range : string","title":"Induced"},{"location":"schema/String/","text":"Type: String A character string URI: xsd:string base : str uri : xsd:string Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: String"},{"location":"schema/String/#type-string","text":"A character string URI: xsd:string base : str uri : xsd:string","title":"Type: String"},{"location":"schema/String/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/String/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/StringificationConfiguration/","text":"Class: StringificationConfiguration URI: linkmltr:StringificationConfiguration classDiagram class StringificationConfiguration StringificationConfiguration : delimiter StringificationConfiguration : over_slots StringificationConfiguration : reversed StringificationConfiguration : syntax StringificationConfiguration --> SerializationSyntaxType : syntax Slots Name Cardinality and Range Description Inheritance delimiter 0..1 String direct reversed 0..1 Boolean direct over_slots 0..* String direct syntax 0..1 SerializationSyntaxType direct Usages used by used in type used SlotDerivation stringification range StringificationConfiguration Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:StringificationConfiguration native linkmltr:StringificationConfiguration LinkML Source Direct name : StringificationConfiguration from_schema : https://w3id.org/linkml/transformer attributes : delimiter : name : delimiter examples : - value : ',' - value : '|' - value : ; from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - StringificationConfiguration range : string reversed : name : reversed from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - StringificationConfiguration range : boolean over_slots : name : over_slots from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - StringificationConfiguration range : string syntax : name : syntax examples : - value : json - value : yaml from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - StringificationConfiguration range : SerializationSyntaxType Induced name : StringificationConfiguration from_schema : https://w3id.org/linkml/transformer attributes : delimiter : name : delimiter examples : - value : ',' - value : '|' - value : ; from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : delimiter owner : StringificationConfiguration domain_of : - StringificationConfiguration range : string reversed : name : reversed from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : reversed owner : StringificationConfiguration domain_of : - StringificationConfiguration range : boolean over_slots : name : over_slots from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : over_slots owner : StringificationConfiguration domain_of : - StringificationConfiguration range : string syntax : name : syntax examples : - value : json - value : yaml from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : syntax owner : StringificationConfiguration domain_of : - StringificationConfiguration range : SerializationSyntaxType","title":"Class: StringificationConfiguration"},{"location":"schema/StringificationConfiguration/#class-stringificationconfiguration","text":"URI: linkmltr:StringificationConfiguration classDiagram class StringificationConfiguration StringificationConfiguration : delimiter StringificationConfiguration : over_slots StringificationConfiguration : reversed StringificationConfiguration : syntax StringificationConfiguration --> SerializationSyntaxType : syntax","title":"Class: StringificationConfiguration"},{"location":"schema/StringificationConfiguration/#slots","text":"Name Cardinality and Range Description Inheritance delimiter 0..1 String direct reversed 0..1 Boolean direct over_slots 0..* String direct syntax 0..1 SerializationSyntaxType direct","title":"Slots"},{"location":"schema/StringificationConfiguration/#usages","text":"used by used in type used SlotDerivation stringification range StringificationConfiguration","title":"Usages"},{"location":"schema/StringificationConfiguration/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/StringificationConfiguration/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/StringificationConfiguration/#mappings","text":"Mapping Type Mapped Value self linkmltr:StringificationConfiguration native linkmltr:StringificationConfiguration","title":"Mappings"},{"location":"schema/StringificationConfiguration/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/StringificationConfiguration/#direct","text":"name : StringificationConfiguration from_schema : https://w3id.org/linkml/transformer attributes : delimiter : name : delimiter examples : - value : ',' - value : '|' - value : ; from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - StringificationConfiguration range : string reversed : name : reversed from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - StringificationConfiguration range : boolean over_slots : name : over_slots from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - StringificationConfiguration range : string syntax : name : syntax examples : - value : json - value : yaml from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - StringificationConfiguration range : SerializationSyntaxType","title":"Direct"},{"location":"schema/StringificationConfiguration/#induced","text":"name : StringificationConfiguration from_schema : https://w3id.org/linkml/transformer attributes : delimiter : name : delimiter examples : - value : ',' - value : '|' - value : ; from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : delimiter owner : StringificationConfiguration domain_of : - StringificationConfiguration range : string reversed : name : reversed from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : reversed owner : StringificationConfiguration domain_of : - StringificationConfiguration range : boolean over_slots : name : over_slots from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : over_slots owner : StringificationConfiguration domain_of : - StringificationConfiguration range : string syntax : name : syntax examples : - value : json - value : yaml from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : syntax owner : StringificationConfiguration domain_of : - StringificationConfiguration range : SerializationSyntaxType","title":"Induced"},{"location":"schema/Time/","text":"Type: Time A time object represents a (local) time of day, independent of any particular day URI: xsd:time base : XSDTime uri : xsd:time repr : str Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Time"},{"location":"schema/Time/#type-time","text":"A time object represents a (local) time of day, independent of any particular day URI: xsd:time base : XSDTime uri : xsd:time repr : str","title":"Type: Time"},{"location":"schema/Time/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Time/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/TransformationSpecification/","text":"Class: TransformationSpecification A collection of mappings between source and target classes URI: linkmltr:TransformationSpecification classDiagram class TransformationSpecification SpecificationComponent <|-- TransformationSpecification TransformationSpecification : class_derivations TransformationSpecification --> ClassDerivation : class_derivations TransformationSpecification : comments TransformationSpecification : description TransformationSpecification --> None : description TransformationSpecification : enum_derivations TransformationSpecification --> EnumDerivation : enum_derivations TransformationSpecification : id TransformationSpecification --> None : id TransformationSpecification : implements TransformationSpecification : prefixes TransformationSpecification --> KeyVal : prefixes TransformationSpecification : slot_derivations TransformationSpecification --> SlotDerivation : slot_derivations TransformationSpecification : source_schema TransformationSpecification --> None : source_schema TransformationSpecification : target_schema TransformationSpecification --> None : target_schema TransformationSpecification : title TransformationSpecification --> None : title Inheritance SpecificationComponent TransformationSpecification Slots Name Cardinality and Range Description Inheritance id 0..1 String Unique identifier for this transformation specification direct title 0..1 String human readable title for this transformation specification direct prefixes 0..* KeyVal maps prefixes to URL expansions direct source_schema 0..1 String name of the schema that describes the source (input) objects direct target_schema 0..1 String name of the schema that describes the target (output) objects direct class_derivations 0..* ClassDerivation Instructions on how to derive a set of classes in the target schema from clas... direct enum_derivations 0..* EnumDerivation Instructions on how to derive a set of enums in the target schema direct slot_derivations 0..* SlotDerivation Instructions on how to derive a set of top level slots in the target schema direct description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:TransformationSpecification native linkmltr:TransformationSpecification LinkML Source Direct name : TransformationSpecification description : A collection of mappings between source and target classes from_schema : https://w3id.org/linkml/transformer is_a : SpecificationComponent attributes : id : name : id description : Unique identifier for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : schema:identifier domain_of : - TransformationSpecification title : name : title description : human readable title for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:title domain_of : - TransformationSpecification prefixes : name : prefixes description : maps prefixes to URL expansions from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : sh:declare multivalued : true domain_of : - TransformationSpecification range : KeyVal inlined : true source_schema : name : source_schema description : name of the schema that describes the source (input) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - TransformationSpecification target_schema : name : target_schema description : name of the schema that describes the target (output) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - TransformationSpecification class_derivations : name : class_derivations description : Instructions on how to derive a set of classes in the target schema from classes in the source schema. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - TransformationSpecification range : ClassDerivation inlined : true enum_derivations : name : enum_derivations description : Instructions on how to derive a set of enums in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - TransformationSpecification range : EnumDerivation inlined : true slot_derivations : name : slot_derivations description : Instructions on how to derive a set of top level slots in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - TransformationSpecification - ClassDerivation range : SlotDerivation inlined : true tree_root : true Induced name : TransformationSpecification description : A collection of mappings between source and target classes from_schema : https://w3id.org/linkml/transformer is_a : SpecificationComponent attributes : id : name : id description : Unique identifier for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : schema:identifier alias : id owner : TransformationSpecification domain_of : - TransformationSpecification title : name : title description : human readable title for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:title alias : title owner : TransformationSpecification domain_of : - TransformationSpecification prefixes : name : prefixes description : maps prefixes to URL expansions from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : sh:declare multivalued : true alias : prefixes owner : TransformationSpecification domain_of : - TransformationSpecification range : KeyVal inlined : true source_schema : name : source_schema description : name of the schema that describes the source (input) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_schema owner : TransformationSpecification domain_of : - TransformationSpecification target_schema : name : target_schema description : name of the schema that describes the target (output) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_schema owner : TransformationSpecification domain_of : - TransformationSpecification class_derivations : name : class_derivations description : Instructions on how to derive a set of classes in the target schema from classes in the source schema. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : class_derivations owner : TransformationSpecification domain_of : - TransformationSpecification range : ClassDerivation inlined : true enum_derivations : name : enum_derivations description : Instructions on how to derive a set of enums in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : enum_derivations owner : TransformationSpecification domain_of : - TransformationSpecification range : EnumDerivation inlined : true slot_derivations : name : slot_derivations description : Instructions on how to derive a set of top level slots in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : slot_derivations owner : TransformationSpecification domain_of : - TransformationSpecification - ClassDerivation range : SlotDerivation inlined : true description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : TransformationSpecification domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : TransformationSpecification domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : TransformationSpecification domain_of : - SpecificationComponent range : string tree_root : true","title":"Class: TransformationSpecification"},{"location":"schema/TransformationSpecification/#class-transformationspecification","text":"A collection of mappings between source and target classes URI: linkmltr:TransformationSpecification classDiagram class TransformationSpecification SpecificationComponent <|-- TransformationSpecification TransformationSpecification : class_derivations TransformationSpecification --> ClassDerivation : class_derivations TransformationSpecification : comments TransformationSpecification : description TransformationSpecification --> None : description TransformationSpecification : enum_derivations TransformationSpecification --> EnumDerivation : enum_derivations TransformationSpecification : id TransformationSpecification --> None : id TransformationSpecification : implements TransformationSpecification : prefixes TransformationSpecification --> KeyVal : prefixes TransformationSpecification : slot_derivations TransformationSpecification --> SlotDerivation : slot_derivations TransformationSpecification : source_schema TransformationSpecification --> None : source_schema TransformationSpecification : target_schema TransformationSpecification --> None : target_schema TransformationSpecification : title TransformationSpecification --> None : title","title":"Class: TransformationSpecification"},{"location":"schema/TransformationSpecification/#inheritance","text":"SpecificationComponent TransformationSpecification","title":"Inheritance"},{"location":"schema/TransformationSpecification/#slots","text":"Name Cardinality and Range Description Inheritance id 0..1 String Unique identifier for this transformation specification direct title 0..1 String human readable title for this transformation specification direct prefixes 0..* KeyVal maps prefixes to URL expansions direct source_schema 0..1 String name of the schema that describes the source (input) objects direct target_schema 0..1 String name of the schema that describes the target (output) objects direct class_derivations 0..* ClassDerivation Instructions on how to derive a set of classes in the target schema from clas... direct enum_derivations 0..* EnumDerivation Instructions on how to derive a set of enums in the target schema direct slot_derivations 0..* SlotDerivation Instructions on how to derive a set of top level slots in the target schema direct description 0..1 String description of the specification component SpecificationComponent implements 0..* Uriorcurie A reference to a specification that this component implements SpecificationComponent comments 0..* String A list of comments about this component SpecificationComponent","title":"Slots"},{"location":"schema/TransformationSpecification/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/TransformationSpecification/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/TransformationSpecification/#mappings","text":"Mapping Type Mapped Value self linkmltr:TransformationSpecification native linkmltr:TransformationSpecification","title":"Mappings"},{"location":"schema/TransformationSpecification/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/TransformationSpecification/#direct","text":"name : TransformationSpecification description : A collection of mappings between source and target classes from_schema : https://w3id.org/linkml/transformer is_a : SpecificationComponent attributes : id : name : id description : Unique identifier for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : schema:identifier domain_of : - TransformationSpecification title : name : title description : human readable title for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:title domain_of : - TransformationSpecification prefixes : name : prefixes description : maps prefixes to URL expansions from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : sh:declare multivalued : true domain_of : - TransformationSpecification range : KeyVal inlined : true source_schema : name : source_schema description : name of the schema that describes the source (input) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - TransformationSpecification target_schema : name : target_schema description : name of the schema that describes the target (output) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - TransformationSpecification class_derivations : name : class_derivations description : Instructions on how to derive a set of classes in the target schema from classes in the source schema. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - TransformationSpecification range : ClassDerivation inlined : true enum_derivations : name : enum_derivations description : Instructions on how to derive a set of enums in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - TransformationSpecification range : EnumDerivation inlined : true slot_derivations : name : slot_derivations description : Instructions on how to derive a set of top level slots in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true domain_of : - TransformationSpecification - ClassDerivation range : SlotDerivation inlined : true tree_root : true","title":"Direct"},{"location":"schema/TransformationSpecification/#induced","text":"name : TransformationSpecification description : A collection of mappings between source and target classes from_schema : https://w3id.org/linkml/transformer is_a : SpecificationComponent attributes : id : name : id description : Unique identifier for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : schema:identifier alias : id owner : TransformationSpecification domain_of : - TransformationSpecification title : name : title description : human readable title for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:title alias : title owner : TransformationSpecification domain_of : - TransformationSpecification prefixes : name : prefixes description : maps prefixes to URL expansions from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : sh:declare multivalued : true alias : prefixes owner : TransformationSpecification domain_of : - TransformationSpecification range : KeyVal inlined : true source_schema : name : source_schema description : name of the schema that describes the source (input) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_schema owner : TransformationSpecification domain_of : - TransformationSpecification target_schema : name : target_schema description : name of the schema that describes the target (output) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_schema owner : TransformationSpecification domain_of : - TransformationSpecification class_derivations : name : class_derivations description : Instructions on how to derive a set of classes in the target schema from classes in the source schema. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : class_derivations owner : TransformationSpecification domain_of : - TransformationSpecification range : ClassDerivation inlined : true enum_derivations : name : enum_derivations description : Instructions on how to derive a set of enums in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : enum_derivations owner : TransformationSpecification domain_of : - TransformationSpecification range : EnumDerivation inlined : true slot_derivations : name : slot_derivations description : Instructions on how to derive a set of top level slots in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : slot_derivations owner : TransformationSpecification domain_of : - TransformationSpecification - ClassDerivation range : SlotDerivation inlined : true description : name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : TransformationSpecification domain_of : - SpecificationComponent range : string implements : name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : TransformationSpecification domain_of : - SpecificationComponent range : uriorcurie comments : name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : TransformationSpecification domain_of : - SpecificationComponent range : string tree_root : true","title":"Induced"},{"location":"schema/UnitConversionConfiguration/","text":"Class: UnitConversionConfiguration URI: linkmltr:UnitConversionConfiguration classDiagram class UnitConversionConfiguration UnitConversionConfiguration : source_magnitude_slot UnitConversionConfiguration --> None : source_magnitude_slot UnitConversionConfiguration : source_unit UnitConversionConfiguration --> None : source_unit UnitConversionConfiguration : source_unit_scheme UnitConversionConfiguration : source_unit_slot UnitConversionConfiguration --> None : source_unit_slot UnitConversionConfiguration : target_magnitude_slot UnitConversionConfiguration --> None : target_magnitude_slot UnitConversionConfiguration : target_unit UnitConversionConfiguration --> None : target_unit UnitConversionConfiguration : target_unit_scheme UnitConversionConfiguration : target_unit_slot UnitConversionConfiguration --> None : target_unit_slot Slots Name Cardinality and Range Description Inheritance target_unit 0..1 String direct target_unit_scheme 0..1 String direct source_unit 0..1 String direct source_unit_scheme 0..1 String direct source_unit_slot 0..1 String direct source_magnitude_slot 0..1 String direct target_unit_slot 0..1 String direct target_magnitude_slot 0..1 String direct Usages used by used in type used SlotDerivation unit_conversion range UnitConversionConfiguration Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer Mappings Mapping Type Mapped Value self linkmltr:UnitConversionConfiguration native linkmltr:UnitConversionConfiguration LinkML Source Direct name : UnitConversionConfiguration from_schema : https://w3id.org/linkml/transformer attributes : target_unit : name : target_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration target_unit_scheme : name : target_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration range : string source_unit : name : source_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration source_unit_scheme : name : source_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration range : string source_unit_slot : name : source_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration source_magnitude_slot : name : source_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration target_unit_slot : name : target_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration target_magnitude_slot : name : target_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration Induced name : UnitConversionConfiguration from_schema : https://w3id.org/linkml/transformer attributes : target_unit : name : target_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration target_unit_scheme : name : target_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit_scheme owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration range : string source_unit : name : source_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration source_unit_scheme : name : source_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit_scheme owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration range : string source_unit_slot : name : source_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration source_magnitude_slot : name : source_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_magnitude_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration target_unit_slot : name : target_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration target_magnitude_slot : name : target_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_magnitude_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"Class: UnitConversionConfiguration"},{"location":"schema/UnitConversionConfiguration/#class-unitconversionconfiguration","text":"URI: linkmltr:UnitConversionConfiguration classDiagram class UnitConversionConfiguration UnitConversionConfiguration : source_magnitude_slot UnitConversionConfiguration --> None : source_magnitude_slot UnitConversionConfiguration : source_unit UnitConversionConfiguration --> None : source_unit UnitConversionConfiguration : source_unit_scheme UnitConversionConfiguration : source_unit_slot UnitConversionConfiguration --> None : source_unit_slot UnitConversionConfiguration : target_magnitude_slot UnitConversionConfiguration --> None : target_magnitude_slot UnitConversionConfiguration : target_unit UnitConversionConfiguration --> None : target_unit UnitConversionConfiguration : target_unit_scheme UnitConversionConfiguration : target_unit_slot UnitConversionConfiguration --> None : target_unit_slot","title":"Class: UnitConversionConfiguration"},{"location":"schema/UnitConversionConfiguration/#slots","text":"Name Cardinality and Range Description Inheritance target_unit 0..1 String direct target_unit_scheme 0..1 String direct source_unit 0..1 String direct source_unit_scheme 0..1 String direct source_unit_slot 0..1 String direct source_magnitude_slot 0..1 String direct target_unit_slot 0..1 String direct target_magnitude_slot 0..1 String direct","title":"Slots"},{"location":"schema/UnitConversionConfiguration/#usages","text":"used by used in type used SlotDerivation unit_conversion range UnitConversionConfiguration","title":"Usages"},{"location":"schema/UnitConversionConfiguration/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/UnitConversionConfiguration/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/UnitConversionConfiguration/#mappings","text":"Mapping Type Mapped Value self linkmltr:UnitConversionConfiguration native linkmltr:UnitConversionConfiguration","title":"Mappings"},{"location":"schema/UnitConversionConfiguration/#linkml-source","text":"","title":"LinkML Source"},{"location":"schema/UnitConversionConfiguration/#direct","text":"name : UnitConversionConfiguration from_schema : https://w3id.org/linkml/transformer attributes : target_unit : name : target_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration target_unit_scheme : name : target_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration range : string source_unit : name : source_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration source_unit_scheme : name : source_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration range : string source_unit_slot : name : source_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration source_magnitude_slot : name : source_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration target_unit_slot : name : target_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration target_magnitude_slot : name : target_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 domain_of : - UnitConversionConfiguration","title":"Direct"},{"location":"schema/UnitConversionConfiguration/#induced","text":"name : UnitConversionConfiguration from_schema : https://w3id.org/linkml/transformer attributes : target_unit : name : target_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration target_unit_scheme : name : target_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit_scheme owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration range : string source_unit : name : source_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration source_unit_scheme : name : source_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit_scheme owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration range : string source_unit_slot : name : source_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration source_magnitude_slot : name : source_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_magnitude_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration target_unit_slot : name : target_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration target_magnitude_slot : name : target_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_magnitude_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"Induced"},{"location":"schema/Uri/","text":"Type: Uri a complete URI URI: xsd:anyURI base : URI uri : xsd:anyURI repr : str Comments in RDF serializations a slot with range of uri is treated as a literal or type xsd:anyURI unless it is an identifier or a reference to an identifier, in which case it is translated directly to a node Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Uri"},{"location":"schema/Uri/#type-uri","text":"a complete URI URI: xsd:anyURI base : URI uri : xsd:anyURI repr : str","title":"Type: Uri"},{"location":"schema/Uri/#comments","text":"in RDF serializations a slot with range of uri is treated as a literal or type xsd:anyURI unless it is an identifier or a reference to an identifier, in which case it is translated directly to a node","title":"Comments"},{"location":"schema/Uri/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Uri/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/Uriorcurie/","text":"Type: Uriorcurie a URI or a CURIE URI: xsd:anyURI base : URIorCURIE uri : xsd:anyURI repr : str Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Type: Uriorcurie"},{"location":"schema/Uriorcurie/#type-uriorcurie","text":"a URI or a CURIE URI: xsd:anyURI base : URIorCURIE uri : xsd:anyURI repr : str","title":"Type: Uriorcurie"},{"location":"schema/Uriorcurie/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/Uriorcurie/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/about/","text":"LinkML-Transformer","title":"LinkML-Transformer"},{"location":"schema/about/#linkml-transformer","text":"","title":"LinkML-Transformer"},{"location":"schema/add/","text":"Slot: add URI: linkmltr:add Applicable Classes Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no Properties Range: Any Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : add from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : add owner : CopyDirective domain_of : - CopyDirective range : Any","title":"Slot: add"},{"location":"schema/add/#slot-add","text":"URI: linkmltr:add","title":"Slot: add"},{"location":"schema/add/#applicable-classes","text":"Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no","title":"Applicable Classes"},{"location":"schema/add/#properties","text":"Range: Any","title":"Properties"},{"location":"schema/add/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/add/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/add/#linkml-source","text":"name : add from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : add owner : CopyDirective domain_of : - CopyDirective range : Any","title":"LinkML Source"},{"location":"schema/alias/","text":"Slot: alias name of the class to be aliased URI: linkmltr:alias Applicable Classes Name Description Modifies Slot AliasedClass alias-class key value pairs for classes no Properties Range: NONE Required: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : alias description : name of the class to be aliased from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : alias owner : AliasedClass domain_of : - AliasedClass required : true","title":"Slot: alias"},{"location":"schema/alias/#slot-alias","text":"name of the class to be aliased URI: linkmltr:alias","title":"Slot: alias"},{"location":"schema/alias/#applicable-classes","text":"Name Description Modifies Slot AliasedClass alias-class key value pairs for classes no","title":"Applicable Classes"},{"location":"schema/alias/#properties","text":"Range: NONE Required: True","title":"Properties"},{"location":"schema/alias/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/alias/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/alias/#linkml-source","text":"name : alias description : name of the class to be aliased from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : alias owner : AliasedClass domain_of : - AliasedClass required : true","title":"LinkML Source"},{"location":"schema/api/","text":"Session A wrapper object for a transformer session. TODO: rename to Manager? consolidate configuration include source and target database current spec, src_sv, tgt_sv all live in both this class and transformer Source code in src\\linkml_map\\session.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 @dataclass class Session : \"\"\" A wrapper object for a transformer session. TODO: - rename to Manager? - consolidate configuration - include source and target database - current spec, src_sv, tgt_sv all live in both this class and transformer \"\"\" transformer_specification : Optional [ TransformationSpecification ] = None source_schemaview : Optional [ SchemaView ] = None transformer : Optional [ Transformer ] = None object_transformer : Optional [ ObjectTransformer ] = None schema_mapper : Optional [ SchemaMapper ] = None _target_schema : Optional [ SchemaDefinition ] = None _target_schemaview : Optional [ SchemaView ] = None def set_transformer_specification ( self , specification : Optional [ Union [ TransformationSpecification , dict , str , Path ]] = None ): if isinstance ( specification , Path ): specification = str ( specification ) if isinstance ( specification , TransformationSpecification ): self . transformer_specification = specification elif isinstance ( specification , dict ): # TODO: centralize this code normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True specification = normalizer . normalize ( specification ) self . transformer_specification = TransformationSpecification ( ** specification ) elif isinstance ( specification , str ): if \" \\n \" in specification : obj = yaml . safe_load ( specification ) else : obj = yaml . safe_load ( open ( specification )) self . set_transformer_specification ( obj ) def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None def set_transformer ( self , transformer : Optional [ Union [ Transformer , Type [ Transformer ]]], ** kwargs , ): if isinstance ( transformer , Type ): transformer = transformer () transformer . specification = self . transformer_specification self . transformer = transformer def set_object_transformer ( self , transformer : Optional [ Union [ ObjectTransformer , TransformationSpecification , dict , str , Path ] ] = None , ): if transformer is None : if self . object_transformer is not None : logger . info ( \"No change\" ) return else : logger . warning ( \"No transformer specified\" ) return if transformer is not None : if isinstance ( transformer , ObjectTransformer ): self . object_transformer = transformer else : self . set_transformer_specification ( transformer ) self . object_transformer = ObjectTransformer () self . object_transformer . specification = self . transformer_specification self . _target_schema = None @property def target_schema ( self ) -> SchemaDefinition : if self . _target_schema is None : if not self . schema_mapper : self . schema_mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) self . _target_schema = self . schema_mapper . derive_schema ( self . transformer_specification ) return self . _target_schema @property def target_schemaview ( self ) -> SchemaView : if self . _target_schemaview is None : # TODO: simplify self . _target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return self . _target_schemaview def transform ( self , obj : dict , ** kwargs ) -> dict : if self . object_transformer is None : raise ValueError ( \"No transformer specified\" ) if not self . object_transformer . source_schemaview : self . object_transformer . source_schemaview = self . source_schemaview return self . object_transformer . map_object ( obj , ** kwargs ) def reverse_transform ( self , obj : dict , ** kwargs ) -> dict : inv_spec = self . invert () reverse_transformer = ObjectTransformer () reverse_transformer . specification = inv_spec reverse_transformer . source_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return reverse_transformer . map_object ( obj , ** kwargs ) def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph graphviz ( ** kwargs ) Return a graphviz representation of the schema. Source code in src\\linkml_map\\session.py 159 160 161 162 163 164 165 166 167 def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph invert ( in_place = False ) Invert the transformer specification. Source code in src\\linkml_map\\session.py 146 147 148 149 150 151 152 153 154 155 156 157 def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec set_source_schema ( schema ) Sets the schema from a path or SchemaView object. Source code in src\\linkml_map\\session.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None Transformer Bases: ABC Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this Source code in src\\linkml_map\\transformer\\transformer.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @dataclass class Transformer ( ABC ): \"\"\" Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this \"\"\" specification : TransformationSpecification = None \"\"\"A specification of how to generate target objects from source objects.\"\"\" source_schemaview : SchemaView = None \"\"\"A view over the schema describing the input/source object.\"\"\" _derived_specification : TransformationSpecification = None \"\"\"A specification with inferred missing values.\"\"\" target_schemaview : Optional [ SchemaView ] = None \"\"\"A view over the schema describing the output/target object.\"\"\" unrestricted_eval : bool = field ( default = False ) \"\"\"Set to True to allow arbitrary evals as part of transformation.\"\"\" _curie_converter : Converter = None def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path ) def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) @property def derived_specification ( self ) -> Optional [ TransformationSpecification ]: if self . _derived_specification is None : if self . specification is None : return None self . _derived_specification = deepcopy ( self . specification ) induce_missing_values ( self . _derived_specification , self . source_schemaview ) return self . _derived_specification def _get_class_derivation ( self , target_class_name : str ) -> ClassDerivation : spec = self . derived_specification matching_tgt_class_derivs = [ deriv for deriv in spec . class_derivations . values () if deriv . populated_from == target_class_name or ( not deriv . populated_from and target_class_name == deriv . name ) ] logger . debug ( f \"Target class derivations= { matching_tgt_class_derivs } \" ) if len ( matching_tgt_class_derivs ) != 1 : raise ValueError ( f \"Could not find class derivation for { target_class_name } (results= { len ( matching_tgt_class_derivs ) } )\" ) cd = matching_tgt_class_derivs [ 0 ] ancmap = self . _class_derivation_ancestors ( cd ) if ancmap : cd = deepcopy ( cd ) for anc in ancmap . values (): for k , v in anc . __dict__ . items (): if v is not None and v != []: curr_v = getattr ( cd , k , None ) if isinstance ( curr_v , list ): curr_v . extend ( v ) elif isinstance ( curr_v , dict ): curr_v . update ({ ** v , ** curr_v }) else : if curr_v is None : setattr ( cd , k , v ) return cd def _class_derivation_ancestors ( self , cd : ClassDerivation ) -> Dict [ str , ClassDerivation ]: \"\"\" Returns a map of all class derivations that are ancestors of the given class derivation. :param cd: :return: \"\"\" spec = self . specification ancestors = {} parents = cd . mixins + ([ cd . is_a ] if cd . is_a else []) for parent in parents : ancestors [ parent ] = spec . class_derivations [ parent ] ancestors . update ( self . _class_derivation_ancestors ( spec . class_derivations [ parent ])) return ancestors def _get_enum_derivation ( self , target_enum_name : str ) -> EnumDerivation : spec = self . derived_specification matching_tgt_enum_derivs = [ deriv for deriv in spec . enum_derivations . values () if deriv . populated_from == target_enum_name or ( not deriv . populated_from and target_enum_name == deriv . name ) ] logger . debug ( f \"Target enum derivations= { matching_tgt_enum_derivs } \" ) if len ( matching_tgt_enum_derivs ) != 1 : raise ValueError ( f \"Could not find what to derive from a source { target_enum_name } \" ) return matching_tgt_enum_derivs [ 0 ] def _is_coerce_to_multivalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as in [ CollectionType . MultiValued , CollectionType . MultiValuedDict , CollectionType . MultiValuedDict , ]: return True if slot_derivation . stringification and slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if slot . multivalued : return True return False def _is_coerce_to_singlevalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as == CollectionType ( CollectionType . SingleValued ): return True if slot_derivation . stringification and not slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if not slot . multivalued : return True return False def _coerce_datatype ( self , v : Any , target_range : Optional [ str ]) -> Any : if target_range is None : return v if isinstance ( v , list ): return [ self . _coerce_datatype ( v1 , target_range ) for v1 in v ] if isinstance ( v , dict ): return { k : self . _coerce_datatype ( v1 , target_range ) for k , v1 in v . items ()} cmap = { \"integer\" : int , \"float\" : float , \"string\" : str , \"boolean\" : bool , } cls = cmap . get ( target_range , None ) if not cls : logger . warning ( f \"Unknown target range { target_range } \" ) return v if isinstance ( v , cls ): return v return cls ( v ) @property def curie_converter ( self ) -> Converter : if not self . _curie_converter : self . _curie_converter = Converter ([]) for prefix in self . source_schemaview . schema . prefixes . values (): self . _curie_converter . add_prefix ( prefix . prefix_prefix , prefix . prefix_reference ) for prefix in self . specification . prefixes . values (): self . _curie_converter . add_prefix ( prefix . key , prefix . value ) return self . _curie_converter def expand_curie ( self , curie : str ) -> str : return self . curie_converter . expand ( curie ) def compress_uri ( self , uri : str ) -> str : return self . curie_converter . compress ( uri ) source_schemaview : SchemaView = None class-attribute instance-attribute A view over the schema describing the input/source object. specification : TransformationSpecification = None class-attribute instance-attribute A specification of how to generate target objects from source objects. target_schemaview : Optional [ SchemaView ] = None class-attribute instance-attribute A view over the schema describing the output/target object. unrestricted_eval : bool = field ( default = False ) class-attribute instance-attribute Set to True to allow arbitrary evals as part of transformation. create_transformer_specification ( obj ) Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) load_source_schema ( path ) Sets source_schemaview from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 89 90 91 92 93 94 95 96 97 98 def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path ) load_transformer_specification ( path ) Sets specification from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) map_database ( source_database , target_database = None , ** kwargs ) Transform source resource. :param source_database: :param target_database: :param kwargs: :return: Source code in src\\linkml_map\\transformer\\transformer.py 76 77 78 79 80 81 82 83 84 85 86 87 def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError map_object ( obj , source_type = None , ** kwargs ) Transform source object into an instance of the target class. :param obj: :param source_type: :return: Source code in src\\linkml_map\\transformer\\transformer.py 66 67 68 69 70 71 72 73 74 def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError","title":"Session"},{"location":"schema/api/#session","text":"A wrapper object for a transformer session. TODO: rename to Manager? consolidate configuration include source and target database current spec, src_sv, tgt_sv all live in both this class and transformer Source code in src\\linkml_map\\session.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 @dataclass class Session : \"\"\" A wrapper object for a transformer session. TODO: - rename to Manager? - consolidate configuration - include source and target database - current spec, src_sv, tgt_sv all live in both this class and transformer \"\"\" transformer_specification : Optional [ TransformationSpecification ] = None source_schemaview : Optional [ SchemaView ] = None transformer : Optional [ Transformer ] = None object_transformer : Optional [ ObjectTransformer ] = None schema_mapper : Optional [ SchemaMapper ] = None _target_schema : Optional [ SchemaDefinition ] = None _target_schemaview : Optional [ SchemaView ] = None def set_transformer_specification ( self , specification : Optional [ Union [ TransformationSpecification , dict , str , Path ]] = None ): if isinstance ( specification , Path ): specification = str ( specification ) if isinstance ( specification , TransformationSpecification ): self . transformer_specification = specification elif isinstance ( specification , dict ): # TODO: centralize this code normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True specification = normalizer . normalize ( specification ) self . transformer_specification = TransformationSpecification ( ** specification ) elif isinstance ( specification , str ): if \" \\n \" in specification : obj = yaml . safe_load ( specification ) else : obj = yaml . safe_load ( open ( specification )) self . set_transformer_specification ( obj ) def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None def set_transformer ( self , transformer : Optional [ Union [ Transformer , Type [ Transformer ]]], ** kwargs , ): if isinstance ( transformer , Type ): transformer = transformer () transformer . specification = self . transformer_specification self . transformer = transformer def set_object_transformer ( self , transformer : Optional [ Union [ ObjectTransformer , TransformationSpecification , dict , str , Path ] ] = None , ): if transformer is None : if self . object_transformer is not None : logger . info ( \"No change\" ) return else : logger . warning ( \"No transformer specified\" ) return if transformer is not None : if isinstance ( transformer , ObjectTransformer ): self . object_transformer = transformer else : self . set_transformer_specification ( transformer ) self . object_transformer = ObjectTransformer () self . object_transformer . specification = self . transformer_specification self . _target_schema = None @property def target_schema ( self ) -> SchemaDefinition : if self . _target_schema is None : if not self . schema_mapper : self . schema_mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) self . _target_schema = self . schema_mapper . derive_schema ( self . transformer_specification ) return self . _target_schema @property def target_schemaview ( self ) -> SchemaView : if self . _target_schemaview is None : # TODO: simplify self . _target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return self . _target_schemaview def transform ( self , obj : dict , ** kwargs ) -> dict : if self . object_transformer is None : raise ValueError ( \"No transformer specified\" ) if not self . object_transformer . source_schemaview : self . object_transformer . source_schemaview = self . source_schemaview return self . object_transformer . map_object ( obj , ** kwargs ) def reverse_transform ( self , obj : dict , ** kwargs ) -> dict : inv_spec = self . invert () reverse_transformer = ObjectTransformer () reverse_transformer . specification = inv_spec reverse_transformer . source_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return reverse_transformer . map_object ( obj , ** kwargs ) def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph","title":"Session"},{"location":"schema/api/#linkml_map.session.Session.graphviz","text":"Return a graphviz representation of the schema. Source code in src\\linkml_map\\session.py 159 160 161 162 163 164 165 166 167 def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph","title":"graphviz"},{"location":"schema/api/#linkml_map.session.Session.invert","text":"Invert the transformer specification. Source code in src\\linkml_map\\session.py 146 147 148 149 150 151 152 153 154 155 156 157 def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec","title":"invert"},{"location":"schema/api/#linkml_map.session.Session.set_source_schema","text":"Sets the schema from a path or SchemaView object. Source code in src\\linkml_map\\session.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None","title":"set_source_schema"},{"location":"schema/api/#transformer","text":"Bases: ABC Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this Source code in src\\linkml_map\\transformer\\transformer.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @dataclass class Transformer ( ABC ): \"\"\" Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this \"\"\" specification : TransformationSpecification = None \"\"\"A specification of how to generate target objects from source objects.\"\"\" source_schemaview : SchemaView = None \"\"\"A view over the schema describing the input/source object.\"\"\" _derived_specification : TransformationSpecification = None \"\"\"A specification with inferred missing values.\"\"\" target_schemaview : Optional [ SchemaView ] = None \"\"\"A view over the schema describing the output/target object.\"\"\" unrestricted_eval : bool = field ( default = False ) \"\"\"Set to True to allow arbitrary evals as part of transformation.\"\"\" _curie_converter : Converter = None def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path ) def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) @property def derived_specification ( self ) -> Optional [ TransformationSpecification ]: if self . _derived_specification is None : if self . specification is None : return None self . _derived_specification = deepcopy ( self . specification ) induce_missing_values ( self . _derived_specification , self . source_schemaview ) return self . _derived_specification def _get_class_derivation ( self , target_class_name : str ) -> ClassDerivation : spec = self . derived_specification matching_tgt_class_derivs = [ deriv for deriv in spec . class_derivations . values () if deriv . populated_from == target_class_name or ( not deriv . populated_from and target_class_name == deriv . name ) ] logger . debug ( f \"Target class derivations= { matching_tgt_class_derivs } \" ) if len ( matching_tgt_class_derivs ) != 1 : raise ValueError ( f \"Could not find class derivation for { target_class_name } (results= { len ( matching_tgt_class_derivs ) } )\" ) cd = matching_tgt_class_derivs [ 0 ] ancmap = self . _class_derivation_ancestors ( cd ) if ancmap : cd = deepcopy ( cd ) for anc in ancmap . values (): for k , v in anc . __dict__ . items (): if v is not None and v != []: curr_v = getattr ( cd , k , None ) if isinstance ( curr_v , list ): curr_v . extend ( v ) elif isinstance ( curr_v , dict ): curr_v . update ({ ** v , ** curr_v }) else : if curr_v is None : setattr ( cd , k , v ) return cd def _class_derivation_ancestors ( self , cd : ClassDerivation ) -> Dict [ str , ClassDerivation ]: \"\"\" Returns a map of all class derivations that are ancestors of the given class derivation. :param cd: :return: \"\"\" spec = self . specification ancestors = {} parents = cd . mixins + ([ cd . is_a ] if cd . is_a else []) for parent in parents : ancestors [ parent ] = spec . class_derivations [ parent ] ancestors . update ( self . _class_derivation_ancestors ( spec . class_derivations [ parent ])) return ancestors def _get_enum_derivation ( self , target_enum_name : str ) -> EnumDerivation : spec = self . derived_specification matching_tgt_enum_derivs = [ deriv for deriv in spec . enum_derivations . values () if deriv . populated_from == target_enum_name or ( not deriv . populated_from and target_enum_name == deriv . name ) ] logger . debug ( f \"Target enum derivations= { matching_tgt_enum_derivs } \" ) if len ( matching_tgt_enum_derivs ) != 1 : raise ValueError ( f \"Could not find what to derive from a source { target_enum_name } \" ) return matching_tgt_enum_derivs [ 0 ] def _is_coerce_to_multivalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as in [ CollectionType . MultiValued , CollectionType . MultiValuedDict , CollectionType . MultiValuedDict , ]: return True if slot_derivation . stringification and slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if slot . multivalued : return True return False def _is_coerce_to_singlevalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as == CollectionType ( CollectionType . SingleValued ): return True if slot_derivation . stringification and not slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if not slot . multivalued : return True return False def _coerce_datatype ( self , v : Any , target_range : Optional [ str ]) -> Any : if target_range is None : return v if isinstance ( v , list ): return [ self . _coerce_datatype ( v1 , target_range ) for v1 in v ] if isinstance ( v , dict ): return { k : self . _coerce_datatype ( v1 , target_range ) for k , v1 in v . items ()} cmap = { \"integer\" : int , \"float\" : float , \"string\" : str , \"boolean\" : bool , } cls = cmap . get ( target_range , None ) if not cls : logger . warning ( f \"Unknown target range { target_range } \" ) return v if isinstance ( v , cls ): return v return cls ( v ) @property def curie_converter ( self ) -> Converter : if not self . _curie_converter : self . _curie_converter = Converter ([]) for prefix in self . source_schemaview . schema . prefixes . values (): self . _curie_converter . add_prefix ( prefix . prefix_prefix , prefix . prefix_reference ) for prefix in self . specification . prefixes . values (): self . _curie_converter . add_prefix ( prefix . key , prefix . value ) return self . _curie_converter def expand_curie ( self , curie : str ) -> str : return self . curie_converter . expand ( curie ) def compress_uri ( self , uri : str ) -> str : return self . curie_converter . compress ( uri )","title":"Transformer"},{"location":"schema/api/#linkml_map.transformer.transformer.Transformer.source_schemaview","text":"A view over the schema describing the input/source object.","title":"source_schemaview"},{"location":"schema/api/#linkml_map.transformer.transformer.Transformer.specification","text":"A specification of how to generate target objects from source objects.","title":"specification"},{"location":"schema/api/#linkml_map.transformer.transformer.Transformer.target_schemaview","text":"A view over the schema describing the output/target object.","title":"target_schemaview"},{"location":"schema/api/#linkml_map.transformer.transformer.Transformer.unrestricted_eval","text":"Set to True to allow arbitrary evals as part of transformation.","title":"unrestricted_eval"},{"location":"schema/api/#linkml_map.transformer.transformer.Transformer.create_transformer_specification","text":"Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj )","title":"create_transformer_specification"},{"location":"schema/api/#linkml_map.transformer.transformer.Transformer.load_source_schema","text":"Sets source_schemaview from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 89 90 91 92 93 94 95 96 97 98 def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path )","title":"load_source_schema"},{"location":"schema/api/#linkml_map.transformer.transformer.Transformer.load_transformer_specification","text":"Sets specification from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj )","title":"load_transformer_specification"},{"location":"schema/api/#linkml_map.transformer.transformer.Transformer.map_database","text":"Transform source resource. :param source_database: :param target_database: :param kwargs: :return: Source code in src\\linkml_map\\transformer\\transformer.py 76 77 78 79 80 81 82 83 84 85 86 87 def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError","title":"map_database"},{"location":"schema/api/#linkml_map.transformer.transformer.Transformer.map_object","text":"Transform source object into an instance of the target class. :param obj: :param source_type: :return: Source code in src\\linkml_map\\transformer\\transformer.py 66 67 68 69 70 71 72 73 74 def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError","title":"map_object"},{"location":"schema/cast_collection_as/","text":"Slot: cast_collection_as URI: linkmltr:cast_collection_as Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no Properties Range: CollectionType Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : cast_collection_as from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : cast_collection_as owner : SlotDerivation domain_of : - SlotDerivation range : CollectionType","title":"Slot: cast_collection_as"},{"location":"schema/cast_collection_as/#slot-cast_collection_as","text":"URI: linkmltr:cast_collection_as","title":"Slot: cast_collection_as"},{"location":"schema/cast_collection_as/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no","title":"Applicable Classes"},{"location":"schema/cast_collection_as/#properties","text":"Range: CollectionType","title":"Properties"},{"location":"schema/cast_collection_as/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/cast_collection_as/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/cast_collection_as/#linkml-source","text":"name : cast_collection_as from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : cast_collection_as owner : SlotDerivation domain_of : - SlotDerivation range : CollectionType","title":"LinkML Source"},{"location":"schema/class_derivations/","text":"Slot: class_derivations Instructions on how to derive a set of classes in the target schema from classes in the source schema. URI: linkmltr:class_derivations Applicable Classes Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no Properties Range: ClassDerivation Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : class_derivations description : Instructions on how to derive a set of classes in the target schema from classes in the source schema. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : class_derivations owner : TransformationSpecification domain_of : - TransformationSpecification range : ClassDerivation inlined : true","title":"Slot: class_derivations"},{"location":"schema/class_derivations/#slot-class_derivations","text":"Instructions on how to derive a set of classes in the target schema from classes in the source schema. URI: linkmltr:class_derivations","title":"Slot: class_derivations"},{"location":"schema/class_derivations/#applicable-classes","text":"Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no","title":"Applicable Classes"},{"location":"schema/class_derivations/#properties","text":"Range: ClassDerivation Multivalued: True","title":"Properties"},{"location":"schema/class_derivations/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/class_derivations/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/class_derivations/#linkml-source","text":"name : class_derivations description : Instructions on how to derive a set of classes in the target schema from classes in the source schema. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : class_derivations owner : TransformationSpecification domain_of : - TransformationSpecification range : ClassDerivation inlined : true","title":"LinkML Source"},{"location":"schema/class_name/","text":"Slot: class_name URI: linkmltr:class_name Applicable Classes Name Description Modifies Slot Inverse Used for back references in mapping to relational model no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : class_name from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : class_name owner : Inverse domain_of : - Inverse","title":"Slot: class_name"},{"location":"schema/class_name/#slot-class_name","text":"URI: linkmltr:class_name","title":"Slot: class_name"},{"location":"schema/class_name/#applicable-classes","text":"Name Description Modifies Slot Inverse Used for back references in mapping to relational model no","title":"Applicable Classes"},{"location":"schema/class_name/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/class_name/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/class_name/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/class_name/#linkml-source","text":"name : class_name from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : class_name owner : Inverse domain_of : - Inverse","title":"LinkML Source"},{"location":"schema/class_named/","text":"Slot: class_named local alias for the class URI: linkmltr:class_named Applicable Classes Name Description Modifies Slot AliasedClass alias-class key value pairs for classes no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : class_named description : local alias for the class from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : class_named owner : AliasedClass domain_of : - AliasedClass","title":"Slot: class_named"},{"location":"schema/class_named/#slot-class_named","text":"local alias for the class URI: linkmltr:class_named","title":"Slot: class_named"},{"location":"schema/class_named/#applicable-classes","text":"Name Description Modifies Slot AliasedClass alias-class key value pairs for classes no","title":"Applicable Classes"},{"location":"schema/class_named/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/class_named/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/class_named/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/class_named/#linkml-source","text":"name : class_named description : local alias for the class from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : class_named owner : AliasedClass domain_of : - AliasedClass","title":"LinkML Source"},{"location":"schema/comments/","text":"Slot: comments A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. URI: rdfs:comment Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no SpecificationComponent no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no TransformationSpecification A collection of mappings between source and target classes no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: String Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : SpecificationComponent domain_of : - SpecificationComponent range : string","title":"Slot: comments"},{"location":"schema/comments/#slot-comments","text":"A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. URI: rdfs:comment","title":"Slot: comments"},{"location":"schema/comments/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no SpecificationComponent no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no TransformationSpecification A collection of mappings between source and target classes no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/comments/#properties","text":"Range: String Multivalued: True","title":"Properties"},{"location":"schema/comments/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/comments/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/comments/#linkml-source","text":"name : comments description : A list of comments about this component. Comments are free text, and may be used to provide additional information about the component, including instructions for its use. from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : rdfs:comment multivalued : true alias : comments owner : SpecificationComponent domain_of : - SpecificationComponent range : string","title":"LinkML Source"},{"location":"schema/compiler/","text":"Compiler Package A compiler will compile a Map specification into an alternative representation Compiler (Base Class) Bases: ABC Base class for all compilers. A compiler will compile a transformation specification into an alternative representation. An example compiler would be a R2RML compiler. Note: Compilers and Importers will in general be implemented by providing mapping specifications Source code in src\\linkml_map\\compiler\\compiler.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @dataclass class Compiler ( ABC ): \"\"\" Base class for all compilers. A compiler will compile a transformation specification into an alternative representation. An example compiler would be a R2RML compiler. Note: Compilers and Importers will in general be implemented by providing mapping specifications \"\"\" source_schemaview : SchemaView = None \"\"\"A view over the schema describing the source.\"\"\" source_python_module : str = None \"\"\"The python module containing the source classes.\"\"\" target_python_module : str = None \"\"\"The python module containing the target classes.\"\"\" def compile ( self , specification : TransformationSpecification ) -> CompiledSpecification : \"\"\" Transform source object into an instance of the target class. :param specification: :return: \"\"\" s = self . _compile_header ( specification ) for chunk in self . _compile_iterator ( specification ): s += chunk return CompiledSpecification ( serialization = s ) def _compile_header ( self , specification : TransformationSpecification ) -> str : return \"\" def _compile_iterator ( self , specification : TransformationSpecification ) -> Iterator [ str ]: raise NotImplementedError def derived_target_schemaview ( self , specification : TransformationSpecification ): \"\"\" Returns a view over the target schema, including any derived classes. \"\"\" mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) return SchemaView ( yaml_dumper . dumps ( mapper . derive_schema ( specification ))) source_python_module : str = None class-attribute instance-attribute The python module containing the source classes. source_schemaview : SchemaView = None class-attribute instance-attribute A view over the schema describing the source. target_python_module : str = None class-attribute instance-attribute The python module containing the target classes. compile ( specification ) Transform source object into an instance of the target class. :param specification: :return: Source code in src\\linkml_map\\compiler\\compiler.py 65 66 67 68 69 70 71 72 73 74 75 def compile ( self , specification : TransformationSpecification ) -> CompiledSpecification : \"\"\" Transform source object into an instance of the target class. :param specification: :return: \"\"\" s = self . _compile_header ( specification ) for chunk in self . _compile_iterator ( specification ): s += chunk return CompiledSpecification ( serialization = s ) derived_target_schemaview ( specification ) Returns a view over the target schema, including any derived classes. Source code in src\\linkml_map\\compiler\\compiler.py 83 84 85 86 87 88 def derived_target_schemaview ( self , specification : TransformationSpecification ): \"\"\" Returns a view over the target schema, including any derived classes. \"\"\" mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) return SchemaView ( yaml_dumper . dumps ( mapper . derive_schema ( specification ))) Python Compiler Bases: Compiler Compiles a Transformation Specification to Python code. Source code in src\\linkml_map\\compiler\\python_compiler.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @dataclass class PythonCompiler ( Compiler ): \"\"\" Compiles a Transformation Specification to Python code. \"\"\" def _compile_header ( self , specification : TransformationSpecification ) -> str : s = \"\" if self . source_python_module : s += f \"import { self . source_python_module } as src \\n \" if self . target_python_module : s += f \"import { self . target_python_module } as tgt \\n \" s += \" \\n NULL = None \\n\\n \" return s def _compile_iterator ( self , specification : TransformationSpecification ) -> Iterator [ str ]: specification = deepcopy ( specification ) induce_missing_values ( specification , self . source_schemaview ) for cd in specification . class_derivations . values (): yield from self . _compiled_class_derivations_iter ( cd ) def _compiled_class_derivations_iter ( self , cd : ClassDerivation ) -> Iterator [ str ]: sv = self . source_schemaview if cd . populated_from : populated_from = cd . populated_from else : populated_from = cd . name if populated_from not in sv . all_classes (): return induced_slots = { s . name : s for s in sv . class_induced_slots ( populated_from )} t = Template ( CD_TEMPLATE ) yield t . render ( cd = cd , source_module = \"src\" , target_module = \"tgt\" , induced_slots = induced_slots , schemaview = sv , source_slots = sv . class_induced_slots ( populated_from ), ) Markdown Compiler Bases: J2BasedCompiler Compiles a Transformation Specification to Markdown. Source code in src\\linkml_map\\compiler\\markdown_compiler.py 6 7 8 9 10 11 12 @dataclass class MarkdownCompiler ( J2BasedCompiler ): \"\"\" Compiles a Transformation Specification to Markdown. \"\"\" template_name : str = \"markdown.j2\"","title":"Compiler Package"},{"location":"schema/compiler/#compiler-package","text":"A compiler will compile a Map specification into an alternative representation","title":"Compiler Package"},{"location":"schema/compiler/#compiler-base-class","text":"Bases: ABC Base class for all compilers. A compiler will compile a transformation specification into an alternative representation. An example compiler would be a R2RML compiler. Note: Compilers and Importers will in general be implemented by providing mapping specifications Source code in src\\linkml_map\\compiler\\compiler.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @dataclass class Compiler ( ABC ): \"\"\" Base class for all compilers. A compiler will compile a transformation specification into an alternative representation. An example compiler would be a R2RML compiler. Note: Compilers and Importers will in general be implemented by providing mapping specifications \"\"\" source_schemaview : SchemaView = None \"\"\"A view over the schema describing the source.\"\"\" source_python_module : str = None \"\"\"The python module containing the source classes.\"\"\" target_python_module : str = None \"\"\"The python module containing the target classes.\"\"\" def compile ( self , specification : TransformationSpecification ) -> CompiledSpecification : \"\"\" Transform source object into an instance of the target class. :param specification: :return: \"\"\" s = self . _compile_header ( specification ) for chunk in self . _compile_iterator ( specification ): s += chunk return CompiledSpecification ( serialization = s ) def _compile_header ( self , specification : TransformationSpecification ) -> str : return \"\" def _compile_iterator ( self , specification : TransformationSpecification ) -> Iterator [ str ]: raise NotImplementedError def derived_target_schemaview ( self , specification : TransformationSpecification ): \"\"\" Returns a view over the target schema, including any derived classes. \"\"\" mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) return SchemaView ( yaml_dumper . dumps ( mapper . derive_schema ( specification )))","title":"Compiler (Base Class)"},{"location":"schema/compiler/#linkml_map.compiler.compiler.Compiler.source_python_module","text":"The python module containing the source classes.","title":"source_python_module"},{"location":"schema/compiler/#linkml_map.compiler.compiler.Compiler.source_schemaview","text":"A view over the schema describing the source.","title":"source_schemaview"},{"location":"schema/compiler/#linkml_map.compiler.compiler.Compiler.target_python_module","text":"The python module containing the target classes.","title":"target_python_module"},{"location":"schema/compiler/#linkml_map.compiler.compiler.Compiler.compile","text":"Transform source object into an instance of the target class. :param specification: :return: Source code in src\\linkml_map\\compiler\\compiler.py 65 66 67 68 69 70 71 72 73 74 75 def compile ( self , specification : TransformationSpecification ) -> CompiledSpecification : \"\"\" Transform source object into an instance of the target class. :param specification: :return: \"\"\" s = self . _compile_header ( specification ) for chunk in self . _compile_iterator ( specification ): s += chunk return CompiledSpecification ( serialization = s )","title":"compile"},{"location":"schema/compiler/#linkml_map.compiler.compiler.Compiler.derived_target_schemaview","text":"Returns a view over the target schema, including any derived classes. Source code in src\\linkml_map\\compiler\\compiler.py 83 84 85 86 87 88 def derived_target_schemaview ( self , specification : TransformationSpecification ): \"\"\" Returns a view over the target schema, including any derived classes. \"\"\" mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) return SchemaView ( yaml_dumper . dumps ( mapper . derive_schema ( specification )))","title":"derived_target_schemaview"},{"location":"schema/compiler/#python-compiler","text":"Bases: Compiler Compiles a Transformation Specification to Python code. Source code in src\\linkml_map\\compiler\\python_compiler.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @dataclass class PythonCompiler ( Compiler ): \"\"\" Compiles a Transformation Specification to Python code. \"\"\" def _compile_header ( self , specification : TransformationSpecification ) -> str : s = \"\" if self . source_python_module : s += f \"import { self . source_python_module } as src \\n \" if self . target_python_module : s += f \"import { self . target_python_module } as tgt \\n \" s += \" \\n NULL = None \\n\\n \" return s def _compile_iterator ( self , specification : TransformationSpecification ) -> Iterator [ str ]: specification = deepcopy ( specification ) induce_missing_values ( specification , self . source_schemaview ) for cd in specification . class_derivations . values (): yield from self . _compiled_class_derivations_iter ( cd ) def _compiled_class_derivations_iter ( self , cd : ClassDerivation ) -> Iterator [ str ]: sv = self . source_schemaview if cd . populated_from : populated_from = cd . populated_from else : populated_from = cd . name if populated_from not in sv . all_classes (): return induced_slots = { s . name : s for s in sv . class_induced_slots ( populated_from )} t = Template ( CD_TEMPLATE ) yield t . render ( cd = cd , source_module = \"src\" , target_module = \"tgt\" , induced_slots = induced_slots , schemaview = sv , source_slots = sv . class_induced_slots ( populated_from ), )","title":"Python Compiler"},{"location":"schema/compiler/#markdown-compiler","text":"Bases: J2BasedCompiler Compiles a Transformation Specification to Markdown. Source code in src\\linkml_map\\compiler\\markdown_compiler.py 6 7 8 9 10 11 12 @dataclass class MarkdownCompiler ( J2BasedCompiler ): \"\"\" Compiles a Transformation Specification to Markdown. \"\"\" template_name : str = \"markdown.j2\"","title":"Markdown Compiler"},{"location":"schema/copy_all/","text":"Slot: copy_all URI: linkmltr:copy_all Applicable Classes Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no Properties Range: Boolean Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : copy_all from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : copy_all owner : CopyDirective domain_of : - CopyDirective range : boolean","title":"Slot: copy_all"},{"location":"schema/copy_all/#slot-copy_all","text":"URI: linkmltr:copy_all","title":"Slot: copy_all"},{"location":"schema/copy_all/#applicable-classes","text":"Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no","title":"Applicable Classes"},{"location":"schema/copy_all/#properties","text":"Range: Boolean","title":"Properties"},{"location":"schema/copy_all/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/copy_all/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/copy_all/#linkml-source","text":"name : copy_all from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : copy_all owner : CopyDirective domain_of : - CopyDirective range : boolean","title":"LinkML Source"},{"location":"schema/copy_directives/","text":"Slot: copy_directives URI: linkmltr:copy_directives Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: CopyDirective Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : ElementDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true","title":"Slot: copy_directives"},{"location":"schema/copy_directives/#slot-copy_directives","text":"URI: linkmltr:copy_directives","title":"Slot: copy_directives"},{"location":"schema/copy_directives/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/copy_directives/#properties","text":"Range: CopyDirective Multivalued: True","title":"Properties"},{"location":"schema/copy_directives/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/copy_directives/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/copy_directives/#linkml-source","text":"name : copy_directives from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : copy_directives owner : ElementDerivation domain_of : - ElementDerivation range : CopyDirective inlined : true","title":"LinkML Source"},{"location":"schema/datamodel/","text":"LinkML Map Data Model Datamodel for LinkML schema mappings and transformations. A mapper generates instances of a target data model from instances of a source data model. This transformation process is guided by a TransformationSpecification . The specification is independent of any one method for transforming data. It allows different approaches, including: direct implementation, transforming python or json objects translation of the specification into SQL commands, to operate on relations translation of the specification into SPARQL CONSTRUCTs, to operate on triples translation into another specification language, such as R2RML URI: https://w3id.org/linkml/transformer Name: linkml-map Classes Class Description AliasedClass alias-class key value pairs for classes Any None CopyDirective Instructs a Schema Mapper in how to map to a target schema. Not used for data transformation. This is the process to process a directive: 1. If copy_all , add all sub-elements to the list of sub-elements to be copied. 2. If exclude , remove the specified sub-elements from the above list. 3. If exclude_all , clean-up the above list. Effectively making previous steps useless. 4. If include , add the specified sub-elements from the list result of previous steps. Implementations might decide to somehow report (error, warning,...) meaningless combinations (like specifying copy_all and exclude_all ). Validation on the correctness of the resulting derived schema might be done optionally by the implementation. For example, removing a slot but keeping a class that requires it would invalidate the derived-schema. It is always possible to validate the schema with the LinkML linter after derivation. What are the considered sub-elements depends on the calls of Element to be transformed. For example, for a class they are slots and attributes . Inverse Used for back references in mapping to relational model KeyVal None SpecificationComponent None ElementDerivation An abstract grouping for classes that provide a specification of how to derive a target element from a source element. ClassDerivation A specification of how to derive a target class from a source class. EnumDerivation A specification of how to derive the value of a target enum from a source enum PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum PrefixDerivation None SlotDerivation A specification of how to derive the value of a target slot from a source slot TransformationSpecification A collection of mappings between source and target classes StringificationConfiguration None TransformationOperation None AggregationOperation None GroupingOperation None PivotOperation None UnitConversionConfiguration None Slots Slot Description add aggregation_operation alias name of the class to be aliased cast_collection_as class_derivations Instructions on how to derive a set of classes in the target schema from clas... class_name class_named local alias for the class comments A list of comments about this component copy_all Copy all sub-elements of the Element being derived copy_directives delimiter derived_from Source slots that are used to derive this slot description description of the specification component dictionary_key direction element_name enum_derivations Instructions on how to derive a set of enums in the target schema exclude Remove certain sub-elements from the list of sub-elements to be copied exclude_all Do not copy any of the sub-elements of the Element being derived expr An expression to be evaluated on the source object to derive the target slot expression_to_expression_mappings A mapping table in which the keys and values are expressions expression_to_value_mappings A mapping table in which the keys are expressions hide True if this is suppressed id Unique identifier for this transformation specification implements A reference to a specification that this component implements include Add certain sub-elements to the list of sub-elements to be copied invalid_value_handling inverse_of Used to specify a class-slot tuple that is the inverse of the derived/target ... is_a joins Additional classes to be joined to derive instances of the target class key mirror_source mixins name Name of the element in the target schema null_handling operator over_slots overrides overrides source schema slots permissible_value_derivations Instructions on how to derive a set of PVs in the target schema populated_from Name of the class in the source schema prefixes maps prefixes to URL expansions range reversed slot_derivations Instructions on how to derive a set of top level slots in the target schema slot_name source_magnitude_slot source_schema name of the schema that describes the source (input) objects source_unit source_unit_scheme source_unit_slot sources stringification syntax target_definition LinkML class definition object for this slot target_magnitude_slot target_schema name of the schema that describes the target (output) objects target_unit target_unit_scheme target_unit_slot title human readable title for this transformation specification type_designator unit_conversion unmelt_to_class In an unmelt operation, attributes (which are values in the long/melted/EAV r... unmelt_to_slots value value_mappings A mapping table that is applied directly to mappings, in order of precedence value_slot Slot to use for the value column in the melted/long representation variable_slot Slot to use for the variable column in the melted/long representation Enumerations Enumeration Description AggregationType CollectionType InvalidValueHandlingStrategy PivotDirectionType SerializationSyntaxType Types Type Description Boolean A binary (true or false) value ClassReference Curie a compact URI Date a date (year, month and day) in an idealized calendar DateOrDatetime Either a date or a datetime Datetime The combination of a date and time Decimal A real number with arbitrary precision that conforms to the xsd:decimal speci... Double A real number that conforms to the xsd:double specification EnumReference Float A real number that conforms to the xsd:float specification Integer An integer Jsonpath A string encoding a JSON Path Jsonpointer A string encoding a JSON Pointer Ncname Prefix part of CURIE Nodeidentifier A URI, CURIE or BNODE that represents a node in a model Objectidentifier A URI or CURIE that represents an object in the model SlotReference Sparqlpath A string encoding a SPARQL Property Path String A character string Time A time object represents a (local) time of day, independent of any particular... Uri a complete URI Uriorcurie a URI or a CURIE Subsets Subset Description","title":"Data Model"},{"location":"schema/datamodel/#linkml-map-data-model","text":"Datamodel for LinkML schema mappings and transformations. A mapper generates instances of a target data model from instances of a source data model. This transformation process is guided by a TransformationSpecification . The specification is independent of any one method for transforming data. It allows different approaches, including: direct implementation, transforming python or json objects translation of the specification into SQL commands, to operate on relations translation of the specification into SPARQL CONSTRUCTs, to operate on triples translation into another specification language, such as R2RML URI: https://w3id.org/linkml/transformer Name: linkml-map","title":"LinkML Map Data Model"},{"location":"schema/datamodel/#classes","text":"Class Description AliasedClass alias-class key value pairs for classes Any None CopyDirective Instructs a Schema Mapper in how to map to a target schema. Not used for data transformation. This is the process to process a directive: 1. If copy_all , add all sub-elements to the list of sub-elements to be copied. 2. If exclude , remove the specified sub-elements from the above list. 3. If exclude_all , clean-up the above list. Effectively making previous steps useless. 4. If include , add the specified sub-elements from the list result of previous steps. Implementations might decide to somehow report (error, warning,...) meaningless combinations (like specifying copy_all and exclude_all ). Validation on the correctness of the resulting derived schema might be done optionally by the implementation. For example, removing a slot but keeping a class that requires it would invalidate the derived-schema. It is always possible to validate the schema with the LinkML linter after derivation. What are the considered sub-elements depends on the calls of Element to be transformed. For example, for a class they are slots and attributes . Inverse Used for back references in mapping to relational model KeyVal None SpecificationComponent None ElementDerivation An abstract grouping for classes that provide a specification of how to derive a target element from a source element. ClassDerivation A specification of how to derive a target class from a source class. EnumDerivation A specification of how to derive the value of a target enum from a source enum PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum PrefixDerivation None SlotDerivation A specification of how to derive the value of a target slot from a source slot TransformationSpecification A collection of mappings between source and target classes StringificationConfiguration None TransformationOperation None AggregationOperation None GroupingOperation None PivotOperation None UnitConversionConfiguration None","title":"Classes"},{"location":"schema/datamodel/#slots","text":"Slot Description add aggregation_operation alias name of the class to be aliased cast_collection_as class_derivations Instructions on how to derive a set of classes in the target schema from clas... class_name class_named local alias for the class comments A list of comments about this component copy_all Copy all sub-elements of the Element being derived copy_directives delimiter derived_from Source slots that are used to derive this slot description description of the specification component dictionary_key direction element_name enum_derivations Instructions on how to derive a set of enums in the target schema exclude Remove certain sub-elements from the list of sub-elements to be copied exclude_all Do not copy any of the sub-elements of the Element being derived expr An expression to be evaluated on the source object to derive the target slot expression_to_expression_mappings A mapping table in which the keys and values are expressions expression_to_value_mappings A mapping table in which the keys are expressions hide True if this is suppressed id Unique identifier for this transformation specification implements A reference to a specification that this component implements include Add certain sub-elements to the list of sub-elements to be copied invalid_value_handling inverse_of Used to specify a class-slot tuple that is the inverse of the derived/target ... is_a joins Additional classes to be joined to derive instances of the target class key mirror_source mixins name Name of the element in the target schema null_handling operator over_slots overrides overrides source schema slots permissible_value_derivations Instructions on how to derive a set of PVs in the target schema populated_from Name of the class in the source schema prefixes maps prefixes to URL expansions range reversed slot_derivations Instructions on how to derive a set of top level slots in the target schema slot_name source_magnitude_slot source_schema name of the schema that describes the source (input) objects source_unit source_unit_scheme source_unit_slot sources stringification syntax target_definition LinkML class definition object for this slot target_magnitude_slot target_schema name of the schema that describes the target (output) objects target_unit target_unit_scheme target_unit_slot title human readable title for this transformation specification type_designator unit_conversion unmelt_to_class In an unmelt operation, attributes (which are values in the long/melted/EAV r... unmelt_to_slots value value_mappings A mapping table that is applied directly to mappings, in order of precedence value_slot Slot to use for the value column in the melted/long representation variable_slot Slot to use for the variable column in the melted/long representation","title":"Slots"},{"location":"schema/datamodel/#enumerations","text":"Enumeration Description AggregationType CollectionType InvalidValueHandlingStrategy PivotDirectionType SerializationSyntaxType","title":"Enumerations"},{"location":"schema/datamodel/#types","text":"Type Description Boolean A binary (true or false) value ClassReference Curie a compact URI Date a date (year, month and day) in an idealized calendar DateOrDatetime Either a date or a datetime Datetime The combination of a date and time Decimal A real number with arbitrary precision that conforms to the xsd:decimal speci... Double A real number that conforms to the xsd:double specification EnumReference Float A real number that conforms to the xsd:float specification Integer An integer Jsonpath A string encoding a JSON Path Jsonpointer A string encoding a JSON Pointer Ncname Prefix part of CURIE Nodeidentifier A URI, CURIE or BNODE that represents a node in a model Objectidentifier A URI or CURIE that represents an object in the model SlotReference Sparqlpath A string encoding a SPARQL Property Path String A character string Time A time object represents a (local) time of day, independent of any particular... Uri a complete URI Uriorcurie a URI or a CURIE","title":"Types"},{"location":"schema/datamodel/#subsets","text":"Subset Description","title":"Subsets"},{"location":"schema/delimiter/","text":"Slot: delimiter URI: linkmltr:delimiter Applicable Classes Name Description Modifies Slot StringificationConfiguration no Properties Range: String Examples Value , ; Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : delimiter examples : - value : ',' - value : '|' - value : ; from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : delimiter owner : StringificationConfiguration domain_of : - StringificationConfiguration range : string","title":"Slot: delimiter"},{"location":"schema/delimiter/#slot-delimiter","text":"URI: linkmltr:delimiter","title":"Slot: delimiter"},{"location":"schema/delimiter/#applicable-classes","text":"Name Description Modifies Slot StringificationConfiguration no","title":"Applicable Classes"},{"location":"schema/delimiter/#properties","text":"Range: String","title":"Properties"},{"location":"schema/delimiter/#examples","text":"Value , ;","title":"Examples"},{"location":"schema/delimiter/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/delimiter/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/delimiter/#linkml-source","text":"name : delimiter examples : - value : ',' - value : '|' - value : ; from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : delimiter owner : StringificationConfiguration domain_of : - StringificationConfiguration range : string","title":"LinkML Source"},{"location":"schema/derived_from/","text":"Slot: derived_from Source slots that are used to derive this slot. This can be computed from the expr, if the expr is declarative. URI: linkmltr:derived_from Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no Properties Range: SlotReference Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : derived_from description : Source slots that are used to derive this slot. This can be computed from the expr, if the expr is declarative. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : derived_from owner : SlotDerivation domain_of : - SlotDerivation range : SlotReference","title":"Slot: derived_from"},{"location":"schema/derived_from/#slot-derived_from","text":"Source slots that are used to derive this slot. This can be computed from the expr, if the expr is declarative. URI: linkmltr:derived_from","title":"Slot: derived_from"},{"location":"schema/derived_from/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no","title":"Applicable Classes"},{"location":"schema/derived_from/#properties","text":"Range: SlotReference Multivalued: True","title":"Properties"},{"location":"schema/derived_from/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/derived_from/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/derived_from/#linkml-source","text":"name : derived_from description : Source slots that are used to derive this slot. This can be computed from the expr, if the expr is declarative. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : derived_from owner : SlotDerivation domain_of : - SlotDerivation range : SlotReference","title":"LinkML Source"},{"location":"schema/description/","text":"Slot: description description of the specification component URI: dcterms:description Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no SpecificationComponent no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no TransformationSpecification A collection of mappings between source and target classes no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : SpecificationComponent domain_of : - SpecificationComponent","title":"Slot: description"},{"location":"schema/description/#slot-description","text":"description of the specification component URI: dcterms:description","title":"Slot: description"},{"location":"schema/description/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no SpecificationComponent no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no TransformationSpecification A collection of mappings between source and target classes no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/description/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/description/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/description/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/description/#linkml-source","text":"name : description description : description of the specification component from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:description alias : description owner : SpecificationComponent domain_of : - SpecificationComponent","title":"LinkML Source"},{"location":"schema/dictionary_key/","text":"Slot: dictionary_key URI: linkmltr:dictionary_key Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no Properties Range: String Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : dictionary_key from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : dictionary_key owner : SlotDerivation domain_of : - SlotDerivation range : string","title":"Slot: dictionary_key"},{"location":"schema/dictionary_key/#slot-dictionary_key","text":"URI: linkmltr:dictionary_key","title":"Slot: dictionary_key"},{"location":"schema/dictionary_key/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no","title":"Applicable Classes"},{"location":"schema/dictionary_key/#properties","text":"Range: String","title":"Properties"},{"location":"schema/dictionary_key/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/dictionary_key/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/dictionary_key/#linkml-source","text":"name : dictionary_key from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : dictionary_key owner : SlotDerivation domain_of : - SlotDerivation range : string","title":"LinkML Source"},{"location":"schema/element_name/","text":"Slot: element_name URI: linkmltr:element_name Applicable Classes Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no Properties Range: NONE Required: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : element_name from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : element_name owner : CopyDirective domain_of : - CopyDirective required : true","title":"Slot: element_name"},{"location":"schema/element_name/#slot-element_name","text":"URI: linkmltr:element_name","title":"Slot: element_name"},{"location":"schema/element_name/#applicable-classes","text":"Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no","title":"Applicable Classes"},{"location":"schema/element_name/#properties","text":"Range: NONE Required: True","title":"Properties"},{"location":"schema/element_name/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/element_name/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/element_name/#linkml-source","text":"name : element_name from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : element_name owner : CopyDirective domain_of : - CopyDirective required : true","title":"LinkML Source"},{"location":"schema/enum_derivations/","text":"Slot: enum_derivations Instructions on how to derive a set of enums in the target schema URI: linkmltr:enum_derivations Applicable Classes Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no Properties Range: EnumDerivation Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : enum_derivations description : Instructions on how to derive a set of enums in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : enum_derivations owner : TransformationSpecification domain_of : - TransformationSpecification range : EnumDerivation inlined : true","title":"Slot: enum_derivations"},{"location":"schema/enum_derivations/#slot-enum_derivations","text":"Instructions on how to derive a set of enums in the target schema URI: linkmltr:enum_derivations","title":"Slot: enum_derivations"},{"location":"schema/enum_derivations/#applicable-classes","text":"Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no","title":"Applicable Classes"},{"location":"schema/enum_derivations/#properties","text":"Range: EnumDerivation Multivalued: True","title":"Properties"},{"location":"schema/enum_derivations/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/enum_derivations/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/enum_derivations/#linkml-source","text":"name : enum_derivations description : Instructions on how to derive a set of enums in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : enum_derivations owner : TransformationSpecification domain_of : - TransformationSpecification range : EnumDerivation inlined : true","title":"LinkML Source"},{"location":"schema/exclude/","text":"Slot: exclude URI: linkmltr:exclude Applicable Classes Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no Properties Range: Any Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : exclude from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : exclude owner : CopyDirective domain_of : - CopyDirective range : Any","title":"Slot: exclude"},{"location":"schema/exclude/#slot-exclude","text":"URI: linkmltr:exclude","title":"Slot: exclude"},{"location":"schema/exclude/#applicable-classes","text":"Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no","title":"Applicable Classes"},{"location":"schema/exclude/#properties","text":"Range: Any","title":"Properties"},{"location":"schema/exclude/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/exclude/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/exclude/#linkml-source","text":"name : exclude from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : exclude owner : CopyDirective domain_of : - CopyDirective range : Any","title":"LinkML Source"},{"location":"schema/exclude_all/","text":"Slot: exclude_all URI: linkmltr:exclude_all Applicable Classes Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no Properties Range: Boolean Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : exclude_all from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : exclude_all owner : CopyDirective domain_of : - CopyDirective range : boolean","title":"Slot: exclude_all"},{"location":"schema/exclude_all/#slot-exclude_all","text":"URI: linkmltr:exclude_all","title":"Slot: exclude_all"},{"location":"schema/exclude_all/#applicable-classes","text":"Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no","title":"Applicable Classes"},{"location":"schema/exclude_all/#properties","text":"Range: Boolean","title":"Properties"},{"location":"schema/exclude_all/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/exclude_all/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/exclude_all/#linkml-source","text":"name : exclude_all from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : exclude_all owner : CopyDirective domain_of : - CopyDirective range : boolean","title":"LinkML Source"},{"location":"schema/expr/","text":"Slot: expr URI: linkmltr:expr Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no EnumDerivation A specification of how to derive the value of a target enum from a source enu... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no Properties Range: NONE Identifier and Mapping Information LinkML Source name : expr alias : expr domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation","title":"Slot: expr"},{"location":"schema/expr/#slot-expr","text":"URI: linkmltr:expr","title":"Slot: expr"},{"location":"schema/expr/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no EnumDerivation A specification of how to derive the value of a target enum from a source enu... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no","title":"Applicable Classes"},{"location":"schema/expr/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/expr/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/expr/#linkml-source","text":"name : expr alias : expr domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation","title":"LinkML Source"},{"location":"schema/expression_to_expression_mappings/","text":"Slot: expression_to_expression_mappings A mapping table in which the keys and values are expressions URI: linkmltr:expression_to_expression_mappings Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: KeyVal Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true","title":"Slot: expression_to_expression_mappings"},{"location":"schema/expression_to_expression_mappings/#slot-expression_to_expression_mappings","text":"A mapping table in which the keys and values are expressions URI: linkmltr:expression_to_expression_mappings","title":"Slot: expression_to_expression_mappings"},{"location":"schema/expression_to_expression_mappings/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/expression_to_expression_mappings/#properties","text":"Range: KeyVal Multivalued: True","title":"Properties"},{"location":"schema/expression_to_expression_mappings/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/expression_to_expression_mappings/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/expression_to_expression_mappings/#linkml-source","text":"name : expression_to_expression_mappings description : A mapping table in which the keys and values are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_expression_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true","title":"LinkML Source"},{"location":"schema/expression_to_value_mappings/","text":"Slot: expression_to_value_mappings A mapping table in which the keys are expressions URI: linkmltr:expression_to_value_mappings Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: KeyVal Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true","title":"Slot: expression_to_value_mappings"},{"location":"schema/expression_to_value_mappings/#slot-expression_to_value_mappings","text":"A mapping table in which the keys are expressions URI: linkmltr:expression_to_value_mappings","title":"Slot: expression_to_value_mappings"},{"location":"schema/expression_to_value_mappings/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/expression_to_value_mappings/#properties","text":"Range: KeyVal Multivalued: True","title":"Properties"},{"location":"schema/expression_to_value_mappings/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/expression_to_value_mappings/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/expression_to_value_mappings/#linkml-source","text":"name : expression_to_value_mappings description : A mapping table in which the keys are expressions from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : expression_to_value_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true","title":"LinkML Source"},{"location":"schema/faq/","text":"FAQ Why another framework? There are a number of excellent frameworks for performing mapping and data transformations. The LinkML Transformer framework was born out of a need for a framework that: was not inherently tied to: a particular serialization format (e.g. RDF, JSON, ...) a particular programming language (e.g. Python, Java, ...) a particular database system or database language (e.g. PostgreSQL or SQL or SPARQL) not tied to a particular kind of transformation (e.g. ORM or Tables to RDF) was a natural fit for the LinkML data modeling framework was declarative and easy to perform machine reasoning over is simple for simple use cases In its current state, this framework is less powerful and expressive than many other frameworks or methodologies for performing transformations. If you need to perform complex data transformations, you might be better off using an expressive query language like SPARQL or SQL, or even just coding transformations directly in a programming language or library like Python or Pandas (but note that even for the coding use case, the LinkML Transformer framework can be useful as a standard way of documenting transformations). Currently the main use case for this framework is mostly isomorphic transformations, with lightweight manipulations. These lend themselves well to a declarative framework. Uses cases that are a particularly good fit involve mapping between data-dictionary like standards, with large numbers of metadata elements, where these elements can often be mapped one-to-one, or with simple manipulations (e.g. unit conversions). The origins lie partly in the SSSOM standard, which is intended as an ultra-simple way of specifying precise mappings between entities (e.g. schema.org Person is the same as DBPedia person). We observed that many people wanted to extend the language to perform more complex mappings. To address this, we help a workshop at the Biocuration conference in Padua, Italy in 2022. Discussion SSSOM paper SSSOM Update 2023 SSSOM Complex Mappings Workshop 2023 Mapping Data Structures: Challenges and Approaches","title":"FAQ"},{"location":"schema/faq/#faq","text":"","title":"FAQ"},{"location":"schema/faq/#why-another-framework","text":"There are a number of excellent frameworks for performing mapping and data transformations. The LinkML Transformer framework was born out of a need for a framework that: was not inherently tied to: a particular serialization format (e.g. RDF, JSON, ...) a particular programming language (e.g. Python, Java, ...) a particular database system or database language (e.g. PostgreSQL or SQL or SPARQL) not tied to a particular kind of transformation (e.g. ORM or Tables to RDF) was a natural fit for the LinkML data modeling framework was declarative and easy to perform machine reasoning over is simple for simple use cases In its current state, this framework is less powerful and expressive than many other frameworks or methodologies for performing transformations. If you need to perform complex data transformations, you might be better off using an expressive query language like SPARQL or SQL, or even just coding transformations directly in a programming language or library like Python or Pandas (but note that even for the coding use case, the LinkML Transformer framework can be useful as a standard way of documenting transformations). Currently the main use case for this framework is mostly isomorphic transformations, with lightweight manipulations. These lend themselves well to a declarative framework. Uses cases that are a particularly good fit involve mapping between data-dictionary like standards, with large numbers of metadata elements, where these elements can often be mapped one-to-one, or with simple manipulations (e.g. unit conversions). The origins lie partly in the SSSOM standard, which is intended as an ultra-simple way of specifying precise mappings between entities (e.g. schema.org Person is the same as DBPedia person). We observed that many people wanted to extend the language to perform more complex mappings. To address this, we help a workshop at the Biocuration conference in Padua, Italy in 2022. Discussion SSSOM paper SSSOM Update 2023 SSSOM Complex Mappings Workshop 2023 Mapping Data Structures: Challenges and Approaches","title":"Why another framework?"},{"location":"schema/functions/","text":"Functions Package Unit Conversion Basic unit conversion functions. Currently only native pint units or UCUM units are supported. For UCUM, the ucumvert library is used to convert UCUM units to pint units, see <https://github.com/dalito/ucumvert> _. DimensionalityError Bases: Exception Raised when a unit conversion cannot be performed. Note: equivalent to the pint error, but the pint dependency is optional Source code in src\\linkml_map\\functions\\unit_conversion.py 47 48 49 50 51 52 53 class DimensionalityError ( Exception ): \"\"\" Raised when a unit conversion cannot be performed. Note: equivalent to the pint error, but the pint dependency is optional \"\"\" QuantitySyntaxError Bases: Exception Raised when a quantity cannot be parsed. Source code in src\\linkml_map\\functions\\unit_conversion.py 41 42 43 44 class QuantitySyntaxError ( Exception ): \"\"\" Raised when a quantity cannot be parsed. \"\"\" UndefinedUnitError Bases: Exception Raised when a unit is not defined. Note: equivalent to the pint error, but the pint dependency is optional Source code in src\\linkml_map\\functions\\unit_conversion.py 32 33 34 35 36 37 38 class UndefinedUnitError ( Exception ): \"\"\" Raised when a unit is not defined. Note: equivalent to the pint error, but the pint dependency is optional \"\"\" UnitSystem Bases: str , Enum Enumeration of supported unit systems. Source code in src\\linkml_map\\functions\\unit_conversion.py 19 20 21 22 23 24 class UnitSystem ( str , Enum ): \"\"\"Enumeration of supported unit systems.\"\"\" UCUM = \"ucum\" IEC61360 = \"iec61360\" SI = \"SI\" convert_units ( magnitude , from_unit , to_unit , system = None ) Convert a quantity between units. convert_units(1, \"m\", \"cm\") 100.0 convert_units(1, \"m\", \"cm\", system=UnitSystem.UCUM) 100.0 convert_units(1, \"m\", \"cm\", system=UnitSystem.SI) 100.0 convert_units(1.0, \"hectare\", \"m^2\", system=UnitSystem.SI) 10000.0 convert_units(1.0, \"hectare\", \"m ** 2\", system=UnitSystem.SI) 10000.0 convert_units(1.0, \"hectare\", \"m ** 2\", system=None) 10000.0 convert_units(1.0, \"km2\", \"m2\", system=UnitSystem.UCUM) 1000000.0 :param magnitude: :param from_unit: :param to_unit: :return: converted magnitude Source code in src\\linkml_map\\functions\\unit_conversion.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def convert_units ( magnitude : float , from_unit : str , to_unit : str , system : Optional [ UnitSystem ] = None ): \"\"\" Convert a quantity between units. >>> convert_units(1, \"m\", \"cm\") 100.0 >>> convert_units(1, \"m\", \"cm\", system=UnitSystem.UCUM) 100.0 >>> convert_units(1, \"m\", \"cm\", system=UnitSystem.SI) 100.0 >>> convert_units(1.0, \"hectare\", \"m^2\", system=UnitSystem.SI) 10000.0 >>> convert_units(1.0, \"hectare\", \"m ** 2\", system=UnitSystem.SI) 10000.0 >>> convert_units(1.0, \"hectare\", \"m ** 2\", system=None) 10000.0 >>> convert_units(1.0, \"km2\", \"m2\", system=UnitSystem.UCUM) 1000000.0 :param magnitude: :param from_unit: :param to_unit: :return: converted magnitude \"\"\" import pint ureg : pint . UnitRegistry = get_unit_registry ( system ) from_unit = normalize_unit ( from_unit , system ) to_unit = normalize_unit ( to_unit , system ) try : from_unit_q = ureg . parse_units ( from_unit ) except lark . exceptions . UnexpectedCharacters : raise UndefinedUnitError ( f \"Cannot parse unit: { from_unit } \" ) except pint . errors . UndefinedUnitError : raise UndefinedUnitError ( f \"Unknown source unit: { from_unit } \" ) quantity = magnitude * from_unit_q try : return quantity . to ( to_unit ) . magnitude except pint . errors . UndefinedUnitError : raise UndefinedUnitError ( f \"Unknown target unit: { from_unit } \" ) except pint . errors . DimensionalityError : raise DimensionalityError ( f \"Cannot convert from { from_unit } to { to_unit } \" ) get_unit_registry ( system = None ) cached Get a unit registry. ureg = get_unit_registry(UnitSystem.UCUM) ureg.from_ucum(\"m/s2.kg\") str( ) '1.0 kilogram * meter / second ** 2' ureg.from_ucum(\"m[H2O]{35Cel}\") # UCUM code with annotation .to(\"mbar\") ureg(\"degC\") # a standard pint unit ureg.from_ucum(\"g/m2\") _.to(ureg.from_ucum(\"kg/m2\")) ureg.from_ucum(\"nmol/mmol{Cre}\") sireg = get_unit_registry(UnitSystem.SI) sireg(\"degC\") sireg(\"ha\") :param system: currently only supported values are None or UnitSystem.UCUM :return: Source code in src\\linkml_map\\functions\\unit_conversion.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 @lru_cache () def get_unit_registry ( system : Optional [ UnitSystem ] = None ) -> Any : \"\"\" Get a unit registry. >>> ureg = get_unit_registry(UnitSystem.UCUM) >>> ureg.from_ucum(\"m/s2.kg\") <Quantity(1.0, 'meter * kilogram / second ** 2')> >>> str(_) '1.0 kilogram * meter / second ** 2' >>> ureg.from_ucum(\"m[H2O]{35Cel}\") # UCUM code with annotation <Quantity(1, 'm_H2O')> >>> _.to(\"mbar\") <Quantity(98.0665, 'millibar')> >>> ureg(\"degC\") # a standard pint unit <Quantity(1, 'degree_Celsius')> >>> ureg.from_ucum(\"g/m2\") <Quantity(1.0, 'gram / meter ** 2')> >>> _.to(ureg.from_ucum(\"kg/m2\")) <Quantity(0.001, 'kilogram / meter ** 2')> >>> ureg.from_ucum(\"nmol/mmol{Cre}\") <Quantity(1.0, 'nanomole / millimole')> >>> sireg = get_unit_registry(UnitSystem.SI) >>> sireg(\"degC\") <Quantity(1, 'degree_Celsius')> >>> sireg(\"ha\") <Quantity(1, 'hectare')> :param system: currently only supported values are None or UnitSystem.UCUM :return: \"\"\" import pint ureg = pint . UnitRegistry () if not system : return ureg if system in REGISTRIES : return REGISTRIES [ system ] if system . value in dir ( ureg . sys ): ureg . default_system = system . value return ureg raise NotImplementedError ( f \"Unknown unit system: { system } \" )","title":"Functions Package"},{"location":"schema/functions/#functions-package","text":"","title":"Functions Package"},{"location":"schema/functions/#unit-conversion","text":"Basic unit conversion functions. Currently only native pint units or UCUM units are supported. For UCUM, the ucumvert library is used to convert UCUM units to pint units, see <https://github.com/dalito/ucumvert> _.","title":"Unit Conversion"},{"location":"schema/functions/#linkml_map.functions.unit_conversion.DimensionalityError","text":"Bases: Exception Raised when a unit conversion cannot be performed. Note: equivalent to the pint error, but the pint dependency is optional Source code in src\\linkml_map\\functions\\unit_conversion.py 47 48 49 50 51 52 53 class DimensionalityError ( Exception ): \"\"\" Raised when a unit conversion cannot be performed. Note: equivalent to the pint error, but the pint dependency is optional \"\"\"","title":"DimensionalityError"},{"location":"schema/functions/#linkml_map.functions.unit_conversion.QuantitySyntaxError","text":"Bases: Exception Raised when a quantity cannot be parsed. Source code in src\\linkml_map\\functions\\unit_conversion.py 41 42 43 44 class QuantitySyntaxError ( Exception ): \"\"\" Raised when a quantity cannot be parsed. \"\"\"","title":"QuantitySyntaxError"},{"location":"schema/functions/#linkml_map.functions.unit_conversion.UndefinedUnitError","text":"Bases: Exception Raised when a unit is not defined. Note: equivalent to the pint error, but the pint dependency is optional Source code in src\\linkml_map\\functions\\unit_conversion.py 32 33 34 35 36 37 38 class UndefinedUnitError ( Exception ): \"\"\" Raised when a unit is not defined. Note: equivalent to the pint error, but the pint dependency is optional \"\"\"","title":"UndefinedUnitError"},{"location":"schema/functions/#linkml_map.functions.unit_conversion.UnitSystem","text":"Bases: str , Enum Enumeration of supported unit systems. Source code in src\\linkml_map\\functions\\unit_conversion.py 19 20 21 22 23 24 class UnitSystem ( str , Enum ): \"\"\"Enumeration of supported unit systems.\"\"\" UCUM = \"ucum\" IEC61360 = \"iec61360\" SI = \"SI\"","title":"UnitSystem"},{"location":"schema/functions/#linkml_map.functions.unit_conversion.convert_units","text":"Convert a quantity between units. convert_units(1, \"m\", \"cm\") 100.0 convert_units(1, \"m\", \"cm\", system=UnitSystem.UCUM) 100.0 convert_units(1, \"m\", \"cm\", system=UnitSystem.SI) 100.0 convert_units(1.0, \"hectare\", \"m^2\", system=UnitSystem.SI) 10000.0 convert_units(1.0, \"hectare\", \"m ** 2\", system=UnitSystem.SI) 10000.0 convert_units(1.0, \"hectare\", \"m ** 2\", system=None) 10000.0 convert_units(1.0, \"km2\", \"m2\", system=UnitSystem.UCUM) 1000000.0 :param magnitude: :param from_unit: :param to_unit: :return: converted magnitude Source code in src\\linkml_map\\functions\\unit_conversion.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def convert_units ( magnitude : float , from_unit : str , to_unit : str , system : Optional [ UnitSystem ] = None ): \"\"\" Convert a quantity between units. >>> convert_units(1, \"m\", \"cm\") 100.0 >>> convert_units(1, \"m\", \"cm\", system=UnitSystem.UCUM) 100.0 >>> convert_units(1, \"m\", \"cm\", system=UnitSystem.SI) 100.0 >>> convert_units(1.0, \"hectare\", \"m^2\", system=UnitSystem.SI) 10000.0 >>> convert_units(1.0, \"hectare\", \"m ** 2\", system=UnitSystem.SI) 10000.0 >>> convert_units(1.0, \"hectare\", \"m ** 2\", system=None) 10000.0 >>> convert_units(1.0, \"km2\", \"m2\", system=UnitSystem.UCUM) 1000000.0 :param magnitude: :param from_unit: :param to_unit: :return: converted magnitude \"\"\" import pint ureg : pint . UnitRegistry = get_unit_registry ( system ) from_unit = normalize_unit ( from_unit , system ) to_unit = normalize_unit ( to_unit , system ) try : from_unit_q = ureg . parse_units ( from_unit ) except lark . exceptions . UnexpectedCharacters : raise UndefinedUnitError ( f \"Cannot parse unit: { from_unit } \" ) except pint . errors . UndefinedUnitError : raise UndefinedUnitError ( f \"Unknown source unit: { from_unit } \" ) quantity = magnitude * from_unit_q try : return quantity . to ( to_unit ) . magnitude except pint . errors . UndefinedUnitError : raise UndefinedUnitError ( f \"Unknown target unit: { from_unit } \" ) except pint . errors . DimensionalityError : raise DimensionalityError ( f \"Cannot convert from { from_unit } to { to_unit } \" )","title":"convert_units"},{"location":"schema/functions/#linkml_map.functions.unit_conversion.get_unit_registry","text":"Get a unit registry. ureg = get_unit_registry(UnitSystem.UCUM) ureg.from_ucum(\"m/s2.kg\") str( ) '1.0 kilogram * meter / second ** 2' ureg.from_ucum(\"m[H2O]{35Cel}\") # UCUM code with annotation .to(\"mbar\") ureg(\"degC\") # a standard pint unit ureg.from_ucum(\"g/m2\") _.to(ureg.from_ucum(\"kg/m2\")) ureg.from_ucum(\"nmol/mmol{Cre}\") sireg = get_unit_registry(UnitSystem.SI) sireg(\"degC\") sireg(\"ha\") :param system: currently only supported values are None or UnitSystem.UCUM :return: Source code in src\\linkml_map\\functions\\unit_conversion.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 @lru_cache () def get_unit_registry ( system : Optional [ UnitSystem ] = None ) -> Any : \"\"\" Get a unit registry. >>> ureg = get_unit_registry(UnitSystem.UCUM) >>> ureg.from_ucum(\"m/s2.kg\") <Quantity(1.0, 'meter * kilogram / second ** 2')> >>> str(_) '1.0 kilogram * meter / second ** 2' >>> ureg.from_ucum(\"m[H2O]{35Cel}\") # UCUM code with annotation <Quantity(1, 'm_H2O')> >>> _.to(\"mbar\") <Quantity(98.0665, 'millibar')> >>> ureg(\"degC\") # a standard pint unit <Quantity(1, 'degree_Celsius')> >>> ureg.from_ucum(\"g/m2\") <Quantity(1.0, 'gram / meter ** 2')> >>> _.to(ureg.from_ucum(\"kg/m2\")) <Quantity(0.001, 'kilogram / meter ** 2')> >>> ureg.from_ucum(\"nmol/mmol{Cre}\") <Quantity(1.0, 'nanomole / millimole')> >>> sireg = get_unit_registry(UnitSystem.SI) >>> sireg(\"degC\") <Quantity(1, 'degree_Celsius')> >>> sireg(\"ha\") <Quantity(1, 'hectare')> :param system: currently only supported values are None or UnitSystem.UCUM :return: \"\"\" import pint ureg = pint . UnitRegistry () if not system : return ureg if system in REGISTRIES : return REGISTRIES [ system ] if system . value in dir ( ureg . sys ): ureg . default_system = system . value return ureg raise NotImplementedError ( f \"Unknown unit system: { system } \" )","title":"get_unit_registry"},{"location":"schema/hide/","text":"Slot: hide URI: linkmltr:hide Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no EnumDerivation A specification of how to derive the value of a target enum from a source enu... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no Properties Range: NONE Identifier and Mapping Information LinkML Source name : hide alias : hide domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation","title":"Slot: hide"},{"location":"schema/hide/#slot-hide","text":"URI: linkmltr:hide","title":"Slot: hide"},{"location":"schema/hide/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no EnumDerivation A specification of how to derive the value of a target enum from a source enu... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no","title":"Applicable Classes"},{"location":"schema/hide/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/hide/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/hide/#linkml-source","text":"name : hide alias : hide domain_of : - SlotDerivation - EnumDerivation - PermissibleValueDerivation","title":"LinkML Source"},{"location":"schema/id/","text":"Slot: id Unique identifier for this transformation specification URI: schema:identifier Applicable Classes Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : id description : Unique identifier for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : schema:identifier alias : id owner : TransformationSpecification domain_of : - TransformationSpecification","title":"Slot: id"},{"location":"schema/id/#slot-id","text":"Unique identifier for this transformation specification URI: schema:identifier","title":"Slot: id"},{"location":"schema/id/#applicable-classes","text":"Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no","title":"Applicable Classes"},{"location":"schema/id/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/id/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/id/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/id/#linkml-source","text":"name : id description : Unique identifier for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : schema:identifier alias : id owner : TransformationSpecification domain_of : - TransformationSpecification","title":"LinkML Source"},{"location":"schema/implements/","text":"Slot: implements A reference to a specification that this component implements. URI: linkmltr:implements Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no SpecificationComponent no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no TransformationSpecification A collection of mappings between source and target classes no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: Uriorcurie Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : SpecificationComponent domain_of : - SpecificationComponent range : uriorcurie","title":"Slot: implements"},{"location":"schema/implements/#slot-implements","text":"A reference to a specification that this component implements. URI: linkmltr:implements","title":"Slot: implements"},{"location":"schema/implements/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no SpecificationComponent no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no TransformationSpecification A collection of mappings between source and target classes no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/implements/#properties","text":"Range: Uriorcurie Multivalued: True","title":"Properties"},{"location":"schema/implements/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/implements/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/implements/#linkml-source","text":"name : implements description : A reference to a specification that this component implements. from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : implements owner : SpecificationComponent domain_of : - SpecificationComponent range : uriorcurie","title":"LinkML Source"},{"location":"schema/include/","text":"Slot: include URI: linkmltr:include Applicable Classes Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no Properties Range: Any Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : include from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : include owner : CopyDirective domain_of : - CopyDirective range : Any","title":"Slot: include"},{"location":"schema/include/#slot-include","text":"URI: linkmltr:include","title":"Slot: include"},{"location":"schema/include/#applicable-classes","text":"Name Description Modifies Slot CopyDirective Instructs a Schema Mapper in how to map to a target schema no","title":"Applicable Classes"},{"location":"schema/include/#properties","text":"Range: Any","title":"Properties"},{"location":"schema/include/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/include/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/include/#linkml-source","text":"name : include from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : include owner : CopyDirective domain_of : - CopyDirective range : Any","title":"LinkML Source"},{"location":"schema/inverse_of/","text":"Slot: inverse_of Used to specify a class-slot tuple that is the inverse of the derived/target slot. This is used primarily for mapping to relational databases or formalisms that do not allow multiple values. The class representing the repeated element has a foreign key slot inserted in that 'back references' the original multivalued slot. URI: linkmltr:inverse_of Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no Properties Range: Inverse Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : inverse_of description : Used to specify a class-slot tuple that is the inverse of the derived/target slot. This is used primarily for mapping to relational databases or formalisms that do not allow multiple values. The class representing the repeated element has a foreign key slot inserted in that 'back references' the original multivalued slot. from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : inverse_of owner : SlotDerivation domain_of : - SlotDerivation range : Inverse","title":"Slot: inverse_of"},{"location":"schema/inverse_of/#slot-inverse_of","text":"Used to specify a class-slot tuple that is the inverse of the derived/target slot. This is used primarily for mapping to relational databases or formalisms that do not allow multiple values. The class representing the repeated element has a foreign key slot inserted in that 'back references' the original multivalued slot. URI: linkmltr:inverse_of","title":"Slot: inverse_of"},{"location":"schema/inverse_of/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no","title":"Applicable Classes"},{"location":"schema/inverse_of/#properties","text":"Range: Inverse","title":"Properties"},{"location":"schema/inverse_of/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/inverse_of/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/inverse_of/#linkml-source","text":"name : inverse_of description : Used to specify a class-slot tuple that is the inverse of the derived/target slot. This is used primarily for mapping to relational databases or formalisms that do not allow multiple values. The class representing the repeated element has a foreign key slot inserted in that 'back references' the original multivalued slot. from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : inverse_of owner : SlotDerivation domain_of : - SlotDerivation range : Inverse","title":"LinkML Source"},{"location":"schema/is_a/","text":"Slot: is_a URI: linkml:is_a Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: ElementDerivation Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : ElementDerivation domain_of : - ElementDerivation range : ElementDerivation","title":"Slot: is_a"},{"location":"schema/is_a/#slot-is_a","text":"URI: linkml:is_a","title":"Slot: is_a"},{"location":"schema/is_a/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/is_a/#properties","text":"Range: ElementDerivation","title":"Properties"},{"location":"schema/is_a/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/is_a/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/is_a/#linkml-source","text":"name : is_a from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:is_a alias : is_a owner : ElementDerivation domain_of : - ElementDerivation range : ElementDerivation","title":"LinkML Source"},{"location":"schema/joins/","text":"Slot: joins Additional classes to be joined to derive instances of the target class URI: linkmltr:joins Applicable Classes Name Description Modifies Slot ClassDerivation A specification of how to derive a target class from a source class no Properties Range: AliasedClass Multivalued: True Comments not yet implemented Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : joins description : Additional classes to be joined to derive instances of the target class comments : - not yet implemented from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : joins owner : ClassDerivation domain_of : - ClassDerivation range : AliasedClass inlined : true","title":"Slot: joins"},{"location":"schema/joins/#slot-joins","text":"Additional classes to be joined to derive instances of the target class URI: linkmltr:joins","title":"Slot: joins"},{"location":"schema/joins/#applicable-classes","text":"Name Description Modifies Slot ClassDerivation A specification of how to derive a target class from a source class no","title":"Applicable Classes"},{"location":"schema/joins/#properties","text":"Range: AliasedClass Multivalued: True","title":"Properties"},{"location":"schema/joins/#comments","text":"not yet implemented","title":"Comments"},{"location":"schema/joins/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/joins/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/joins/#linkml-source","text":"name : joins description : Additional classes to be joined to derive instances of the target class comments : - not yet implemented from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : joins owner : ClassDerivation domain_of : - ClassDerivation range : AliasedClass inlined : true","title":"LinkML Source"},{"location":"schema/key/","text":"Slot: key URI: linkmltr:key Applicable Classes Name Description Modifies Slot KeyVal no Properties Range: NONE Required: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : key from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : key owner : KeyVal domain_of : - KeyVal required : true","title":"Slot: key"},{"location":"schema/key/#slot-key","text":"URI: linkmltr:key","title":"Slot: key"},{"location":"schema/key/#applicable-classes","text":"Name Description Modifies Slot KeyVal no","title":"Applicable Classes"},{"location":"schema/key/#properties","text":"Range: NONE Required: True","title":"Properties"},{"location":"schema/key/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/key/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/key/#linkml-source","text":"name : key from_schema : https://w3id.org/linkml/transformer rank : 1000 key : true alias : key owner : KeyVal domain_of : - KeyVal required : true","title":"LinkML Source"},{"location":"schema/linkml-map/","text":"linkml-map Datamodel for LinkML schema mappings and transformations. A mapper generates instances of a target data model from instances of a source data model. This transformation process is guided by a TransformationSpecification . The specification is independent of any one method for transforming data. It allows different approaches, including: direct implementation, transforming python or json objects translation of the specification into SQL commands, to operate on relations translation of the specification into SPARQL CONSTRUCTs, to operate on triples translation into another specification language, such as R2RML URI: https://w3id.org/linkml/transformer","title":"linkml-map"},{"location":"schema/linkml-map/#linkml-map","text":"Datamodel for LinkML schema mappings and transformations. A mapper generates instances of a target data model from instances of a source data model. This transformation process is guided by a TransformationSpecification . The specification is independent of any one method for transforming data. It allows different approaches, including: direct implementation, transforming python or json objects translation of the specification into SQL commands, to operate on relations translation of the specification into SPARQL CONSTRUCTs, to operate on triples translation into another specification language, such as R2RML URI: https://w3id.org/linkml/transformer","title":"linkml-map"},{"location":"schema/mirror_source/","text":"Slot: mirror_source URI: linkmltr:mirror_source Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: Boolean Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : ElementDerivation domain_of : - ElementDerivation range : boolean","title":"Slot: mirror_source"},{"location":"schema/mirror_source/#slot-mirror_source","text":"URI: linkmltr:mirror_source","title":"Slot: mirror_source"},{"location":"schema/mirror_source/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/mirror_source/#properties","text":"Range: Boolean","title":"Properties"},{"location":"schema/mirror_source/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/mirror_source/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/mirror_source/#linkml-source","text":"name : mirror_source from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : mirror_source owner : ElementDerivation domain_of : - ElementDerivation range : boolean","title":"LinkML Source"},{"location":"schema/mixins/","text":"Slot: mixins URI: linkml:mixins Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: ElementDerivation Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : ElementDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false","title":"Slot: mixins"},{"location":"schema/mixins/#slot-mixins","text":"URI: linkml:mixins","title":"Slot: mixins"},{"location":"schema/mixins/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/mixins/#properties","text":"Range: ElementDerivation Multivalued: True","title":"Properties"},{"location":"schema/mixins/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/mixins/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/mixins/#linkml-source","text":"name : mixins from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:mixins multivalued : true alias : mixins owner : ElementDerivation domain_of : - ElementDerivation range : ElementDerivation inlined : false","title":"LinkML Source"},{"location":"schema/name/","text":"Slot: name URI: linkmltr:name Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: NONE Identifier and Mapping Information LinkML Source name : name alias : name domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation","title":"Slot: name"},{"location":"schema/name/#slot-name","text":"URI: linkmltr:name","title":"Slot: name"},{"location":"schema/name/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/name/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/name/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/name/#linkml-source","text":"name : name alias : name domain_of : - ElementDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation","title":"LinkML Source"},{"location":"schema/over_slots/","text":"Slot: over_slots URI: linkmltr:over_slots Applicable Classes Name Description Modifies Slot StringificationConfiguration no Properties Range: String Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : over_slots from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : over_slots owner : StringificationConfiguration domain_of : - StringificationConfiguration range : string","title":"Slot: over_slots"},{"location":"schema/over_slots/#slot-over_slots","text":"URI: linkmltr:over_slots","title":"Slot: over_slots"},{"location":"schema/over_slots/#applicable-classes","text":"Name Description Modifies Slot StringificationConfiguration no","title":"Applicable Classes"},{"location":"schema/over_slots/#properties","text":"Range: String Multivalued: True","title":"Properties"},{"location":"schema/over_slots/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/over_slots/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/over_slots/#linkml-source","text":"name : over_slots from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : over_slots owner : StringificationConfiguration domain_of : - StringificationConfiguration range : string","title":"LinkML Source"},{"location":"schema/overrides/","text":"Slot: overrides overrides source schema slots URI: linkmltr:overrides Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: Any Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : ElementDerivation domain_of : - ElementDerivation range : Any","title":"Slot: overrides"},{"location":"schema/overrides/#slot-overrides","text":"overrides source schema slots URI: linkmltr:overrides","title":"Slot: overrides"},{"location":"schema/overrides/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/overrides/#properties","text":"Range: Any","title":"Properties"},{"location":"schema/overrides/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/overrides/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/overrides/#linkml-source","text":"name : overrides description : overrides source schema slots from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : overrides owner : ElementDerivation domain_of : - ElementDerivation range : Any","title":"LinkML Source"},{"location":"schema/overview/","text":"Mapping Between LinkML Schemas Draft 2022-06-24 Problem: map data from one schema to another Problem: Map d1 \u2192 d2 Assumption d1 and d2 conform to two separate schemas\\, s1\u2192 s2 Sub-problems: Ingest/Import: my data warehouse conforms to s2 (e.g. Monarch ingest) Export: make my data ingest friendly Migrations: s1 and s2 are different versions of the same schema Not in scope: in-schema syntactic or structural transforms JSON to YAML\\, JSON to TSV\\, JSON to SQL\\, JSON to RDF\\, ORM\\, \u2026 In LinkML this is already largely solved The actual problem space is highly varied S1 and S2 may be trivially isomorphic S1 and S2 may differ in complex or nuanced ways There are many existing approaches Generic frameworks\\, driven by declarative specification in Domain Specific Language (DSL) JSON-based Google whistle jsonpath-lift XSLT Semweb YARRML\\, R2RML Many many more\u2026 Bespoke transforms: non-declarative Implement in python/awk/etc. Hybrid: bespoke with some declarative mappings in ad-hoc format E.g. NMDC ingest framework Traps with declarative mapping Declarative is great\\, until it\u2019s not Anti-patterns: Insufficient expressivity to carry out real world tasks Bolting on features to mapping DSL until it\u2019s a fully-featured Turing-complete language Optimization/scalability at mercy of framework Messy layering between DSL and host language It can be useful to leverage host language features (e.g arbitrary python function) But this can get confusing: NFNF: Neither fish nor fowl Limits optimizations (forces iterative host language calls) YARRRML https://rml.io/yarrrml/ YARRRML notes Has a playground\\, which is great Mixes two concerns: 1. Isomorphic structural mapping between JSON/TSVs and RDF (already covered by JSON-LD) 2. Mapping This isn\u2019t necessarily bad - it\u2019s quite practical\\, but a little unsatisfying IMO jsonpath-lifter Was proposed for CCDH CRDC-node mappings Doesn\u2019t seem widely used Is there a big advantage over simply writing javascript functions? Koza (previously: bioweave) ETL frameworks There are many many ETL frameworks E.g. WebKarma Inherently mixing of concerns Here we are concerned with the \u201cT\u201d part Do existing frameworks separate out the T as a modular composable component? I\u2019m not sure Do we need Yet Another Mapping Framework? LinkML philosophy: Embrace\\, extend\\, parasitize Develop lightweight ways to map Map mappings to existing mapping frameworks This actually makes sense even if it sounds kind of meta\u2026 Level 0 Mapping: Isomorphic, same URIs classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address classes: Agent: class_uri: sdo:Person attributes: surname: slot_uri: sdo:familyName home_address: slot_uri: sdo:address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville Level 0: handled by standard linkml convert to/from RDF classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address classes: Agent: class_uri: sdo:Person attributes: surname: slot_uri: sdo:familyName home_address: slot_uri: sdo:address data2 (yaml/json) d ata1 (yaml/json) family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville d ata1.ttl == data2.ttl [sdo:familyName \u201cWu\u201d ; sdo:address \u201c1 my street\\, Oakville\u201d ] Level 0: Enums TODO: add example here. Basically this works the same way Level 0: HOWTO Compose two commands: linkml-convert -s schema1.yaml data1.yaml -o data1.ttl linkml-convert -s schema2.yaml data1.ttl -o data2.yaml That\u2019s it! TODO: Write a wrapper (linkml-map-data?) that does this in one command Level 0: other considerations Going via RDF in theory eliminates inlining differences E.g. s1 inlines address objects\\, s2 uses references (inlined: false) and includes a separate index slot for addresses Current status: Currently when going from s1 to s2\\, no index slots are generated This could be done as part of the general rdflib framework Lessons learned so far: annotate your schema with URIs! Annotating schemas with URIs is optional with LinkML But your future self and data users will thank you for careful schema annotation! Hints: Schema-automator can provide suggestions for your element and enum URIs Sometimes plain semweb URIs (e.g. schema.org) can be easier for interoperation than overly granular OBO ones E.g modeling Personhood as a role vs straightforward schema:Person Level 1 Mapping: Isomorphic, different URIs name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville Level 1 Mapping: mediated by URI mapping name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address subject_id object_id sdo:Person NCBITaxon:9606 sdo:familyName IAO:nnnn sdo:address IAO:0000422 family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville [sdo:familyName \u201cWu\u201d sdo:address \u201c1 my street\\, Oakville\u201d ] [sdo:familyName \u201cWu\u201d sdo:address \u201c1 my street\\, Oakville\u201d ] Level 1: HOWTO Compose three commands: linkml-convert -s schema1.yaml data1.yaml -o data1.ttl sssom-map-iris -i data1.ttl -m schema1-to-schema2.sssom.tsv -o data2.ttl linkml-convert -s schema2.yaml data2.ttl -o data2.yaml That\u2019s it! TODO: sssom-map-iris does not yet exist (?)\\, but should be trivial Fold into wrapper CLI tool Nuances: Schemas have nuanced differences: not everything with be skos:exact We can distinguish 3 flavors of level 1 mapping: Precise\\, bidirectional: follow exact only Valid\\, unidirectional: follow exact + broad Loose: any mapping Level 1 variant: mappings in schema name: example-semweb-schema classes: Person: class_uri: sdo:Person __ __ exact_mappings: [\u201cNCBITaxon:9606\u201d] attributes: family_name: slot_uri: sdo:familyName __ exact_mappings: [\u201cIAO:nnnn\u201d]__ address: slot_uri: sdo:address __ exact_mappings: [\u201cIAO:0000422\u201d]__ name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville [sdo:familyName \u201cWu\u201d sdo:address \u201c1 my street\\, Oakville\u201d ] [sdo:familyName \u201cWu\u201d sdo:address \u201c1 my street\\, Oakville\u201d ] Advantages of RDF as an intermediate Use of IRIs Separation of concerns Structural differences (e.g. inlining) are already handled by linkml convert Allows us to focus on semantic mappings Lessons learned so far: think about mappings https://linkml.io/linkml/faq/modeling.html#when-is-it-important-to-have-mappings https://github.com/alliance-genome/agr_curation_schema/blob/main/model/schema/agent.yaml More complex mappings: level 2 and above TODO: define levels 2 and above Examples of kinds of features: merging/splitting fields; e.g. full_name = first + \u201c \u201c + last Unit conversion or baked-in units to explicit units Normalization/denormalization (aka flattening) Complex logic If conditions A\\, B\\, C and not D are met then copy field F from X to Y LinkML Rule and Inference Framework Current use case is intra-schema inference Easy to invoke on command line Needs more docs! Could form basis of inter-schema DSL Examples Schemas differ in units Schemas differ in categorical vs quantitative Current use case is intra-schema inference Could form basis of inter-schema DSL Datalog Datalog could serve as the powerful basis of an expressive declarative transformation language https://linkml.io/linkml-datalog Approach for level 2+ Do we even want a generic mapping framework in LinkML here? This is a good \u201c parasitization hook\u201d Do complex stuff using an existing framework TBD: derive or semi-derive mapping specification? This is also a code bespoke procedural code hook Do the generic stuff with linkml-convert and isomorphic IRI mapping Do more complex stuff in code General approach for level 2+; same to same name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville JSON OR XML OR YAML OR RDF OR SQL JSON __ OR __ XML __ OR __ YAML __ OR __ RDF __ OR __ SQL (matches the one on the left) Existing __ __mapping __ framework (X to X)__ Example of same-to-same: jsonpath-lifter name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville Jsonpath-lifter (JSON to JSON) Example of same-to-same: awk Example of same-to-same: SQL INSERT INTO Agent AS SELECT Person.last_name AS Agent.surname\\, CONCAT(Person.full_name\\, \u201c \u201c\\, Person.first) AS Agent.full_name\\, \u2026 CONSTRUCT { [ a schema:Person ; my:fullName STRCAT(...) ] } WHERE { ?person a schema:Person ; schema:firstName ; schema:lastName ; \u2026 } SPARQL CONSTRUCT RDF __ Engine or Triplestore__ Example of same-to-same: Python (LinkML objects) def convert(p: Person) -> Agent: return Agent(p.id\\, full_name=f\u201d{..} {..}\u201d\\, \u2026 Conversion script General approach for level 2+; heteromorphic name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville L inkml-convert OPTIONAL L inkml-convert OPTIONAL JSON OR XML OR YAML OR RDF OR SQL JSON __ OR __ XML __ OR __ YAML __ OR __ RDF __ OR __ SQL ( different __ from the one on the left)__ Existing mapping framework (X to Y) Example: YARRRML name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville YARRRML (JSON/YAML to RDF) Example: YARRRML, native mappings name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville mapping.yarrrml.yml Example: YARRRML, compiled mappings name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address Mappings : __ \u2026 \\< TO BE DEFINED LINKML MAPPING SPEC >__ name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville mapping.yarrrml.yml Hyperparasitism is good name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address Mappings : __ \u2026 \\< TO BE DEFINED LINKML MAPPING SPEC >__ name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address mapping.yarrrml.yml family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville Alternative: Direct translation language Desiderata Ability to compile to scalable frameworks E.g. compile to SQL Simple for simple tasks Layer on existing expression language Provides path to safe subset of host language (Python) Can be easily implemented in other languages Normalized to Denormalized (modeling SSSOM) SQL INSERT (or CREATE VIEW) SQL FROM Clause (implicit INNER JOIN/WHERE) SQL SELECT \u2026 AS clause Relationship to profiles TODO Profiles/IGs can be seen as a sub-case of schema mapping Current progress https://github.com/linkml/linkml/issues/533 map to YARRRML Vincent Vemonet has started on linkml->rml https://github.com/vemonet/linkml/blob/add-gen-rml/linkml/generators/rmlgen.py Relationship to Koza Koza ingests often require multiple files See Also Revisiting BioWeave (Kent Shefchek\\, 2020?) https://docs.google.com/presentation/d/1DYiWXoz3iHM2PvMFD0hRpJ544tnHawg00PBwNuESo44/edit#slide=id.gb33d7ddd1b_0_93 Automating mapping Should we pursue approaches to automate mapping? Some of the functionality is already in schema-automator. E.g. auto-annotating schema elements using ontologies Isomorphic schema mapping discovery analogous to ontology mapping Can a boomer type approach help? E.g. given multiple loose mappings with alternative interpretations\\, which ones give coherent results Other approaches Inductive Logic Programming: transformations as logic programs Genetic programming: transformations as lambda functions Deep Learning: e.g. Language Models for translation There is already a rich literature spanning decades here to be parasitized\u2026 Summary: just tell me what to do today For isomorphic mappings: Stay within LinkML/SSSOM No need for custom code\\, it all works For complex mappings: It depends! Do the structural mapping with linkml-convert Implement the complex logic as you see fit\\, depending on multiple factors. Any of the following may be valid Koza Awk SPARQL CONSTRUCTS or SELECTS Custom python YARRRML SQL INSERTs XSLT Jsonpath-lifter \u2026. Roadmap 2022: Continue to gather use cases\\, experiment 2023: If funding permits Extend metamodel to include complex mapping Implement EITHER Parasitizing converters Direct mapping framework TBD: Is this Koza2?","title":"Mapping Between LinkML Schemas"},{"location":"schema/overview/#mapping-between-linkml-schemas","text":"","title":"Mapping Between LinkML Schemas"},{"location":"schema/overview/#draft","text":"2022-06-24","title":"Draft"},{"location":"schema/overview/#problem-map-data-from-one-schema-to-another","text":"Problem: Map d1 \u2192 d2 Assumption d1 and d2 conform to two separate schemas\\, s1\u2192 s2 Sub-problems: Ingest/Import: my data warehouse conforms to s2 (e.g. Monarch ingest) Export: make my data ingest friendly Migrations: s1 and s2 are different versions of the same schema Not in scope: in-schema syntactic or structural transforms JSON to YAML\\, JSON to TSV\\, JSON to SQL\\, JSON to RDF\\, ORM\\, \u2026 In LinkML this is already largely solved The actual problem space is highly varied S1 and S2 may be trivially isomorphic S1 and S2 may differ in complex or nuanced ways","title":"Problem: map data from one schema to another"},{"location":"schema/overview/#there-are-many-existing-approaches","text":"Generic frameworks\\, driven by declarative specification in Domain Specific Language (DSL) JSON-based Google whistle jsonpath-lift XSLT Semweb YARRML\\, R2RML Many many more\u2026 Bespoke transforms: non-declarative Implement in python/awk/etc. Hybrid: bespoke with some declarative mappings in ad-hoc format E.g. NMDC ingest framework","title":"There are many existing approaches"},{"location":"schema/overview/#traps-with-declarative-mapping","text":"Declarative is great\\, until it\u2019s not Anti-patterns: Insufficient expressivity to carry out real world tasks Bolting on features to mapping DSL until it\u2019s a fully-featured Turing-complete language Optimization/scalability at mercy of framework Messy layering between DSL and host language It can be useful to leverage host language features (e.g arbitrary python function) But this can get confusing: NFNF: Neither fish nor fowl Limits optimizations (forces iterative host language calls)","title":"Traps with declarative mapping"},{"location":"schema/overview/#yarrrml","text":"https://rml.io/yarrrml/","title":"YARRRML"},{"location":"schema/overview/#yarrrml-notes","text":"Has a playground\\, which is great Mixes two concerns: 1. Isomorphic structural mapping between JSON/TSVs and RDF (already covered by JSON-LD) 2. Mapping This isn\u2019t necessarily bad - it\u2019s quite practical\\, but a little unsatisfying IMO","title":"YARRRML notes"},{"location":"schema/overview/#jsonpath-lifter","text":"Was proposed for CCDH CRDC-node mappings Doesn\u2019t seem widely used Is there a big advantage over simply writing javascript functions?","title":"jsonpath-lifter"},{"location":"schema/overview/#koza-previously-bioweave","text":"","title":"Koza (previously: bioweave)"},{"location":"schema/overview/#etl-frameworks","text":"There are many many ETL frameworks E.g. WebKarma Inherently mixing of concerns Here we are concerned with the \u201cT\u201d part Do existing frameworks separate out the T as a modular composable component? I\u2019m not sure","title":"ETL frameworks"},{"location":"schema/overview/#do-we-need-yet-another-mapping-framework","text":"LinkML philosophy: Embrace\\, extend\\, parasitize Develop lightweight ways to map Map mappings to existing mapping frameworks This actually makes sense even if it sounds kind of meta\u2026","title":"Do we need Yet Another Mapping Framework?"},{"location":"schema/overview/#level-0-mapping-isomorphic-same-uris","text":"classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address classes: Agent: class_uri: sdo:Person attributes: surname: slot_uri: sdo:familyName home_address: slot_uri: sdo:address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville","title":"Level 0 Mapping: Isomorphic, same URIs"},{"location":"schema/overview/#level-0-handled-by-standard-linkml-convert-tofrom-rdf","text":"classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address classes: Agent: class_uri: sdo:Person attributes: surname: slot_uri: sdo:familyName home_address: slot_uri: sdo:address data2 (yaml/json) d ata1 (yaml/json) family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville d ata1.ttl == data2.ttl [sdo:familyName \u201cWu\u201d ; sdo:address \u201c1 my street\\, Oakville\u201d ]","title":"Level 0: handled by standard linkml convert to/from RDF"},{"location":"schema/overview/#level-0-enums-todo-add-example-here-basically-this-works-the-same-way","text":"","title":"Level 0: Enums TODO: add example here. Basically this works the same way"},{"location":"schema/overview/#level-0-howto","text":"Compose two commands: linkml-convert -s schema1.yaml data1.yaml -o data1.ttl linkml-convert -s schema2.yaml data1.ttl -o data2.yaml That\u2019s it! TODO: Write a wrapper (linkml-map-data?) that does this in one command","title":"Level 0: HOWTO"},{"location":"schema/overview/#level-0-other-considerations","text":"Going via RDF in theory eliminates inlining differences E.g. s1 inlines address objects\\, s2 uses references (inlined: false) and includes a separate index slot for addresses Current status: Currently when going from s1 to s2\\, no index slots are generated This could be done as part of the general rdflib framework","title":"Level 0: other considerations"},{"location":"schema/overview/#lessons-learned-so-far-annotate-your-schema-with-uris","text":"Annotating schemas with URIs is optional with LinkML But your future self and data users will thank you for careful schema annotation! Hints: Schema-automator can provide suggestions for your element and enum URIs Sometimes plain semweb URIs (e.g. schema.org) can be easier for interoperation than overly granular OBO ones E.g modeling Personhood as a role vs straightforward schema:Person","title":"Lessons learned so far: annotate your schema with URIs!"},{"location":"schema/overview/#level-1-mapping-isomorphic-different-uris","text":"name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville","title":"Level 1 Mapping: Isomorphic, different URIs"},{"location":"schema/overview/#level-1-mapping-mediated-by-uri-mapping","text":"name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address subject_id object_id sdo:Person NCBITaxon:9606 sdo:familyName IAO:nnnn sdo:address IAO:0000422 family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville [sdo:familyName \u201cWu\u201d sdo:address \u201c1 my street\\, Oakville\u201d ] [sdo:familyName \u201cWu\u201d sdo:address \u201c1 my street\\, Oakville\u201d ]","title":"Level 1 Mapping: mediated by URI mapping"},{"location":"schema/overview/#level-1-howto","text":"Compose three commands: linkml-convert -s schema1.yaml data1.yaml -o data1.ttl sssom-map-iris -i data1.ttl -m schema1-to-schema2.sssom.tsv -o data2.ttl linkml-convert -s schema2.yaml data2.ttl -o data2.yaml That\u2019s it! TODO: sssom-map-iris does not yet exist (?)\\, but should be trivial Fold into wrapper CLI tool Nuances: Schemas have nuanced differences: not everything with be skos:exact We can distinguish 3 flavors of level 1 mapping: Precise\\, bidirectional: follow exact only Valid\\, unidirectional: follow exact + broad Loose: any mapping","title":"Level 1: HOWTO"},{"location":"schema/overview/#level-1-variant-mappings-in-schema","text":"name: example-semweb-schema classes: Person: class_uri: sdo:Person __ __ exact_mappings: [\u201cNCBITaxon:9606\u201d] attributes: family_name: slot_uri: sdo:familyName __ exact_mappings: [\u201cIAO:nnnn\u201d]__ address: slot_uri: sdo:address __ exact_mappings: [\u201cIAO:0000422\u201d]__ name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville [sdo:familyName \u201cWu\u201d sdo:address \u201c1 my street\\, Oakville\u201d ] [sdo:familyName \u201cWu\u201d sdo:address \u201c1 my street\\, Oakville\u201d ]","title":"Level 1 variant: mappings in schema"},{"location":"schema/overview/#advantages-of-rdf-as-an-intermediate","text":"Use of IRIs Separation of concerns Structural differences (e.g. inlining) are already handled by linkml convert Allows us to focus on semantic mappings","title":"Advantages of RDF as an intermediate"},{"location":"schema/overview/#lessons-learned-so-far-think-about-mappings","text":"https://linkml.io/linkml/faq/modeling.html#when-is-it-important-to-have-mappings https://github.com/alliance-genome/agr_curation_schema/blob/main/model/schema/agent.yaml","title":"Lessons learned so far: think about mappings"},{"location":"schema/overview/#more-complex-mappings-level-2-and-above","text":"TODO: define levels 2 and above Examples of kinds of features: merging/splitting fields; e.g. full_name = first + \u201c \u201c + last Unit conversion or baked-in units to explicit units Normalization/denormalization (aka flattening) Complex logic If conditions A\\, B\\, C and not D are met then copy field F from X to Y","title":"More complex mappings: level 2 and above"},{"location":"schema/overview/#linkml-rule-and-inference-framework","text":"Current use case is intra-schema inference Easy to invoke on command line Needs more docs! Could form basis of inter-schema DSL Examples Schemas differ in units Schemas differ in categorical vs quantitative Current use case is intra-schema inference Could form basis of inter-schema DSL","title":"LinkML Rule and Inference Framework"},{"location":"schema/overview/#datalog","text":"Datalog could serve as the powerful basis of an expressive declarative transformation language https://linkml.io/linkml-datalog","title":"Datalog"},{"location":"schema/overview/#approach-for-level-2","text":"Do we even want a generic mapping framework in LinkML here? This is a good \u201c parasitization hook\u201d Do complex stuff using an existing framework TBD: derive or semi-derive mapping specification? This is also a code bespoke procedural code hook Do the generic stuff with linkml-convert and isomorphic IRI mapping Do more complex stuff in code","title":"Approach for level 2+"},{"location":"schema/overview/#general-approach-for-level-2-same-to-same","text":"name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville JSON OR XML OR YAML OR RDF OR SQL JSON __ OR __ XML __ OR __ YAML __ OR __ RDF __ OR __ SQL (matches the one on the left) Existing __ __mapping __ framework (X to X)__","title":"General approach for level 2+; same to same"},{"location":"schema/overview/#example-of-same-to-same-jsonpath-lifter","text":"name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville Jsonpath-lifter (JSON to JSON)","title":"Example of same-to-same: jsonpath-lifter"},{"location":"schema/overview/#example-of-same-to-same-awk","text":"","title":"Example of same-to-same: awk"},{"location":"schema/overview/#example-of-same-to-same-sql","text":"INSERT INTO Agent AS SELECT Person.last_name AS Agent.surname\\, CONCAT(Person.full_name\\, \u201c \u201c\\, Person.first) AS Agent.full_name\\, \u2026 CONSTRUCT { [ a schema:Person ; my:fullName STRCAT(...) ] } WHERE { ?person a schema:Person ; schema:firstName ; schema:lastName ; \u2026 } SPARQL CONSTRUCT RDF __ Engine or Triplestore__","title":"Example of same-to-same: SQL"},{"location":"schema/overview/#example-of-same-to-same-python-linkml-objects","text":"def convert(p: Person) -> Agent: return Agent(p.id\\, full_name=f\u201d{..} {..}\u201d\\, \u2026 Conversion script","title":"Example of same-to-same: Python (LinkML objects)"},{"location":"schema/overview/#general-approach-for-level-2-heteromorphic","text":"name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville L inkml-convert OPTIONAL L inkml-convert OPTIONAL JSON OR XML OR YAML OR RDF OR SQL JSON __ OR __ XML __ OR __ YAML __ OR __ RDF __ OR __ SQL ( different __ from the one on the left)__ Existing mapping framework (X to Y)","title":"General approach for level 2+; heteromorphic"},{"location":"schema/overview/#example-yarrrml","text":"name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville YARRRML (JSON/YAML to RDF)","title":"Example: YARRRML"},{"location":"schema/overview/#example-yarrrml-native-mappings","text":"name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville mapping.yarrrml.yml","title":"Example: YARRRML, native mappings"},{"location":"schema/overview/#example-yarrrml-compiled-mappings","text":"name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address Mappings : __ \u2026 \\< TO BE DEFINED LINKML MAPPING SPEC >__ name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville mapping.yarrrml.yml","title":"Example: YARRRML, compiled mappings"},{"location":"schema/overview/#hyperparasitism-is-good","text":"name: example-semweb-schema classes: Person: class_uri: sdo:Person attributes: family_name: slot_uri: sdo:familyName address: slot_uri: sdo:address Mappings : __ \u2026 \\< TO BE DEFINED LINKML MAPPING SPEC >__ name: example-OBO-schema classes: Person: class_uri: NCBITaxon:9606 ## Homo sapiens attributes: surname: slot_uri: IAO:0000590 ## written name home_address: slot_uri: IAO:0000422 ## postal address mapping.yarrrml.yml family_name: Wu address: 1 my street\\, Oakville surname: Wu home_address: 1 my street\\, Oakville","title":"Hyperparasitism is good"},{"location":"schema/overview/#alternative-direct-translation-language","text":"Desiderata Ability to compile to scalable frameworks E.g. compile to SQL Simple for simple tasks Layer on existing expression language Provides path to safe subset of host language (Python) Can be easily implemented in other languages","title":"Alternative: Direct translation language"},{"location":"schema/overview/#normalized-to-denormalized-modeling-sssom","text":"SQL INSERT (or CREATE VIEW) SQL FROM Clause (implicit INNER JOIN/WHERE) SQL SELECT \u2026 AS clause","title":"Normalized to Denormalized (modeling SSSOM)"},{"location":"schema/overview/#relationship-to-profiles-todo","text":"Profiles/IGs can be seen as a sub-case of schema mapping","title":"Relationship to profiles TODO"},{"location":"schema/overview/#current-progress","text":"https://github.com/linkml/linkml/issues/533 map to YARRRML Vincent Vemonet has started on linkml->rml https://github.com/vemonet/linkml/blob/add-gen-rml/linkml/generators/rmlgen.py","title":"Current progress"},{"location":"schema/overview/#relationship-to-koza","text":"","title":"Relationship to Koza"},{"location":"schema/overview/#koza-ingests-often-require-multiple-files","text":"","title":"Koza ingests often require multiple files"},{"location":"schema/overview/#see-also","text":"Revisiting BioWeave (Kent Shefchek\\, 2020?) https://docs.google.com/presentation/d/1DYiWXoz3iHM2PvMFD0hRpJ544tnHawg00PBwNuESo44/edit#slide=id.gb33d7ddd1b_0_93","title":"See Also"},{"location":"schema/overview/#automating-mapping","text":"Should we pursue approaches to automate mapping? Some of the functionality is already in schema-automator. E.g. auto-annotating schema elements using ontologies Isomorphic schema mapping discovery analogous to ontology mapping Can a boomer type approach help? E.g. given multiple loose mappings with alternative interpretations\\, which ones give coherent results Other approaches Inductive Logic Programming: transformations as logic programs Genetic programming: transformations as lambda functions Deep Learning: e.g. Language Models for translation There is already a rich literature spanning decades here to be parasitized\u2026","title":"Automating mapping"},{"location":"schema/overview/#summary-just-tell-me-what-to-do-today","text":"For isomorphic mappings: Stay within LinkML/SSSOM No need for custom code\\, it all works For complex mappings: It depends! Do the structural mapping with linkml-convert Implement the complex logic as you see fit\\, depending on multiple factors. Any of the following may be valid Koza Awk SPARQL CONSTRUCTS or SELECTS Custom python YARRRML SQL INSERTs XSLT Jsonpath-lifter \u2026.","title":"Summary: just tell me what to do today"},{"location":"schema/overview/#roadmap","text":"2022: Continue to gather use cases\\, experiment 2023: If funding permits Extend metamodel to include complex mapping Implement EITHER Parasitizing converters Direct mapping framework TBD: Is this Koza2?","title":"Roadmap"},{"location":"schema/permissible_value_derivations/","text":"Slot: permissible_value_derivations Instructions on how to derive a set of PVs in the target schema URI: linkmltr:permissible_value_derivations Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no Properties Range: PermissibleValueDerivation Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : permissible_value_derivations description : Instructions on how to derive a set of PVs in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : permissible_value_derivations owner : EnumDerivation domain_of : - EnumDerivation range : PermissibleValueDerivation inlined : true","title":"Slot: permissible_value_derivations"},{"location":"schema/permissible_value_derivations/#slot-permissible_value_derivations","text":"Instructions on how to derive a set of PVs in the target schema URI: linkmltr:permissible_value_derivations","title":"Slot: permissible_value_derivations"},{"location":"schema/permissible_value_derivations/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no","title":"Applicable Classes"},{"location":"schema/permissible_value_derivations/#properties","text":"Range: PermissibleValueDerivation Multivalued: True","title":"Properties"},{"location":"schema/permissible_value_derivations/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/permissible_value_derivations/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/permissible_value_derivations/#linkml-source","text":"name : permissible_value_derivations description : Instructions on how to derive a set of PVs in the target schema from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : permissible_value_derivations owner : EnumDerivation domain_of : - EnumDerivation range : PermissibleValueDerivation inlined : true","title":"LinkML Source"},{"location":"schema/populated_from/","text":"Slot: populated_from URI: linkmltr:populated_from Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no ClassDerivation A specification of how to derive a target class from a source class no EnumDerivation A specification of how to derive the value of a target enum from a source enu... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no Properties Range: NONE Identifier and Mapping Information LinkML Source name : populated_from alias : populated_from domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation","title":"Slot: populated_from"},{"location":"schema/populated_from/#slot-populated_from","text":"URI: linkmltr:populated_from","title":"Slot: populated_from"},{"location":"schema/populated_from/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no ClassDerivation A specification of how to derive a target class from a source class no EnumDerivation A specification of how to derive the value of a target enum from a source enu... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no","title":"Applicable Classes"},{"location":"schema/populated_from/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/populated_from/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/populated_from/#linkml-source","text":"name : populated_from alias : populated_from domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation","title":"LinkML Source"},{"location":"schema/prefixes/","text":"Slot: prefixes maps prefixes to URL expansions URI: sh:declare Applicable Classes Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no Properties Range: KeyVal Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : prefixes description : maps prefixes to URL expansions from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : sh:declare multivalued : true alias : prefixes owner : TransformationSpecification domain_of : - TransformationSpecification range : KeyVal inlined : true","title":"Slot: prefixes"},{"location":"schema/prefixes/#slot-prefixes","text":"maps prefixes to URL expansions URI: sh:declare","title":"Slot: prefixes"},{"location":"schema/prefixes/#applicable-classes","text":"Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no","title":"Applicable Classes"},{"location":"schema/prefixes/#properties","text":"Range: KeyVal Multivalued: True","title":"Properties"},{"location":"schema/prefixes/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/prefixes/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/prefixes/#linkml-source","text":"name : prefixes description : maps prefixes to URL expansions from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : sh:declare multivalued : true alias : prefixes owner : TransformationSpecification domain_of : - TransformationSpecification range : KeyVal inlined : true","title":"LinkML Source"},{"location":"schema/range/","text":"Slot: range URI: linkml:range Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no Properties Range: String Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : range from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:range alias : range owner : SlotDerivation domain_of : - SlotDerivation range : string","title":"Slot: range"},{"location":"schema/range/#slot-range","text":"URI: linkml:range","title":"Slot: range"},{"location":"schema/range/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no","title":"Applicable Classes"},{"location":"schema/range/#properties","text":"Range: String","title":"Properties"},{"location":"schema/range/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/range/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/range/#linkml-source","text":"name : range from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : linkml:range alias : range owner : SlotDerivation domain_of : - SlotDerivation range : string","title":"LinkML Source"},{"location":"schema/reversed/","text":"Slot: reversed URI: linkmltr:reversed Applicable Classes Name Description Modifies Slot StringificationConfiguration no Properties Range: Boolean Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : reversed from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : reversed owner : StringificationConfiguration domain_of : - StringificationConfiguration range : boolean","title":"Slot: reversed"},{"location":"schema/reversed/#slot-reversed","text":"URI: linkmltr:reversed","title":"Slot: reversed"},{"location":"schema/reversed/#applicable-classes","text":"Name Description Modifies Slot StringificationConfiguration no","title":"Applicable Classes"},{"location":"schema/reversed/#properties","text":"Range: Boolean","title":"Properties"},{"location":"schema/reversed/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/reversed/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/reversed/#linkml-source","text":"name : reversed from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : reversed owner : StringificationConfiguration domain_of : - StringificationConfiguration range : boolean","title":"LinkML Source"},{"location":"schema/same_as/","text":"Slot: same_as Name of the class in the source schema URI: https://w3id.org/linkml/transformer/same_as Properties Range: xsd:string Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer","title":"Slot: same_as"},{"location":"schema/same_as/#slot-same_as","text":"Name of the class in the source schema URI: https://w3id.org/linkml/transformer/same_as","title":"Slot: same_as"},{"location":"schema/same_as/#properties","text":"Range: xsd:string","title":"Properties"},{"location":"schema/same_as/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/same_as/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/session/","text":"Session A wrapper object for a transformer session. TODO: rename to Manager? consolidate configuration include source and target database current spec, src_sv, tgt_sv all live in both this class and transformer Source code in src\\linkml_map\\session.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 @dataclass class Session : \"\"\" A wrapper object for a transformer session. TODO: - rename to Manager? - consolidate configuration - include source and target database - current spec, src_sv, tgt_sv all live in both this class and transformer \"\"\" transformer_specification : Optional [ TransformationSpecification ] = None source_schemaview : Optional [ SchemaView ] = None transformer : Optional [ Transformer ] = None object_transformer : Optional [ ObjectTransformer ] = None schema_mapper : Optional [ SchemaMapper ] = None _target_schema : Optional [ SchemaDefinition ] = None _target_schemaview : Optional [ SchemaView ] = None def set_transformer_specification ( self , specification : Optional [ Union [ TransformationSpecification , dict , str , Path ]] = None ): if isinstance ( specification , Path ): specification = str ( specification ) if isinstance ( specification , TransformationSpecification ): self . transformer_specification = specification elif isinstance ( specification , dict ): # TODO: centralize this code normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True specification = normalizer . normalize ( specification ) self . transformer_specification = TransformationSpecification ( ** specification ) elif isinstance ( specification , str ): if \" \\n \" in specification : obj = yaml . safe_load ( specification ) else : obj = yaml . safe_load ( open ( specification )) self . set_transformer_specification ( obj ) def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None def set_transformer ( self , transformer : Optional [ Union [ Transformer , Type [ Transformer ]]], ** kwargs , ): if isinstance ( transformer , Type ): transformer = transformer () transformer . specification = self . transformer_specification self . transformer = transformer def set_object_transformer ( self , transformer : Optional [ Union [ ObjectTransformer , TransformationSpecification , dict , str , Path ] ] = None , ): if transformer is None : if self . object_transformer is not None : logger . info ( \"No change\" ) return else : logger . warning ( \"No transformer specified\" ) return if transformer is not None : if isinstance ( transformer , ObjectTransformer ): self . object_transformer = transformer else : self . set_transformer_specification ( transformer ) self . object_transformer = ObjectTransformer () self . object_transformer . specification = self . transformer_specification self . _target_schema = None @property def target_schema ( self ) -> SchemaDefinition : if self . _target_schema is None : if not self . schema_mapper : self . schema_mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) self . _target_schema = self . schema_mapper . derive_schema ( self . transformer_specification ) return self . _target_schema @property def target_schemaview ( self ) -> SchemaView : if self . _target_schemaview is None : # TODO: simplify self . _target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return self . _target_schemaview def transform ( self , obj : dict , ** kwargs ) -> dict : if self . object_transformer is None : raise ValueError ( \"No transformer specified\" ) if not self . object_transformer . source_schemaview : self . object_transformer . source_schemaview = self . source_schemaview return self . object_transformer . map_object ( obj , ** kwargs ) def reverse_transform ( self , obj : dict , ** kwargs ) -> dict : inv_spec = self . invert () reverse_transformer = ObjectTransformer () reverse_transformer . specification = inv_spec reverse_transformer . source_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return reverse_transformer . map_object ( obj , ** kwargs ) def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph graphviz ( ** kwargs ) Return a graphviz representation of the schema. Source code in src\\linkml_map\\session.py 159 160 161 162 163 164 165 166 167 def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph invert ( in_place = False ) Invert the transformer specification. Source code in src\\linkml_map\\session.py 146 147 148 149 150 151 152 153 154 155 156 157 def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec set_source_schema ( schema ) Sets the schema from a path or SchemaView object. Source code in src\\linkml_map\\session.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None","title":"Session"},{"location":"schema/session/#session","text":"A wrapper object for a transformer session. TODO: rename to Manager? consolidate configuration include source and target database current spec, src_sv, tgt_sv all live in both this class and transformer Source code in src\\linkml_map\\session.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 @dataclass class Session : \"\"\" A wrapper object for a transformer session. TODO: - rename to Manager? - consolidate configuration - include source and target database - current spec, src_sv, tgt_sv all live in both this class and transformer \"\"\" transformer_specification : Optional [ TransformationSpecification ] = None source_schemaview : Optional [ SchemaView ] = None transformer : Optional [ Transformer ] = None object_transformer : Optional [ ObjectTransformer ] = None schema_mapper : Optional [ SchemaMapper ] = None _target_schema : Optional [ SchemaDefinition ] = None _target_schemaview : Optional [ SchemaView ] = None def set_transformer_specification ( self , specification : Optional [ Union [ TransformationSpecification , dict , str , Path ]] = None ): if isinstance ( specification , Path ): specification = str ( specification ) if isinstance ( specification , TransformationSpecification ): self . transformer_specification = specification elif isinstance ( specification , dict ): # TODO: centralize this code normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True specification = normalizer . normalize ( specification ) self . transformer_specification = TransformationSpecification ( ** specification ) elif isinstance ( specification , str ): if \" \\n \" in specification : obj = yaml . safe_load ( specification ) else : obj = yaml . safe_load ( open ( specification )) self . set_transformer_specification ( obj ) def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None def set_transformer ( self , transformer : Optional [ Union [ Transformer , Type [ Transformer ]]], ** kwargs , ): if isinstance ( transformer , Type ): transformer = transformer () transformer . specification = self . transformer_specification self . transformer = transformer def set_object_transformer ( self , transformer : Optional [ Union [ ObjectTransformer , TransformationSpecification , dict , str , Path ] ] = None , ): if transformer is None : if self . object_transformer is not None : logger . info ( \"No change\" ) return else : logger . warning ( \"No transformer specified\" ) return if transformer is not None : if isinstance ( transformer , ObjectTransformer ): self . object_transformer = transformer else : self . set_transformer_specification ( transformer ) self . object_transformer = ObjectTransformer () self . object_transformer . specification = self . transformer_specification self . _target_schema = None @property def target_schema ( self ) -> SchemaDefinition : if self . _target_schema is None : if not self . schema_mapper : self . schema_mapper = SchemaMapper ( source_schemaview = self . source_schemaview ) self . _target_schema = self . schema_mapper . derive_schema ( self . transformer_specification ) return self . _target_schema @property def target_schemaview ( self ) -> SchemaView : if self . _target_schemaview is None : # TODO: simplify self . _target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return self . _target_schemaview def transform ( self , obj : dict , ** kwargs ) -> dict : if self . object_transformer is None : raise ValueError ( \"No transformer specified\" ) if not self . object_transformer . source_schemaview : self . object_transformer . source_schemaview = self . source_schemaview return self . object_transformer . map_object ( obj , ** kwargs ) def reverse_transform ( self , obj : dict , ** kwargs ) -> dict : inv_spec = self . invert () reverse_transformer = ObjectTransformer () reverse_transformer . specification = inv_spec reverse_transformer . source_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )) return reverse_transformer . map_object ( obj , ** kwargs ) def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph","title":"Session"},{"location":"schema/session/#linkml_map.session.Session.graphviz","text":"Return a graphviz representation of the schema. Source code in src\\linkml_map\\session.py 159 160 161 162 163 164 165 166 167 def graphviz ( self , ** kwargs ) -> Any : \"\"\" Return a graphviz representation of the schema. \"\"\" from linkml_map.compiler.graphviz_compiler import GraphvizCompiler gc = GraphvizCompiler ( source_schemaview = self . source_schemaview ) compiled = gc . compile ( self . transformer_specification ) return compiled . digraph","title":"graphviz"},{"location":"schema/session/#linkml_map.session.Session.invert","text":"Invert the transformer specification. Source code in src\\linkml_map\\session.py 146 147 148 149 150 151 152 153 154 155 156 157 def invert ( self , in_place = False ) -> TransformationSpecification : \"\"\" Invert the transformer specification. \"\"\" inverter = TransformationSpecificationInverter ( source_schemaview = self . source_schemaview , target_schemaview = SchemaView ( yaml_dumper . dumps ( self . target_schema )), ) inv_spec = inverter . invert ( self . transformer_specification ) if in_place : raise NotImplementedError return inv_spec","title":"invert"},{"location":"schema/session/#linkml_map.session.Session.set_source_schema","text":"Sets the schema from a path or SchemaView object. Source code in src\\linkml_map\\session.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def set_source_schema ( self , schema : Union [ str , Path , dict , SchemaView , SchemaDefinition ]): \"\"\" Sets the schema from a path or SchemaView object. \"\"\" if isinstance ( schema , str ): sv = SchemaView ( schema ) elif isinstance ( schema , Path ): sv = SchemaView ( str ( schema )) elif isinstance ( schema , dict ): sv = SchemaView ( yaml_dumper . dumps ( schema )) elif isinstance ( schema , SchemaView ): sv = schema elif isinstance ( schema , SchemaDefinition ): sv = SchemaView ( schema ) else : raise ValueError ( f \"Unsupported schema type: { type ( schema ) } \" ) self . source_schemaview = sv self . _target_schema = None","title":"set_source_schema"},{"location":"schema/slot_derivations/","text":"Slot: slot_derivations URI: linkmltr:slot_derivations Applicable Classes Name Description Modifies Slot ClassDerivation A specification of how to derive a target class from a source class no TransformationSpecification A collection of mappings between source and target classes no Properties Range: NONE Identifier and Mapping Information LinkML Source name : slot_derivations alias : slot_derivations domain_of : - TransformationSpecification - ClassDerivation","title":"Slot: slot_derivations"},{"location":"schema/slot_derivations/#slot-slot_derivations","text":"URI: linkmltr:slot_derivations","title":"Slot: slot_derivations"},{"location":"schema/slot_derivations/#applicable-classes","text":"Name Description Modifies Slot ClassDerivation A specification of how to derive a target class from a source class no TransformationSpecification A collection of mappings between source and target classes no","title":"Applicable Classes"},{"location":"schema/slot_derivations/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/slot_derivations/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/slot_derivations/#linkml-source","text":"name : slot_derivations alias : slot_derivations domain_of : - TransformationSpecification - ClassDerivation","title":"LinkML Source"},{"location":"schema/slot_name/","text":"Slot: slot_name URI: linkmltr:slot_name Applicable Classes Name Description Modifies Slot Inverse Used for back references in mapping to relational model no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : slot_name from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : slot_name owner : Inverse domain_of : - Inverse","title":"Slot: slot_name"},{"location":"schema/slot_name/#slot-slot_name","text":"URI: linkmltr:slot_name","title":"Slot: slot_name"},{"location":"schema/slot_name/#applicable-classes","text":"Name Description Modifies Slot Inverse Used for back references in mapping to relational model no","title":"Applicable Classes"},{"location":"schema/slot_name/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/slot_name/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/slot_name/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/slot_name/#linkml-source","text":"name : slot_name from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : slot_name owner : Inverse domain_of : - Inverse","title":"LinkML Source"},{"location":"schema/source_magnitude_slot/","text":"Slot: source_magnitude_slot URI: linkmltr:source_magnitude_slot Applicable Classes Name Description Modifies Slot UnitConversionConfiguration no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : source_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_magnitude_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"Slot: source_magnitude_slot"},{"location":"schema/source_magnitude_slot/#slot-source_magnitude_slot","text":"URI: linkmltr:source_magnitude_slot","title":"Slot: source_magnitude_slot"},{"location":"schema/source_magnitude_slot/#applicable-classes","text":"Name Description Modifies Slot UnitConversionConfiguration no","title":"Applicable Classes"},{"location":"schema/source_magnitude_slot/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/source_magnitude_slot/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/source_magnitude_slot/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/source_magnitude_slot/#linkml-source","text":"name : source_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_magnitude_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"LinkML Source"},{"location":"schema/source_schema/","text":"Slot: source_schema name of the schema that describes the source (input) objects URI: linkmltr:source_schema Applicable Classes Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : source_schema description : name of the schema that describes the source (input) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_schema owner : TransformationSpecification domain_of : - TransformationSpecification","title":"Slot: source_schema"},{"location":"schema/source_schema/#slot-source_schema","text":"name of the schema that describes the source (input) objects URI: linkmltr:source_schema","title":"Slot: source_schema"},{"location":"schema/source_schema/#applicable-classes","text":"Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no","title":"Applicable Classes"},{"location":"schema/source_schema/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/source_schema/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/source_schema/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/source_schema/#linkml-source","text":"name : source_schema description : name of the schema that describes the source (input) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_schema owner : TransformationSpecification domain_of : - TransformationSpecification","title":"LinkML Source"},{"location":"schema/source_unit/","text":"Slot: source_unit URI: linkmltr:source_unit Applicable Classes Name Description Modifies Slot UnitConversionConfiguration no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : source_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"Slot: source_unit"},{"location":"schema/source_unit/#slot-source_unit","text":"URI: linkmltr:source_unit","title":"Slot: source_unit"},{"location":"schema/source_unit/#applicable-classes","text":"Name Description Modifies Slot UnitConversionConfiguration no","title":"Applicable Classes"},{"location":"schema/source_unit/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/source_unit/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/source_unit/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/source_unit/#linkml-source","text":"name : source_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"LinkML Source"},{"location":"schema/source_unit_scheme/","text":"Slot: source_unit_scheme URI: linkmltr:source_unit_scheme Applicable Classes Name Description Modifies Slot UnitConversionConfiguration no Properties Range: String Examples Value ucum Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : source_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit_scheme owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration range : string","title":"Slot: source_unit_scheme"},{"location":"schema/source_unit_scheme/#slot-source_unit_scheme","text":"URI: linkmltr:source_unit_scheme","title":"Slot: source_unit_scheme"},{"location":"schema/source_unit_scheme/#applicable-classes","text":"Name Description Modifies Slot UnitConversionConfiguration no","title":"Applicable Classes"},{"location":"schema/source_unit_scheme/#properties","text":"Range: String","title":"Properties"},{"location":"schema/source_unit_scheme/#examples","text":"Value ucum","title":"Examples"},{"location":"schema/source_unit_scheme/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/source_unit_scheme/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/source_unit_scheme/#linkml-source","text":"name : source_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit_scheme owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration range : string","title":"LinkML Source"},{"location":"schema/source_unit_slot/","text":"Slot: source_unit_slot URI: linkmltr:source_unit_slot Applicable Classes Name Description Modifies Slot UnitConversionConfiguration no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : source_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"Slot: source_unit_slot"},{"location":"schema/source_unit_slot/#slot-source_unit_slot","text":"URI: linkmltr:source_unit_slot","title":"Slot: source_unit_slot"},{"location":"schema/source_unit_slot/#applicable-classes","text":"Name Description Modifies Slot UnitConversionConfiguration no","title":"Applicable Classes"},{"location":"schema/source_unit_slot/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/source_unit_slot/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/source_unit_slot/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/source_unit_slot/#linkml-source","text":"name : source_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : source_unit_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"LinkML Source"},{"location":"schema/sources/","text":"Slot: sources URI: linkmltr:sources Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no ClassDerivation A specification of how to derive a target class from a source class no EnumDerivation A specification of how to derive the value of a target enum from a source enu... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no Properties Range: NONE Identifier and Mapping Information LinkML Source name : sources alias : sources domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation","title":"Slot: sources"},{"location":"schema/sources/#slot-sources","text":"URI: linkmltr:sources","title":"Slot: sources"},{"location":"schema/sources/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no ClassDerivation A specification of how to derive a target class from a source class no EnumDerivation A specification of how to derive the value of a target enum from a source enu... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no","title":"Applicable Classes"},{"location":"schema/sources/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/sources/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/sources/#linkml-source","text":"name : sources alias : sources domain_of : - ClassDerivation - SlotDerivation - EnumDerivation - PermissibleValueDerivation","title":"LinkML Source"},{"location":"schema/stringification/","text":"Slot: stringification URI: linkmltr:stringification Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no Properties Range: StringificationConfiguration Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : stringification from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : stringification owner : SlotDerivation domain_of : - SlotDerivation range : StringificationConfiguration","title":"Slot: stringification"},{"location":"schema/stringification/#slot-stringification","text":"URI: linkmltr:stringification","title":"Slot: stringification"},{"location":"schema/stringification/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no","title":"Applicable Classes"},{"location":"schema/stringification/#properties","text":"Range: StringificationConfiguration","title":"Properties"},{"location":"schema/stringification/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/stringification/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/stringification/#linkml-source","text":"name : stringification from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : stringification owner : SlotDerivation domain_of : - SlotDerivation range : StringificationConfiguration","title":"LinkML Source"},{"location":"schema/syntax/","text":"Slot: syntax URI: linkmltr:syntax Applicable Classes Name Description Modifies Slot StringificationConfiguration no Properties Range: SerializationSyntaxType Examples Value json yaml Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : syntax examples : - value : json - value : yaml from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : syntax owner : StringificationConfiguration domain_of : - StringificationConfiguration range : SerializationSyntaxType","title":"Slot: syntax"},{"location":"schema/syntax/#slot-syntax","text":"URI: linkmltr:syntax","title":"Slot: syntax"},{"location":"schema/syntax/#applicable-classes","text":"Name Description Modifies Slot StringificationConfiguration no","title":"Applicable Classes"},{"location":"schema/syntax/#properties","text":"Range: SerializationSyntaxType","title":"Properties"},{"location":"schema/syntax/#examples","text":"Value json yaml","title":"Examples"},{"location":"schema/syntax/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/syntax/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/syntax/#linkml-source","text":"name : syntax examples : - value : json - value : yaml from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : syntax owner : StringificationConfiguration domain_of : - StringificationConfiguration range : SerializationSyntaxType","title":"LinkML Source"},{"location":"schema/target_magnitude_slot/","text":"Slot: target_magnitude_slot URI: linkmltr:target_magnitude_slot Applicable Classes Name Description Modifies Slot UnitConversionConfiguration no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : target_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_magnitude_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"Slot: target_magnitude_slot"},{"location":"schema/target_magnitude_slot/#slot-target_magnitude_slot","text":"URI: linkmltr:target_magnitude_slot","title":"Slot: target_magnitude_slot"},{"location":"schema/target_magnitude_slot/#applicable-classes","text":"Name Description Modifies Slot UnitConversionConfiguration no","title":"Applicable Classes"},{"location":"schema/target_magnitude_slot/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/target_magnitude_slot/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/target_magnitude_slot/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/target_magnitude_slot/#linkml-source","text":"name : target_magnitude_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_magnitude_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"LinkML Source"},{"location":"schema/target_schema/","text":"Slot: target_schema name of the schema that describes the target (output) objects URI: linkmltr:target_schema Applicable Classes Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : target_schema description : name of the schema that describes the target (output) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_schema owner : TransformationSpecification domain_of : - TransformationSpecification","title":"Slot: target_schema"},{"location":"schema/target_schema/#slot-target_schema","text":"name of the schema that describes the target (output) objects URI: linkmltr:target_schema","title":"Slot: target_schema"},{"location":"schema/target_schema/#applicable-classes","text":"Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no","title":"Applicable Classes"},{"location":"schema/target_schema/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/target_schema/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/target_schema/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/target_schema/#linkml-source","text":"name : target_schema description : name of the schema that describes the target (output) objects from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_schema owner : TransformationSpecification domain_of : - TransformationSpecification","title":"LinkML Source"},{"location":"schema/target_unit/","text":"Slot: target_unit URI: linkmltr:target_unit Applicable Classes Name Description Modifies Slot UnitConversionConfiguration no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : target_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"Slot: target_unit"},{"location":"schema/target_unit/#slot-target_unit","text":"URI: linkmltr:target_unit","title":"Slot: target_unit"},{"location":"schema/target_unit/#applicable-classes","text":"Name Description Modifies Slot UnitConversionConfiguration no","title":"Applicable Classes"},{"location":"schema/target_unit/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/target_unit/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/target_unit/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/target_unit/#linkml-source","text":"name : target_unit from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"LinkML Source"},{"location":"schema/target_unit_scheme/","text":"Slot: target_unit_scheme URI: linkmltr:target_unit_scheme Applicable Classes Name Description Modifies Slot UnitConversionConfiguration no Properties Range: String Examples Value ucum Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : target_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit_scheme owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration range : string","title":"Slot: target_unit_scheme"},{"location":"schema/target_unit_scheme/#slot-target_unit_scheme","text":"URI: linkmltr:target_unit_scheme","title":"Slot: target_unit_scheme"},{"location":"schema/target_unit_scheme/#applicable-classes","text":"Name Description Modifies Slot UnitConversionConfiguration no","title":"Applicable Classes"},{"location":"schema/target_unit_scheme/#properties","text":"Range: String","title":"Properties"},{"location":"schema/target_unit_scheme/#examples","text":"Value ucum","title":"Examples"},{"location":"schema/target_unit_scheme/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/target_unit_scheme/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/target_unit_scheme/#linkml-source","text":"name : target_unit_scheme examples : - value : ucum from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit_scheme owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration range : string","title":"LinkML Source"},{"location":"schema/target_unit_slot/","text":"Slot: target_unit_slot URI: linkmltr:target_unit_slot Applicable Classes Name Description Modifies Slot UnitConversionConfiguration no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : target_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"Slot: target_unit_slot"},{"location":"schema/target_unit_slot/#slot-target_unit_slot","text":"URI: linkmltr:target_unit_slot","title":"Slot: target_unit_slot"},{"location":"schema/target_unit_slot/#applicable-classes","text":"Name Description Modifies Slot UnitConversionConfiguration no","title":"Applicable Classes"},{"location":"schema/target_unit_slot/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/target_unit_slot/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/target_unit_slot/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/target_unit_slot/#linkml-source","text":"name : target_unit_slot from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : target_unit_slot owner : UnitConversionConfiguration domain_of : - UnitConversionConfiguration","title":"LinkML Source"},{"location":"schema/title/","text":"Slot: title human readable title for this transformation specification URI: dcterms:title Applicable Classes Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no Properties Range: NONE Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : title description : human readable title for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:title alias : title owner : TransformationSpecification domain_of : - TransformationSpecification","title":"Slot: title"},{"location":"schema/title/#slot-title","text":"human readable title for this transformation specification URI: dcterms:title","title":"Slot: title"},{"location":"schema/title/#applicable-classes","text":"Name Description Modifies Slot TransformationSpecification A collection of mappings between source and target classes no","title":"Applicable Classes"},{"location":"schema/title/#properties","text":"Range: NONE","title":"Properties"},{"location":"schema/title/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/title/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/title/#linkml-source","text":"name : title description : human readable title for this transformation specification from_schema : https://w3id.org/linkml/transformer rank : 1000 slot_uri : dcterms:title alias : title owner : TransformationSpecification domain_of : - TransformationSpecification","title":"LinkML Source"},{"location":"schema/transformer/","text":"Transformer Package Transformer (Base Class) Bases: ABC Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this Source code in src\\linkml_map\\transformer\\transformer.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @dataclass class Transformer ( ABC ): \"\"\" Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this \"\"\" specification : TransformationSpecification = None \"\"\"A specification of how to generate target objects from source objects.\"\"\" source_schemaview : SchemaView = None \"\"\"A view over the schema describing the input/source object.\"\"\" _derived_specification : TransformationSpecification = None \"\"\"A specification with inferred missing values.\"\"\" target_schemaview : Optional [ SchemaView ] = None \"\"\"A view over the schema describing the output/target object.\"\"\" unrestricted_eval : bool = field ( default = False ) \"\"\"Set to True to allow arbitrary evals as part of transformation.\"\"\" _curie_converter : Converter = None def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path ) def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) @property def derived_specification ( self ) -> Optional [ TransformationSpecification ]: if self . _derived_specification is None : if self . specification is None : return None self . _derived_specification = deepcopy ( self . specification ) induce_missing_values ( self . _derived_specification , self . source_schemaview ) return self . _derived_specification def _get_class_derivation ( self , target_class_name : str ) -> ClassDerivation : spec = self . derived_specification matching_tgt_class_derivs = [ deriv for deriv in spec . class_derivations . values () if deriv . populated_from == target_class_name or ( not deriv . populated_from and target_class_name == deriv . name ) ] logger . debug ( f \"Target class derivations= { matching_tgt_class_derivs } \" ) if len ( matching_tgt_class_derivs ) != 1 : raise ValueError ( f \"Could not find class derivation for { target_class_name } (results= { len ( matching_tgt_class_derivs ) } )\" ) cd = matching_tgt_class_derivs [ 0 ] ancmap = self . _class_derivation_ancestors ( cd ) if ancmap : cd = deepcopy ( cd ) for anc in ancmap . values (): for k , v in anc . __dict__ . items (): if v is not None and v != []: curr_v = getattr ( cd , k , None ) if isinstance ( curr_v , list ): curr_v . extend ( v ) elif isinstance ( curr_v , dict ): curr_v . update ({ ** v , ** curr_v }) else : if curr_v is None : setattr ( cd , k , v ) return cd def _class_derivation_ancestors ( self , cd : ClassDerivation ) -> Dict [ str , ClassDerivation ]: \"\"\" Returns a map of all class derivations that are ancestors of the given class derivation. :param cd: :return: \"\"\" spec = self . specification ancestors = {} parents = cd . mixins + ([ cd . is_a ] if cd . is_a else []) for parent in parents : ancestors [ parent ] = spec . class_derivations [ parent ] ancestors . update ( self . _class_derivation_ancestors ( spec . class_derivations [ parent ])) return ancestors def _get_enum_derivation ( self , target_enum_name : str ) -> EnumDerivation : spec = self . derived_specification matching_tgt_enum_derivs = [ deriv for deriv in spec . enum_derivations . values () if deriv . populated_from == target_enum_name or ( not deriv . populated_from and target_enum_name == deriv . name ) ] logger . debug ( f \"Target enum derivations= { matching_tgt_enum_derivs } \" ) if len ( matching_tgt_enum_derivs ) != 1 : raise ValueError ( f \"Could not find what to derive from a source { target_enum_name } \" ) return matching_tgt_enum_derivs [ 0 ] def _is_coerce_to_multivalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as in [ CollectionType . MultiValued , CollectionType . MultiValuedDict , CollectionType . MultiValuedDict , ]: return True if slot_derivation . stringification and slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if slot . multivalued : return True return False def _is_coerce_to_singlevalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as == CollectionType ( CollectionType . SingleValued ): return True if slot_derivation . stringification and not slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if not slot . multivalued : return True return False def _coerce_datatype ( self , v : Any , target_range : Optional [ str ]) -> Any : if target_range is None : return v if isinstance ( v , list ): return [ self . _coerce_datatype ( v1 , target_range ) for v1 in v ] if isinstance ( v , dict ): return { k : self . _coerce_datatype ( v1 , target_range ) for k , v1 in v . items ()} cmap = { \"integer\" : int , \"float\" : float , \"string\" : str , \"boolean\" : bool , } cls = cmap . get ( target_range , None ) if not cls : logger . warning ( f \"Unknown target range { target_range } \" ) return v if isinstance ( v , cls ): return v return cls ( v ) @property def curie_converter ( self ) -> Converter : if not self . _curie_converter : self . _curie_converter = Converter ([]) for prefix in self . source_schemaview . schema . prefixes . values (): self . _curie_converter . add_prefix ( prefix . prefix_prefix , prefix . prefix_reference ) for prefix in self . specification . prefixes . values (): self . _curie_converter . add_prefix ( prefix . key , prefix . value ) return self . _curie_converter def expand_curie ( self , curie : str ) -> str : return self . curie_converter . expand ( curie ) def compress_uri ( self , uri : str ) -> str : return self . curie_converter . compress ( uri ) source_schemaview : SchemaView = None class-attribute instance-attribute A view over the schema describing the input/source object. specification : TransformationSpecification = None class-attribute instance-attribute A specification of how to generate target objects from source objects. target_schemaview : Optional [ SchemaView ] = None class-attribute instance-attribute A view over the schema describing the output/target object. unrestricted_eval : bool = field ( default = False ) class-attribute instance-attribute Set to True to allow arbitrary evals as part of transformation. create_transformer_specification ( obj ) Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) load_source_schema ( path ) Sets source_schemaview from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 89 90 91 92 93 94 95 96 97 98 def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path ) load_transformer_specification ( path ) Sets specification from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) map_database ( source_database , target_database = None , ** kwargs ) Transform source resource. :param source_database: :param target_database: :param kwargs: :return: Source code in src\\linkml_map\\transformer\\transformer.py 76 77 78 79 80 81 82 83 84 85 86 87 def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError map_object ( obj , source_type = None , ** kwargs ) Transform source object into an instance of the target class. :param obj: :param source_type: :return: Source code in src\\linkml_map\\transformer\\transformer.py 66 67 68 69 70 71 72 73 74 def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError ObjectTransformer Bases: Transformer A Transformer that works on in-memory dict objects. This works recursively Source code in src\\linkml_map\\transformer\\object_transformer.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 @dataclass class ObjectTransformer ( Transformer ): \"\"\" A Transformer that works on in-memory dict objects. This works recursively \"\"\" object_index : ObjectIndex = None def index ( self , source_obj : Any , target : str = None ): \"\"\" Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into \"\"\" if isinstance ( source_obj , dict ): if target is None : [ target ] = [ c . name for c in self . source_schemaview . all_classes () . values () if c . tree_root ] if target is None : raise ValueError ( f \"target must be passed if source_obj is dict: { source_obj } \" ) source_obj_typed = dynamic_object ( source_obj , self . source_schemaview , target ) self . object_index = ObjectIndex ( source_obj_typed , schemaview = self . source_schemaview ) else : self . object_index = ObjectIndex ( source_obj , schemaview = self . source_schemaview ) def map_object ( self , source_obj : OBJECT_TYPE , source_type : str = None , target_type : str = None , ) -> Union [ DICT_OBJ , Any ]: \"\"\" Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary \"\"\" sv = self . source_schemaview if source_type is None and sv is None : # TODO: use smarter method source_type = list ( self . specification . class_derivations . values ())[ 0 ] . name if source_type is None and sv is not None : source_types = [ c . name for c in sv . all_classes () . values () if c . tree_root ] if len ( source_types ) == 1 : source_type = source_types [ 0 ] elif len ( source_types ) > 1 : raise ValueError ( \"No source type specified and multiple root classes found\" ) elif len ( source_types ) == 0 : if len ( sv . all_classes ()) == 1 : source_type = list ( sv . all_classes () . keys ())[ 0 ] else : raise ValueError ( \"No source type specified and no root classes found\" ) if source_type in sv . all_types (): if target_type : if target_type == \"string\" : return str ( source_obj ) elif target_type == \"integer\" : return int ( source_obj ) elif target_type == \"float\" or target_type == \"double\" : return float ( source_obj ) elif target_type == \"uri\" : return self . expand_curie ( source_obj ) elif target_type == \"curie\" : return self . compress_uri ( source_obj ) return source_obj if source_type in sv . all_enums (): # TODO: enum derivations return self . transform_enum ( source_obj , source_type , source_obj ) # return str(source_obj) source_obj_typed = None if isinstance ( source_obj , ( BaseModel , YAMLRoot )): # ensure dict source_obj_typed = source_obj source_obj = vars ( source_obj ) if not isinstance ( source_obj , dict ): logger . warning ( f \"Unexpected: { source_obj } for type { source_type } \" ) return source_obj class_deriv = self . _get_class_derivation ( source_type ) tgt_attrs = {} bindings = None # map each slot assignment in source_obj, if there is a slot_derivation for slot_derivation in class_deriv . slot_derivations . values (): v = None source_class_slot = None if slot_derivation . unit_conversion : v = self . _perform_unit_conversion ( slot_derivation , source_obj , sv , source_type ) elif slot_derivation . expr : if bindings is None : bindings = Bindings ( self , source_obj = source_obj , source_obj_typed = source_obj_typed , source_type = source_type , sv = sv , bindings = { \"NULL\" : None }, ) try : v = eval_expr_with_mapping ( slot_derivation . expr , bindings ) except Exception : if not self . unrestricted_eval : raise RuntimeError ( f \"Expression not in safe subset: { slot_derivation . expr } \" ) ctxt_obj , _ = bindings . get_ctxt_obj_and_dict () aeval = Interpreter ( usersyms = { \"src\" : ctxt_obj , \"target\" : None }) aeval ( slot_derivation . expr ) v = aeval . symtable [ \"target\" ] elif slot_derivation . populated_from : v = source_obj . get ( slot_derivation . populated_from , None ) source_class_slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) elif slot_derivation . sources : vmap = { s : source_obj . get ( s , None ) for s in slot_derivation . sources } vmap = { k : v for k , v in vmap . items () if v is not None } if len ( vmap . keys ()) > 1 : raise ValueError ( f \"Multiple sources for { slot_derivation . name } : { vmap } \" ) elif len ( vmap . keys ()) == 1 : v = list ( vmap . values ())[ 0 ] source_class_slot_name = list ( vmap . keys ())[ 0 ] source_class_slot = sv . induced_slot ( source_class_slot_name , source_type ) else : v = None source_class_slot = None logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) else : source_class_slot = sv . induced_slot ( slot_derivation . name , source_type ) v = source_obj . get ( slot_derivation . name , None ) if source_class_slot and v is not None : # slot is mapped and there is a value in the assignment target_range = slot_derivation . range source_class_slot_range = source_class_slot . range if source_class_slot . multivalued : if isinstance ( v , list ): v = [ self . map_object ( v1 , source_class_slot_range , target_range ) for v1 in v ] elif isinstance ( v , dict ): v = { k1 : self . map_object ( v1 , source_class_slot_range , target_range ) for k1 , v1 in v . items () } else : v = [ v ] else : v = self . map_object ( v , source_class_slot_range , target_range ) if ( self . _is_coerce_to_multivalued ( slot_derivation , class_deriv ) and v is not None and not isinstance ( v , list ) ): v = self . _singlevalued_to_multivalued ( v , slot_derivation ) if self . _is_coerce_to_singlevalued ( slot_derivation , class_deriv ) and isinstance ( v , list ): v = self . _multivalued_to_singlevalued ( v , slot_derivation ) v = self . _coerce_datatype ( v , target_range ) if slot_derivation . dictionary_key and isinstance ( v , list ): # List to CompactDict v = { v1 [ slot_derivation . dictionary_key ]: v1 for v1 in v } for v1 in v . values (): del v1 [ slot_derivation . dictionary_key ] elif ( slot_derivation . cast_collection_as and slot_derivation . cast_collection_as == CollectionType . MultiValuedList and isinstance ( v , dict ) ): # CompactDict to List src_rng = source_class_slot . range src_rng_id_slot = self . source_schemaview . get_identifier_slot ( src_rng , use_key = True ) if src_rng_id_slot : v = [{ ** v1 , src_rng_id_slot . name : k } for k , v1 in v . items ()] else : v = list ( v . values ()) tgt_attrs [ str ( slot_derivation . name )] = v return tgt_attrs def _perform_unit_conversion ( self , slot_derivation : SlotDerivation , source_obj : Any , sv : SchemaView , source_type : str ) -> Union [ float , Dict ]: uc = slot_derivation . unit_conversion curr_v = source_obj . get ( slot_derivation . populated_from , None ) system = UnitSystem . UCUM if curr_v is not None : slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) to_unit = uc . target_unit if uc . source_unit_slot : from_unit = curr_v . get ( uc . source_unit_slot , None ) if from_unit is None : raise ValueError ( f \"Could not determine unit from { curr_v } \" f \" using { uc . source_unit_slot } \" ) magnitude = curr_v . get ( uc . source_magnitude_slot , None ) if magnitude is None : raise ValueError ( f \"Could not determine magnitude from { curr_v } \" f \" using { uc . source_magnitude_slot } \" ) else : if slot . unit . ucum_code : from_unit = slot . unit . ucum_code elif slot . unit . iec61360code : from_unit = slot . unit . iec61360code system = UnitSystem . IEC61360 else : system = None if slot . unit . symbol : from_unit = slot . unit . symbol elif slot . unit . abbreviation : from_unit = slot . unit . abbreviation elif slot . unit . descriptive_name : from_unit = slot . unit . descriptive_name else : raise NotImplementedError ( f \"Cannot determine unit system for { slot . unit } \" ) magnitude = curr_v if not from_unit : raise ValueError ( f \"Could not determine from_unit for { slot_derivation } \" ) if not to_unit : to_unit = from_unit # raise ValueError(f\"Could not determine to_unit for {slot_derivation}\") if from_unit == to_unit : v = magnitude else : v = convert_units ( magnitude , from_unit = from_unit , to_unit = to_unit , system = system , ) if uc . target_magnitude_slot : v = { uc . target_magnitude_slot : v , uc . target_unit_slot : to_unit } return v def _multivalued_to_singlevalued ( self , vs : List [ Any ], slot_derivation : SlotDerivation ) -> Any : if slot_derivation . stringification : stringification = slot_derivation . stringification delimiter = stringification . delimiter if delimiter : return delimiter . join ( vs ) elif stringification . syntax : if stringification . syntax == SerializationSyntaxType . JSON : return json . dumps ( vs ) elif stringification . syntax == SerializationSyntaxType . YAML : return yaml . dump ( vs , default_flow_style = True ) . strip () else : raise ValueError ( f \"Unknown syntax: { stringification . syntax } \" ) else : raise ValueError ( f \"Cannot convert multivalued to single valued: { vs } ; no delimiter\" ) if len ( vs ) > 1 : raise ValueError ( f \"Cannot coerce multiple values { vs } \" ) if len ( vs ) == 0 : return None else : return vs [ 0 ] def _singlevalued_to_multivalued ( self , v : Any , slot_derivation : SlotDerivation ) -> List [ Any ]: stringification = slot_derivation . stringification if stringification : delimiter = stringification . delimiter if delimiter : vs = v . split ( slot_derivation . stringification . delimiter ) if vs == [ \"\" ]: vs = [] elif stringification . syntax : syntax = stringification . syntax if syntax == SerializationSyntaxType . JSON : vs = json . loads ( v ) elif syntax == SerializationSyntaxType . YAML : vs = yaml . safe_load ( v ) else : raise ValueError ( f \"Unknown syntax: { syntax } \" ) else : raise ValueError ( f \"Cannot convert single valued to multivalued: { v } ; no delimiter\" ) return vs return [ v ] def transform_object ( self , source_obj : Union [ YAMLRoot , BaseModel ], target_class : Optional [ Union [ Type [ YAMLRoot ], Type [ BaseModel ]]] = None , ) -> Union [ YAMLRoot , BaseModel ]: \"\"\" Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] \"\"\" if not target_class : raise ValueError ( \"No target_class specified for transform_object\" ) source_type = type ( source_obj ) source_type_name = source_type . __name__ # if isinstance(source_obj, YAMLRoot): # source_obj_dict = json_dumper.to_dict(source_obj) # elif isinstance(source_obj, BaseModel): # source_obj_dict = source_obj.dict() # else: # raise ValueError(f\"Do not know how to handle type: {typ}\") tr_obj_dict = self . map_object ( source_obj , source_type_name ) return target_class ( ** tr_obj_dict ) def transform_enum ( self , source_value : str , enum_name : str , source_obj : Any ) -> Optional [ str ]: enum_deriv = self . _get_enum_derivation ( enum_name ) if enum_deriv . expr : try : if enum_deriv . expr : v = eval_expr ( enum_deriv . expr , ** source_obj , NULL = None ) except Exception : aeval = Interpreter ( usersyms = { \"src\" : source_obj , \"target\" : None }) aeval ( enum_deriv . expr ) v = aeval . symtable [ \"target\" ] if v is not None : return v for pv_deriv in enum_deriv . permissible_value_derivations . values (): if source_value == pv_deriv . populated_from : return pv_deriv . name if source_value in pv_deriv . sources : return pv_deriv . name if enum_deriv . mirror_source : return str ( source_value ) else : return None index ( source_obj , target = None ) Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into Source code in src\\linkml_map\\transformer\\object_transformer.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def index ( self , source_obj : Any , target : str = None ): \"\"\" Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into \"\"\" if isinstance ( source_obj , dict ): if target is None : [ target ] = [ c . name for c in self . source_schemaview . all_classes () . values () if c . tree_root ] if target is None : raise ValueError ( f \"target must be passed if source_obj is dict: { source_obj } \" ) source_obj_typed = dynamic_object ( source_obj , self . source_schemaview , target ) self . object_index = ObjectIndex ( source_obj_typed , schemaview = self . source_schemaview ) else : self . object_index = ObjectIndex ( source_obj , schemaview = self . source_schemaview ) map_object ( source_obj , source_type = None , target_type = None ) Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary Source code in src\\linkml_map\\transformer\\object_transformer.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def map_object ( self , source_obj : OBJECT_TYPE , source_type : str = None , target_type : str = None , ) -> Union [ DICT_OBJ , Any ]: \"\"\" Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary \"\"\" sv = self . source_schemaview if source_type is None and sv is None : # TODO: use smarter method source_type = list ( self . specification . class_derivations . values ())[ 0 ] . name if source_type is None and sv is not None : source_types = [ c . name for c in sv . all_classes () . values () if c . tree_root ] if len ( source_types ) == 1 : source_type = source_types [ 0 ] elif len ( source_types ) > 1 : raise ValueError ( \"No source type specified and multiple root classes found\" ) elif len ( source_types ) == 0 : if len ( sv . all_classes ()) == 1 : source_type = list ( sv . all_classes () . keys ())[ 0 ] else : raise ValueError ( \"No source type specified and no root classes found\" ) if source_type in sv . all_types (): if target_type : if target_type == \"string\" : return str ( source_obj ) elif target_type == \"integer\" : return int ( source_obj ) elif target_type == \"float\" or target_type == \"double\" : return float ( source_obj ) elif target_type == \"uri\" : return self . expand_curie ( source_obj ) elif target_type == \"curie\" : return self . compress_uri ( source_obj ) return source_obj if source_type in sv . all_enums (): # TODO: enum derivations return self . transform_enum ( source_obj , source_type , source_obj ) # return str(source_obj) source_obj_typed = None if isinstance ( source_obj , ( BaseModel , YAMLRoot )): # ensure dict source_obj_typed = source_obj source_obj = vars ( source_obj ) if not isinstance ( source_obj , dict ): logger . warning ( f \"Unexpected: { source_obj } for type { source_type } \" ) return source_obj class_deriv = self . _get_class_derivation ( source_type ) tgt_attrs = {} bindings = None # map each slot assignment in source_obj, if there is a slot_derivation for slot_derivation in class_deriv . slot_derivations . values (): v = None source_class_slot = None if slot_derivation . unit_conversion : v = self . _perform_unit_conversion ( slot_derivation , source_obj , sv , source_type ) elif slot_derivation . expr : if bindings is None : bindings = Bindings ( self , source_obj = source_obj , source_obj_typed = source_obj_typed , source_type = source_type , sv = sv , bindings = { \"NULL\" : None }, ) try : v = eval_expr_with_mapping ( slot_derivation . expr , bindings ) except Exception : if not self . unrestricted_eval : raise RuntimeError ( f \"Expression not in safe subset: { slot_derivation . expr } \" ) ctxt_obj , _ = bindings . get_ctxt_obj_and_dict () aeval = Interpreter ( usersyms = { \"src\" : ctxt_obj , \"target\" : None }) aeval ( slot_derivation . expr ) v = aeval . symtable [ \"target\" ] elif slot_derivation . populated_from : v = source_obj . get ( slot_derivation . populated_from , None ) source_class_slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) elif slot_derivation . sources : vmap = { s : source_obj . get ( s , None ) for s in slot_derivation . sources } vmap = { k : v for k , v in vmap . items () if v is not None } if len ( vmap . keys ()) > 1 : raise ValueError ( f \"Multiple sources for { slot_derivation . name } : { vmap } \" ) elif len ( vmap . keys ()) == 1 : v = list ( vmap . values ())[ 0 ] source_class_slot_name = list ( vmap . keys ())[ 0 ] source_class_slot = sv . induced_slot ( source_class_slot_name , source_type ) else : v = None source_class_slot = None logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) else : source_class_slot = sv . induced_slot ( slot_derivation . name , source_type ) v = source_obj . get ( slot_derivation . name , None ) if source_class_slot and v is not None : # slot is mapped and there is a value in the assignment target_range = slot_derivation . range source_class_slot_range = source_class_slot . range if source_class_slot . multivalued : if isinstance ( v , list ): v = [ self . map_object ( v1 , source_class_slot_range , target_range ) for v1 in v ] elif isinstance ( v , dict ): v = { k1 : self . map_object ( v1 , source_class_slot_range , target_range ) for k1 , v1 in v . items () } else : v = [ v ] else : v = self . map_object ( v , source_class_slot_range , target_range ) if ( self . _is_coerce_to_multivalued ( slot_derivation , class_deriv ) and v is not None and not isinstance ( v , list ) ): v = self . _singlevalued_to_multivalued ( v , slot_derivation ) if self . _is_coerce_to_singlevalued ( slot_derivation , class_deriv ) and isinstance ( v , list ): v = self . _multivalued_to_singlevalued ( v , slot_derivation ) v = self . _coerce_datatype ( v , target_range ) if slot_derivation . dictionary_key and isinstance ( v , list ): # List to CompactDict v = { v1 [ slot_derivation . dictionary_key ]: v1 for v1 in v } for v1 in v . values (): del v1 [ slot_derivation . dictionary_key ] elif ( slot_derivation . cast_collection_as and slot_derivation . cast_collection_as == CollectionType . MultiValuedList and isinstance ( v , dict ) ): # CompactDict to List src_rng = source_class_slot . range src_rng_id_slot = self . source_schemaview . get_identifier_slot ( src_rng , use_key = True ) if src_rng_id_slot : v = [{ ** v1 , src_rng_id_slot . name : k } for k , v1 in v . items ()] else : v = list ( v . values ()) tgt_attrs [ str ( slot_derivation . name )] = v return tgt_attrs transform_object ( source_obj , target_class = None ) Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] Source code in src\\linkml_map\\transformer\\object_transformer.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def transform_object ( self , source_obj : Union [ YAMLRoot , BaseModel ], target_class : Optional [ Union [ Type [ YAMLRoot ], Type [ BaseModel ]]] = None , ) -> Union [ YAMLRoot , BaseModel ]: \"\"\" Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] \"\"\" if not target_class : raise ValueError ( \"No target_class specified for transform_object\" ) source_type = type ( source_obj ) source_type_name = source_type . __name__ # if isinstance(source_obj, YAMLRoot): # source_obj_dict = json_dumper.to_dict(source_obj) # elif isinstance(source_obj, BaseModel): # source_obj_dict = source_obj.dict() # else: # raise ValueError(f\"Do not know how to handle type: {typ}\") tr_obj_dict = self . map_object ( source_obj , source_type_name ) return target_class ( ** tr_obj_dict )","title":"Transformer Package"},{"location":"schema/transformer/#transformer-package","text":"","title":"Transformer Package"},{"location":"schema/transformer/#transformer-base-class","text":"Bases: ABC Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this Source code in src\\linkml_map\\transformer\\transformer.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @dataclass class Transformer ( ABC ): \"\"\" Base class for all transformers. A transformer will generate an instance of a target class from an instance of a source class, making use of a specification. This is an abstract class. Different implementations will subclass this \"\"\" specification : TransformationSpecification = None \"\"\"A specification of how to generate target objects from source objects.\"\"\" source_schemaview : SchemaView = None \"\"\"A view over the schema describing the input/source object.\"\"\" _derived_specification : TransformationSpecification = None \"\"\"A specification with inferred missing values.\"\"\" target_schemaview : Optional [ SchemaView ] = None \"\"\"A view over the schema describing the output/target object.\"\"\" unrestricted_eval : bool = field ( default = False ) \"\"\"Set to True to allow arbitrary evals as part of transformation.\"\"\" _curie_converter : Converter = None def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path ) def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj ) @property def derived_specification ( self ) -> Optional [ TransformationSpecification ]: if self . _derived_specification is None : if self . specification is None : return None self . _derived_specification = deepcopy ( self . specification ) induce_missing_values ( self . _derived_specification , self . source_schemaview ) return self . _derived_specification def _get_class_derivation ( self , target_class_name : str ) -> ClassDerivation : spec = self . derived_specification matching_tgt_class_derivs = [ deriv for deriv in spec . class_derivations . values () if deriv . populated_from == target_class_name or ( not deriv . populated_from and target_class_name == deriv . name ) ] logger . debug ( f \"Target class derivations= { matching_tgt_class_derivs } \" ) if len ( matching_tgt_class_derivs ) != 1 : raise ValueError ( f \"Could not find class derivation for { target_class_name } (results= { len ( matching_tgt_class_derivs ) } )\" ) cd = matching_tgt_class_derivs [ 0 ] ancmap = self . _class_derivation_ancestors ( cd ) if ancmap : cd = deepcopy ( cd ) for anc in ancmap . values (): for k , v in anc . __dict__ . items (): if v is not None and v != []: curr_v = getattr ( cd , k , None ) if isinstance ( curr_v , list ): curr_v . extend ( v ) elif isinstance ( curr_v , dict ): curr_v . update ({ ** v , ** curr_v }) else : if curr_v is None : setattr ( cd , k , v ) return cd def _class_derivation_ancestors ( self , cd : ClassDerivation ) -> Dict [ str , ClassDerivation ]: \"\"\" Returns a map of all class derivations that are ancestors of the given class derivation. :param cd: :return: \"\"\" spec = self . specification ancestors = {} parents = cd . mixins + ([ cd . is_a ] if cd . is_a else []) for parent in parents : ancestors [ parent ] = spec . class_derivations [ parent ] ancestors . update ( self . _class_derivation_ancestors ( spec . class_derivations [ parent ])) return ancestors def _get_enum_derivation ( self , target_enum_name : str ) -> EnumDerivation : spec = self . derived_specification matching_tgt_enum_derivs = [ deriv for deriv in spec . enum_derivations . values () if deriv . populated_from == target_enum_name or ( not deriv . populated_from and target_enum_name == deriv . name ) ] logger . debug ( f \"Target enum derivations= { matching_tgt_enum_derivs } \" ) if len ( matching_tgt_enum_derivs ) != 1 : raise ValueError ( f \"Could not find what to derive from a source { target_enum_name } \" ) return matching_tgt_enum_derivs [ 0 ] def _is_coerce_to_multivalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as in [ CollectionType . MultiValued , CollectionType . MultiValuedDict , CollectionType . MultiValuedDict , ]: return True if slot_derivation . stringification and slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if slot . multivalued : return True return False def _is_coerce_to_singlevalued ( self , slot_derivation : SlotDerivation , class_derivation : ClassDerivation ): cast_as = slot_derivation . cast_collection_as if cast_as and cast_as == CollectionType ( CollectionType . SingleValued ): return True if slot_derivation . stringification and not slot_derivation . stringification . reversed : return True sv = self . target_schemaview if sv : slot = sv . induced_slot ( slot_derivation . name , class_derivation . name ) if not slot . multivalued : return True return False def _coerce_datatype ( self , v : Any , target_range : Optional [ str ]) -> Any : if target_range is None : return v if isinstance ( v , list ): return [ self . _coerce_datatype ( v1 , target_range ) for v1 in v ] if isinstance ( v , dict ): return { k : self . _coerce_datatype ( v1 , target_range ) for k , v1 in v . items ()} cmap = { \"integer\" : int , \"float\" : float , \"string\" : str , \"boolean\" : bool , } cls = cmap . get ( target_range , None ) if not cls : logger . warning ( f \"Unknown target range { target_range } \" ) return v if isinstance ( v , cls ): return v return cls ( v ) @property def curie_converter ( self ) -> Converter : if not self . _curie_converter : self . _curie_converter = Converter ([]) for prefix in self . source_schemaview . schema . prefixes . values (): self . _curie_converter . add_prefix ( prefix . prefix_prefix , prefix . prefix_reference ) for prefix in self . specification . prefixes . values (): self . _curie_converter . add_prefix ( prefix . key , prefix . value ) return self . _curie_converter def expand_curie ( self , curie : str ) -> str : return self . curie_converter . expand ( curie ) def compress_uri ( self , uri : str ) -> str : return self . curie_converter . compress ( uri )","title":"Transformer (Base Class)"},{"location":"schema/transformer/#linkml_map.transformer.transformer.Transformer.source_schemaview","text":"A view over the schema describing the input/source object.","title":"source_schemaview"},{"location":"schema/transformer/#linkml_map.transformer.transformer.Transformer.specification","text":"A specification of how to generate target objects from source objects.","title":"specification"},{"location":"schema/transformer/#linkml_map.transformer.transformer.Transformer.target_schemaview","text":"A view over the schema describing the output/target object.","title":"target_schemaview"},{"location":"schema/transformer/#linkml_map.transformer.transformer.Transformer.unrestricted_eval","text":"Set to True to allow arbitrary evals as part of transformation.","title":"unrestricted_eval"},{"location":"schema/transformer/#linkml_map.transformer.transformer.Transformer.create_transformer_specification","text":"Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def create_transformer_specification ( self , obj : Dict [ str , Any ]): \"\"\" Creates specification from a dict. TODO: this will no longer be necessary when pydantic supports inlined as dict :param path: :return: \"\"\" normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj )","title":"create_transformer_specification"},{"location":"schema/transformer/#linkml_map.transformer.transformer.Transformer.load_source_schema","text":"Sets source_schemaview from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 89 90 91 92 93 94 95 96 97 98 def load_source_schema ( self , path : Union [ str , Path , dict ]): \"\"\" Sets source_schemaview from a schema path. :param path: :return: \"\"\" if isinstance ( path , Path ): path = str ( path ) self . source_schemaview = SchemaView ( path )","title":"load_source_schema"},{"location":"schema/transformer/#linkml_map.transformer.transformer.Transformer.load_transformer_specification","text":"Sets specification from a schema path. :param path: :return: Source code in src\\linkml_map\\transformer\\transformer.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def load_transformer_specification ( self , path : Union [ str , Path ]): \"\"\" Sets specification from a schema path. :param path: :return: \"\"\" # self.specification = yaml_loader.load(str(path), TransformationSpecification) with open ( path ) as f : obj = yaml . safe_load ( f ) # necessary to expand first normalizer = ReferenceValidator ( package_schemaview ( \"linkml_map.datamodel.transformer_model\" ) ) normalizer . expand_all = True obj = normalizer . normalize ( obj ) self . specification = TransformationSpecification ( ** obj )","title":"load_transformer_specification"},{"location":"schema/transformer/#linkml_map.transformer.transformer.Transformer.map_database","text":"Transform source resource. :param source_database: :param target_database: :param kwargs: :return: Source code in src\\linkml_map\\transformer\\transformer.py 76 77 78 79 80 81 82 83 84 85 86 87 def map_database ( self , source_database : Any , target_database : Optional [ Any ] = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source resource. :param source_database: :param target_database: :param kwargs: :return: \"\"\" raise NotImplementedError","title":"map_database"},{"location":"schema/transformer/#linkml_map.transformer.transformer.Transformer.map_object","text":"Transform source object into an instance of the target class. :param obj: :param source_type: :return: Source code in src\\linkml_map\\transformer\\transformer.py 66 67 68 69 70 71 72 73 74 def map_object ( self , obj : OBJECT_TYPE , source_type : str = None , ** kwargs ) -> OBJECT_TYPE : \"\"\" Transform source object into an instance of the target class. :param obj: :param source_type: :return: \"\"\" raise NotImplementedError","title":"map_object"},{"location":"schema/transformer/#objecttransformer","text":"Bases: Transformer A Transformer that works on in-memory dict objects. This works recursively Source code in src\\linkml_map\\transformer\\object_transformer.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 @dataclass class ObjectTransformer ( Transformer ): \"\"\" A Transformer that works on in-memory dict objects. This works recursively \"\"\" object_index : ObjectIndex = None def index ( self , source_obj : Any , target : str = None ): \"\"\" Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into \"\"\" if isinstance ( source_obj , dict ): if target is None : [ target ] = [ c . name for c in self . source_schemaview . all_classes () . values () if c . tree_root ] if target is None : raise ValueError ( f \"target must be passed if source_obj is dict: { source_obj } \" ) source_obj_typed = dynamic_object ( source_obj , self . source_schemaview , target ) self . object_index = ObjectIndex ( source_obj_typed , schemaview = self . source_schemaview ) else : self . object_index = ObjectIndex ( source_obj , schemaview = self . source_schemaview ) def map_object ( self , source_obj : OBJECT_TYPE , source_type : str = None , target_type : str = None , ) -> Union [ DICT_OBJ , Any ]: \"\"\" Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary \"\"\" sv = self . source_schemaview if source_type is None and sv is None : # TODO: use smarter method source_type = list ( self . specification . class_derivations . values ())[ 0 ] . name if source_type is None and sv is not None : source_types = [ c . name for c in sv . all_classes () . values () if c . tree_root ] if len ( source_types ) == 1 : source_type = source_types [ 0 ] elif len ( source_types ) > 1 : raise ValueError ( \"No source type specified and multiple root classes found\" ) elif len ( source_types ) == 0 : if len ( sv . all_classes ()) == 1 : source_type = list ( sv . all_classes () . keys ())[ 0 ] else : raise ValueError ( \"No source type specified and no root classes found\" ) if source_type in sv . all_types (): if target_type : if target_type == \"string\" : return str ( source_obj ) elif target_type == \"integer\" : return int ( source_obj ) elif target_type == \"float\" or target_type == \"double\" : return float ( source_obj ) elif target_type == \"uri\" : return self . expand_curie ( source_obj ) elif target_type == \"curie\" : return self . compress_uri ( source_obj ) return source_obj if source_type in sv . all_enums (): # TODO: enum derivations return self . transform_enum ( source_obj , source_type , source_obj ) # return str(source_obj) source_obj_typed = None if isinstance ( source_obj , ( BaseModel , YAMLRoot )): # ensure dict source_obj_typed = source_obj source_obj = vars ( source_obj ) if not isinstance ( source_obj , dict ): logger . warning ( f \"Unexpected: { source_obj } for type { source_type } \" ) return source_obj class_deriv = self . _get_class_derivation ( source_type ) tgt_attrs = {} bindings = None # map each slot assignment in source_obj, if there is a slot_derivation for slot_derivation in class_deriv . slot_derivations . values (): v = None source_class_slot = None if slot_derivation . unit_conversion : v = self . _perform_unit_conversion ( slot_derivation , source_obj , sv , source_type ) elif slot_derivation . expr : if bindings is None : bindings = Bindings ( self , source_obj = source_obj , source_obj_typed = source_obj_typed , source_type = source_type , sv = sv , bindings = { \"NULL\" : None }, ) try : v = eval_expr_with_mapping ( slot_derivation . expr , bindings ) except Exception : if not self . unrestricted_eval : raise RuntimeError ( f \"Expression not in safe subset: { slot_derivation . expr } \" ) ctxt_obj , _ = bindings . get_ctxt_obj_and_dict () aeval = Interpreter ( usersyms = { \"src\" : ctxt_obj , \"target\" : None }) aeval ( slot_derivation . expr ) v = aeval . symtable [ \"target\" ] elif slot_derivation . populated_from : v = source_obj . get ( slot_derivation . populated_from , None ) source_class_slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) elif slot_derivation . sources : vmap = { s : source_obj . get ( s , None ) for s in slot_derivation . sources } vmap = { k : v for k , v in vmap . items () if v is not None } if len ( vmap . keys ()) > 1 : raise ValueError ( f \"Multiple sources for { slot_derivation . name } : { vmap } \" ) elif len ( vmap . keys ()) == 1 : v = list ( vmap . values ())[ 0 ] source_class_slot_name = list ( vmap . keys ())[ 0 ] source_class_slot = sv . induced_slot ( source_class_slot_name , source_type ) else : v = None source_class_slot = None logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) else : source_class_slot = sv . induced_slot ( slot_derivation . name , source_type ) v = source_obj . get ( slot_derivation . name , None ) if source_class_slot and v is not None : # slot is mapped and there is a value in the assignment target_range = slot_derivation . range source_class_slot_range = source_class_slot . range if source_class_slot . multivalued : if isinstance ( v , list ): v = [ self . map_object ( v1 , source_class_slot_range , target_range ) for v1 in v ] elif isinstance ( v , dict ): v = { k1 : self . map_object ( v1 , source_class_slot_range , target_range ) for k1 , v1 in v . items () } else : v = [ v ] else : v = self . map_object ( v , source_class_slot_range , target_range ) if ( self . _is_coerce_to_multivalued ( slot_derivation , class_deriv ) and v is not None and not isinstance ( v , list ) ): v = self . _singlevalued_to_multivalued ( v , slot_derivation ) if self . _is_coerce_to_singlevalued ( slot_derivation , class_deriv ) and isinstance ( v , list ): v = self . _multivalued_to_singlevalued ( v , slot_derivation ) v = self . _coerce_datatype ( v , target_range ) if slot_derivation . dictionary_key and isinstance ( v , list ): # List to CompactDict v = { v1 [ slot_derivation . dictionary_key ]: v1 for v1 in v } for v1 in v . values (): del v1 [ slot_derivation . dictionary_key ] elif ( slot_derivation . cast_collection_as and slot_derivation . cast_collection_as == CollectionType . MultiValuedList and isinstance ( v , dict ) ): # CompactDict to List src_rng = source_class_slot . range src_rng_id_slot = self . source_schemaview . get_identifier_slot ( src_rng , use_key = True ) if src_rng_id_slot : v = [{ ** v1 , src_rng_id_slot . name : k } for k , v1 in v . items ()] else : v = list ( v . values ()) tgt_attrs [ str ( slot_derivation . name )] = v return tgt_attrs def _perform_unit_conversion ( self , slot_derivation : SlotDerivation , source_obj : Any , sv : SchemaView , source_type : str ) -> Union [ float , Dict ]: uc = slot_derivation . unit_conversion curr_v = source_obj . get ( slot_derivation . populated_from , None ) system = UnitSystem . UCUM if curr_v is not None : slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) to_unit = uc . target_unit if uc . source_unit_slot : from_unit = curr_v . get ( uc . source_unit_slot , None ) if from_unit is None : raise ValueError ( f \"Could not determine unit from { curr_v } \" f \" using { uc . source_unit_slot } \" ) magnitude = curr_v . get ( uc . source_magnitude_slot , None ) if magnitude is None : raise ValueError ( f \"Could not determine magnitude from { curr_v } \" f \" using { uc . source_magnitude_slot } \" ) else : if slot . unit . ucum_code : from_unit = slot . unit . ucum_code elif slot . unit . iec61360code : from_unit = slot . unit . iec61360code system = UnitSystem . IEC61360 else : system = None if slot . unit . symbol : from_unit = slot . unit . symbol elif slot . unit . abbreviation : from_unit = slot . unit . abbreviation elif slot . unit . descriptive_name : from_unit = slot . unit . descriptive_name else : raise NotImplementedError ( f \"Cannot determine unit system for { slot . unit } \" ) magnitude = curr_v if not from_unit : raise ValueError ( f \"Could not determine from_unit for { slot_derivation } \" ) if not to_unit : to_unit = from_unit # raise ValueError(f\"Could not determine to_unit for {slot_derivation}\") if from_unit == to_unit : v = magnitude else : v = convert_units ( magnitude , from_unit = from_unit , to_unit = to_unit , system = system , ) if uc . target_magnitude_slot : v = { uc . target_magnitude_slot : v , uc . target_unit_slot : to_unit } return v def _multivalued_to_singlevalued ( self , vs : List [ Any ], slot_derivation : SlotDerivation ) -> Any : if slot_derivation . stringification : stringification = slot_derivation . stringification delimiter = stringification . delimiter if delimiter : return delimiter . join ( vs ) elif stringification . syntax : if stringification . syntax == SerializationSyntaxType . JSON : return json . dumps ( vs ) elif stringification . syntax == SerializationSyntaxType . YAML : return yaml . dump ( vs , default_flow_style = True ) . strip () else : raise ValueError ( f \"Unknown syntax: { stringification . syntax } \" ) else : raise ValueError ( f \"Cannot convert multivalued to single valued: { vs } ; no delimiter\" ) if len ( vs ) > 1 : raise ValueError ( f \"Cannot coerce multiple values { vs } \" ) if len ( vs ) == 0 : return None else : return vs [ 0 ] def _singlevalued_to_multivalued ( self , v : Any , slot_derivation : SlotDerivation ) -> List [ Any ]: stringification = slot_derivation . stringification if stringification : delimiter = stringification . delimiter if delimiter : vs = v . split ( slot_derivation . stringification . delimiter ) if vs == [ \"\" ]: vs = [] elif stringification . syntax : syntax = stringification . syntax if syntax == SerializationSyntaxType . JSON : vs = json . loads ( v ) elif syntax == SerializationSyntaxType . YAML : vs = yaml . safe_load ( v ) else : raise ValueError ( f \"Unknown syntax: { syntax } \" ) else : raise ValueError ( f \"Cannot convert single valued to multivalued: { v } ; no delimiter\" ) return vs return [ v ] def transform_object ( self , source_obj : Union [ YAMLRoot , BaseModel ], target_class : Optional [ Union [ Type [ YAMLRoot ], Type [ BaseModel ]]] = None , ) -> Union [ YAMLRoot , BaseModel ]: \"\"\" Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] \"\"\" if not target_class : raise ValueError ( \"No target_class specified for transform_object\" ) source_type = type ( source_obj ) source_type_name = source_type . __name__ # if isinstance(source_obj, YAMLRoot): # source_obj_dict = json_dumper.to_dict(source_obj) # elif isinstance(source_obj, BaseModel): # source_obj_dict = source_obj.dict() # else: # raise ValueError(f\"Do not know how to handle type: {typ}\") tr_obj_dict = self . map_object ( source_obj , source_type_name ) return target_class ( ** tr_obj_dict ) def transform_enum ( self , source_value : str , enum_name : str , source_obj : Any ) -> Optional [ str ]: enum_deriv = self . _get_enum_derivation ( enum_name ) if enum_deriv . expr : try : if enum_deriv . expr : v = eval_expr ( enum_deriv . expr , ** source_obj , NULL = None ) except Exception : aeval = Interpreter ( usersyms = { \"src\" : source_obj , \"target\" : None }) aeval ( enum_deriv . expr ) v = aeval . symtable [ \"target\" ] if v is not None : return v for pv_deriv in enum_deriv . permissible_value_derivations . values (): if source_value == pv_deriv . populated_from : return pv_deriv . name if source_value in pv_deriv . sources : return pv_deriv . name if enum_deriv . mirror_source : return str ( source_value ) else : return None","title":"ObjectTransformer"},{"location":"schema/transformer/#linkml_map.transformer.object_transformer.ObjectTransformer.index","text":"Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into Source code in src\\linkml_map\\transformer\\object_transformer.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def index ( self , source_obj : Any , target : str = None ): \"\"\" Create an index over a container object. :param source_obj: source data structure to be indexed :param target: class to convert source object into \"\"\" if isinstance ( source_obj , dict ): if target is None : [ target ] = [ c . name for c in self . source_schemaview . all_classes () . values () if c . tree_root ] if target is None : raise ValueError ( f \"target must be passed if source_obj is dict: { source_obj } \" ) source_obj_typed = dynamic_object ( source_obj , self . source_schemaview , target ) self . object_index = ObjectIndex ( source_obj_typed , schemaview = self . source_schemaview ) else : self . object_index = ObjectIndex ( source_obj , schemaview = self . source_schemaview )","title":"index"},{"location":"schema/transformer/#linkml_map.transformer.object_transformer.ObjectTransformer.map_object","text":"Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary Source code in src\\linkml_map\\transformer\\object_transformer.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def map_object ( self , source_obj : OBJECT_TYPE , source_type : str = None , target_type : str = None , ) -> Union [ DICT_OBJ , Any ]: \"\"\" Transform a source object into a target object. :param source_obj: source data structure :param source_type: source_obj instantiates this (may be class, type, or enum) :param target_type: target_obj instantiates this (may be class, type, or enum) :return: transformed data, either as type target_type or a dictionary \"\"\" sv = self . source_schemaview if source_type is None and sv is None : # TODO: use smarter method source_type = list ( self . specification . class_derivations . values ())[ 0 ] . name if source_type is None and sv is not None : source_types = [ c . name for c in sv . all_classes () . values () if c . tree_root ] if len ( source_types ) == 1 : source_type = source_types [ 0 ] elif len ( source_types ) > 1 : raise ValueError ( \"No source type specified and multiple root classes found\" ) elif len ( source_types ) == 0 : if len ( sv . all_classes ()) == 1 : source_type = list ( sv . all_classes () . keys ())[ 0 ] else : raise ValueError ( \"No source type specified and no root classes found\" ) if source_type in sv . all_types (): if target_type : if target_type == \"string\" : return str ( source_obj ) elif target_type == \"integer\" : return int ( source_obj ) elif target_type == \"float\" or target_type == \"double\" : return float ( source_obj ) elif target_type == \"uri\" : return self . expand_curie ( source_obj ) elif target_type == \"curie\" : return self . compress_uri ( source_obj ) return source_obj if source_type in sv . all_enums (): # TODO: enum derivations return self . transform_enum ( source_obj , source_type , source_obj ) # return str(source_obj) source_obj_typed = None if isinstance ( source_obj , ( BaseModel , YAMLRoot )): # ensure dict source_obj_typed = source_obj source_obj = vars ( source_obj ) if not isinstance ( source_obj , dict ): logger . warning ( f \"Unexpected: { source_obj } for type { source_type } \" ) return source_obj class_deriv = self . _get_class_derivation ( source_type ) tgt_attrs = {} bindings = None # map each slot assignment in source_obj, if there is a slot_derivation for slot_derivation in class_deriv . slot_derivations . values (): v = None source_class_slot = None if slot_derivation . unit_conversion : v = self . _perform_unit_conversion ( slot_derivation , source_obj , sv , source_type ) elif slot_derivation . expr : if bindings is None : bindings = Bindings ( self , source_obj = source_obj , source_obj_typed = source_obj_typed , source_type = source_type , sv = sv , bindings = { \"NULL\" : None }, ) try : v = eval_expr_with_mapping ( slot_derivation . expr , bindings ) except Exception : if not self . unrestricted_eval : raise RuntimeError ( f \"Expression not in safe subset: { slot_derivation . expr } \" ) ctxt_obj , _ = bindings . get_ctxt_obj_and_dict () aeval = Interpreter ( usersyms = { \"src\" : ctxt_obj , \"target\" : None }) aeval ( slot_derivation . expr ) v = aeval . symtable [ \"target\" ] elif slot_derivation . populated_from : v = source_obj . get ( slot_derivation . populated_from , None ) source_class_slot = sv . induced_slot ( slot_derivation . populated_from , source_type ) logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) elif slot_derivation . sources : vmap = { s : source_obj . get ( s , None ) for s in slot_derivation . sources } vmap = { k : v for k , v in vmap . items () if v is not None } if len ( vmap . keys ()) > 1 : raise ValueError ( f \"Multiple sources for { slot_derivation . name } : { vmap } \" ) elif len ( vmap . keys ()) == 1 : v = list ( vmap . values ())[ 0 ] source_class_slot_name = list ( vmap . keys ())[ 0 ] source_class_slot = sv . induced_slot ( source_class_slot_name , source_type ) else : v = None source_class_slot = None logger . debug ( f \"Pop slot { slot_derivation . name } => { v } using { slot_derivation . populated_from } // { source_obj } \" ) else : source_class_slot = sv . induced_slot ( slot_derivation . name , source_type ) v = source_obj . get ( slot_derivation . name , None ) if source_class_slot and v is not None : # slot is mapped and there is a value in the assignment target_range = slot_derivation . range source_class_slot_range = source_class_slot . range if source_class_slot . multivalued : if isinstance ( v , list ): v = [ self . map_object ( v1 , source_class_slot_range , target_range ) for v1 in v ] elif isinstance ( v , dict ): v = { k1 : self . map_object ( v1 , source_class_slot_range , target_range ) for k1 , v1 in v . items () } else : v = [ v ] else : v = self . map_object ( v , source_class_slot_range , target_range ) if ( self . _is_coerce_to_multivalued ( slot_derivation , class_deriv ) and v is not None and not isinstance ( v , list ) ): v = self . _singlevalued_to_multivalued ( v , slot_derivation ) if self . _is_coerce_to_singlevalued ( slot_derivation , class_deriv ) and isinstance ( v , list ): v = self . _multivalued_to_singlevalued ( v , slot_derivation ) v = self . _coerce_datatype ( v , target_range ) if slot_derivation . dictionary_key and isinstance ( v , list ): # List to CompactDict v = { v1 [ slot_derivation . dictionary_key ]: v1 for v1 in v } for v1 in v . values (): del v1 [ slot_derivation . dictionary_key ] elif ( slot_derivation . cast_collection_as and slot_derivation . cast_collection_as == CollectionType . MultiValuedList and isinstance ( v , dict ) ): # CompactDict to List src_rng = source_class_slot . range src_rng_id_slot = self . source_schemaview . get_identifier_slot ( src_rng , use_key = True ) if src_rng_id_slot : v = [{ ** v1 , src_rng_id_slot . name : k } for k , v1 in v . items ()] else : v = list ( v . values ()) tgt_attrs [ str ( slot_derivation . name )] = v return tgt_attrs","title":"map_object"},{"location":"schema/transformer/#linkml_map.transformer.object_transformer.ObjectTransformer.transform_object","text":"Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] Source code in src\\linkml_map\\transformer\\object_transformer.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def transform_object ( self , source_obj : Union [ YAMLRoot , BaseModel ], target_class : Optional [ Union [ Type [ YAMLRoot ], Type [ BaseModel ]]] = None , ) -> Union [ YAMLRoot , BaseModel ]: \"\"\" Transform an object into an object of class target_class. :param source_obj: source object :type source_obj: Union[YAMLRoot, BaseModel] :param target_class: class to transform the object into, defaults to None :type target_class: Optional[Union[Type[YAMLRoot], Type[BaseModel]]], optional :return: transformed object of class target_class :rtype: Union[YAMLRoot, BaseModel] \"\"\" if not target_class : raise ValueError ( \"No target_class specified for transform_object\" ) source_type = type ( source_obj ) source_type_name = source_type . __name__ # if isinstance(source_obj, YAMLRoot): # source_obj_dict = json_dumper.to_dict(source_obj) # elif isinstance(source_obj, BaseModel): # source_obj_dict = source_obj.dict() # else: # raise ValueError(f\"Do not know how to handle type: {typ}\") tr_obj_dict = self . map_object ( source_obj , source_type_name ) return target_class ( ** tr_obj_dict )","title":"transform_object"},{"location":"schema/type_designator/","text":"Slot: type_designator URI: linkmltr:type_designator Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no Properties Range: Boolean Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : type_designator from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : type_designator owner : SlotDerivation domain_of : - SlotDerivation range : boolean","title":"Slot: type_designator"},{"location":"schema/type_designator/#slot-type_designator","text":"URI: linkmltr:type_designator","title":"Slot: type_designator"},{"location":"schema/type_designator/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no","title":"Applicable Classes"},{"location":"schema/type_designator/#properties","text":"Range: Boolean","title":"Properties"},{"location":"schema/type_designator/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/type_designator/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/type_designator/#linkml-source","text":"name : type_designator from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : type_designator owner : SlotDerivation domain_of : - SlotDerivation range : boolean","title":"LinkML Source"},{"location":"schema/types/","text":"types Shared type definitions for the core LinkML mode and metamodel URI: https://w3id.org/linkml/types","title":"types"},{"location":"schema/types/#types","text":"Shared type definitions for the core LinkML mode and metamodel URI: https://w3id.org/linkml/types","title":"types"},{"location":"schema/unit/","text":"Slot: unit URI: linkmltr:unit Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no Properties Range: String Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : unit from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : unit owner : SlotDerivation domain_of : - SlotDerivation range : string","title":"Slot: unit"},{"location":"schema/unit/#slot-unit","text":"URI: linkmltr:unit","title":"Slot: unit"},{"location":"schema/unit/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no","title":"Applicable Classes"},{"location":"schema/unit/#properties","text":"Range: String","title":"Properties"},{"location":"schema/unit/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/unit/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/unit/#linkml-source","text":"name : unit from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : unit owner : SlotDerivation domain_of : - SlotDerivation range : string","title":"LinkML Source"},{"location":"schema/unit_conversion/","text":"Slot: unit_conversion URI: linkmltr:unit_conversion Applicable Classes Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no Properties Range: UnitConversionConfiguration Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : unit_conversion from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : unit_conversion owner : SlotDerivation domain_of : - SlotDerivation range : UnitConversionConfiguration","title":"Slot: unit_conversion"},{"location":"schema/unit_conversion/#slot-unit_conversion","text":"URI: linkmltr:unit_conversion","title":"Slot: unit_conversion"},{"location":"schema/unit_conversion/#applicable-classes","text":"Name Description Modifies Slot SlotDerivation A specification of how to derive the value of a target slot from a source slo... no","title":"Applicable Classes"},{"location":"schema/unit_conversion/#properties","text":"Range: UnitConversionConfiguration","title":"Properties"},{"location":"schema/unit_conversion/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/unit_conversion/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/unit_conversion/#linkml-source","text":"name : unit_conversion from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : unit_conversion owner : SlotDerivation domain_of : - SlotDerivation range : UnitConversionConfiguration","title":"LinkML Source"},{"location":"schema/value/","text":"Slot: value URI: linkmltr:value Applicable Classes Name Description Modifies Slot KeyVal no Properties Range: Any Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : value from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : value owner : KeyVal domain_of : - KeyVal range : Any","title":"Slot: value"},{"location":"schema/value/#slot-value","text":"URI: linkmltr:value","title":"Slot: value"},{"location":"schema/value/#applicable-classes","text":"Name Description Modifies Slot KeyVal no","title":"Applicable Classes"},{"location":"schema/value/#properties","text":"Range: Any","title":"Properties"},{"location":"schema/value/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/value/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/value/#linkml-source","text":"name : value from_schema : https://w3id.org/linkml/transformer rank : 1000 alias : value owner : KeyVal domain_of : - KeyVal range : Any","title":"LinkML Source"},{"location":"schema/value_mappings/","text":"Slot: value_mappings A mapping table that is applied directly to mappings, in order of precedence URI: linkmltr:value_mappings Applicable Classes Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no Properties Range: KeyVal Multivalued: True Identifier and Mapping Information Schema Source from schema: https://w3id.org/linkml/transformer LinkML Source name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true","title":"Slot: value_mappings"},{"location":"schema/value_mappings/#slot-value_mappings","text":"A mapping table that is applied directly to mappings, in order of precedence URI: linkmltr:value_mappings","title":"Slot: value_mappings"},{"location":"schema/value_mappings/#applicable-classes","text":"Name Description Modifies Slot EnumDerivation A specification of how to derive the value of a target enum from a source enu... no ClassDerivation A specification of how to derive a target class from a source class no PrefixDerivation no SlotDerivation A specification of how to derive the value of a target slot from a source slo... no PermissibleValueDerivation A specification of how to derive the value of a PV from a source enum no ElementDerivation An abstract grouping for classes that provide a specification of how to deri... no","title":"Applicable Classes"},{"location":"schema/value_mappings/#properties","text":"Range: KeyVal Multivalued: True","title":"Properties"},{"location":"schema/value_mappings/#identifier-and-mapping-information","text":"","title":"Identifier and Mapping Information"},{"location":"schema/value_mappings/#schema-source","text":"from schema: https://w3id.org/linkml/transformer","title":"Schema Source"},{"location":"schema/value_mappings/#linkml-source","text":"name : value_mappings description : A mapping table that is applied directly to mappings, in order of precedence from_schema : https://w3id.org/linkml/transformer rank : 1000 multivalued : true alias : value_mappings owner : ElementDerivation domain_of : - ElementDerivation range : KeyVal inlined : true","title":"LinkML Source"},{"location":"specification/compliance/","text":"LinkML-Map Compliance Suite Feature Set: test_map_types Feature Set: test_map_collections Feature Set: test_expr Feature Set: test_simple_unit_conversion Feature Set: test_complex_unit_conversion Feature Set: test_stringify Feature Set: test_isomorphic Feature Set: test_join Feature Set: test_map_enum Feature Set: test_inheritance LinkML-Map Compliance Suite This is the output from running the full compliance test suite. Time_executed : 2024-07-03 Package : /Users/cjm/repos/linkml-map/tests/test_compliance/test_compliance_suite.py It is organized into Feature Sets that test a particular feature or group of features, and combinations of different schemas, input objects, and transformation specifications. This is intended to exhaustively test all combinations of features, and provide informative output. Each test is designed to demonstrate: data mapping (transformation) derived schemas inversion (reverse transformation) (in some cases) compilation to other frameworks (coming soon) Feature Set: test_map_types Test mapping between basic data types. This test uses an ultra-minimal schema with a single class and a single attribute, the transformation specification maps that attribute onto itself, with a different type, demonstrating type coercion. Some cases will be trivially isomorphic (where source_datatype == target_datatype ), but these are executed anyway. source_datatype : linkml datatype of source object target_datatype : linkml datatype of target object source_value : value of source object target_value : expected value of slot in target object invertible : True if the transformation is invertible Combo: test_map_types[string-string-foo-foo-True] Mapping string => string Isomorphic mapping: input should equal output Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : string Object Transformation : Source Object: s1 : foo Target Object: s1 : foo Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : string Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 range : string Combo: test_map_types[integer-integer-5-5-True] Mapping integer => integer Isomorphic mapping: input should equal output Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer Object Transformation : Source Object: s1 : 5 Target Object: s1 : 5 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer Combo: test_map_types[string-integer-5-5-True] Mapping string => integer Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer Object Transformation : Source Object: s1 : '5' Target Object: s1 : 5 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 range : string Combo: test_map_types[integer-float-5-5.0-True] {#combo-test_map_typesinteger-float-5-50-true} Mapping integer => float Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : float Object Transformation : Source Object: s1 : 5 Target Object: s1 : 5.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer Combo: test_map_types[float-integer-5.0-5-True] {#combo-test_map_typesfloat-integer-50-5-true} Mapping float => integer Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer Object Transformation : Source Object: s1 : 5.0 Target Object: s1 : 5 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 range : float Combo: test_map_types[float-integer-5.2-5-False] {#combo-test_map_typesfloat-integer-52-5-false} Mapping float => integer Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer Object Transformation : Source Object: s1 : 5.2 Target Object: s1 : 5 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer Combo: test_map_types[integer-boolean-5-True-False] Mapping integer => boolean Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : boolean Object Transformation : Source Object: s1 : 5 Target Object: s1 : true Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : boolean Combo: test_map_types[integer-boolean-0-False-False] Mapping integer => boolean Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : boolean Object Transformation : Source Object: s1 : 0 Target Object: s1 : false Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : boolean Feature Set: test_map_collections Test mapping between collection data types (lists and dicts). This makes use of the cast_collection_as construct source_datatype : linkml datatype of source object target_datatype : linkml datatype of target object source_value : value of source object target_value : expected value of slot in target object invertible : True if the transformation is invertible Combo: test_map_collections[string-string-source_value0-target_value0-True] Mapping string => string Isomorphic mapping: input must equal output Source Schema : name : types description : Mapping between collection types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : ds : name : ds range : D multivalued : true inlined : true inlined_as_list : true tree_root : true D : name : D attributes : id : name : id identifier : true s1 : name : s1 range : string Transformer Specification : class_derivations : C : name : C slot_derivations : ds : name : ds populated_from : ds cast_collection_as : MultiValuedDict dictionary_key : id D : name : D slot_derivations : id : name : id populated_from : id s1 : name : s1 populated_from : s1 range : string Object Transformation : Source Object: ds : - id : X s1 : foo - id : Y s1 : bar Target Object: ds : X : s1 : foo Y : s1 : bar Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : ds : name : ds domain_of : - C range : D multivalued : true inlined : true inlined_as_list : false tree_root : true D : name : D attributes : id : name : id identifier : true domain_of : - D required : true s1 : name : s1 domain_of : - D range : string Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : ds : name : ds populated_from : ds cast_collection_as : MultiValuedList D : name : D populated_from : D slot_derivations : id : name : id populated_from : id s1 : name : s1 populated_from : s1 range : string Combo: test_map_collections[string-string-source_value1-target_value1-True] Mapping string => string Isomorphic mapping: input must equal output Source Schema : name : types description : Mapping between collection types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : ds : name : ds range : D multivalued : true inlined : true inlined_as_list : false tree_root : true D : name : D attributes : id : name : id identifier : true s1 : name : s1 range : string Transformer Specification : class_derivations : C : name : C slot_derivations : ds : name : ds populated_from : ds cast_collection_as : MultiValuedList D : name : D slot_derivations : id : name : id populated_from : id s1 : name : s1 populated_from : s1 range : string Object Transformation : Source Object: ds : X : s1 : foo Y : s1 : bar Target Object: ds : - id : X s1 : foo - id : Y s1 : bar Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : ds : name : ds domain_of : - C range : D multivalued : true inlined : true inlined_as_list : true tree_root : true D : name : D attributes : id : name : id identifier : true domain_of : - D required : true s1 : name : s1 domain_of : - D range : string Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : ds : name : ds populated_from : ds cast_collection_as : MultiValuedDict dictionary_key : id D : name : D populated_from : D slot_derivations : id : name : id populated_from : id s1 : name : s1 populated_from : s1 range : string Feature Set: test_expr Test transformation using pythonic expressions. This test uses a simple source schema with two slots ( s1 and s2 ). These are combined using a pythonic expression, to populate the only slot in the target schema (called derived ). The values of s1 and s2 can be numbers or strings. If the expression wraps a slot in {...} then the presence of a None forces the entire expression to be None Limitations: At this time, the framework cannot generate a complete derived schema or inversion for expressions. This will be fixed in future. See also: LinkML Expressions expr : pythonic expression source_object : source object target_value : expected value of slot in target object Combo: test_expr[s1 + s2-source_object0-11] {#combo-test_exprs1--s2-source_object0-11} Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer s2 : name : s2 range : integer tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 + s2 Object Transformation : Source Object: s1 : 5 s2 : 6 Target Object: derived : 11 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true Combo: test_expr[{s1} + {s2}-source_object1-11] {#combo-test_exprs1--s2-source_object1-11} Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer s2 : name : s2 range : integer tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : '{s1} + {s2}' Object Transformation : Source Object: s1 : 5 s2 : 6 Target Object: derived : 11 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true Combo: test_expr[{s1} + {s2}-source_object2-None] {#combo-test_exprs1--s2-source_object2-none} Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : '{s1} + {s2}' Object Transformation : Source Object: s1 : 5 Target Object: {} Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true Combo: test_expr[s1 + s2.s3-source_object3-11] {#combo-test_exprs1--s2s3-source_object3-11} Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer s2 : name : s2 range : D tree_root : true D : name : D attributes : s3 : name : s3 range : integer Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 + s2.s3 Object Transformation : Source Object: s1 : 5 s2 : s3 : 6 Target Object: derived : 11 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true Combo: test_expr[s1 + s2.s3.s4-source_object4-11] {#combo-test_exprs1--s2s3s4-source_object4-11} Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer s2 : name : s2 range : D tree_root : true D : name : D attributes : s4 : name : s4 range : integer s3 : name : s3 range : D Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 + s2.s3.s4 Object Transformation : Source Object: s1 : 5 s2 : s3 : s4 : 6 Target Object: derived : 11 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true Combo: test_expr[s1 + s2-source_object5-ab] {#combo-test_exprs1--s2-source_object5-ab} Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string s2 : name : s2 range : string tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 + s2 Object Transformation : Source Object: s1 : a s2 : b Target Object: derived : ab Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true Combo: test_expr[s1 + s2-source_object6-target_value6] {#combo-test_exprs1--s2-source_object6-target_value6} Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true s2 : name : s2 range : string multivalued : true tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 + s2 Object Transformation : Source Object: s1 : - a s2 : - b Target Object: derived : - a - b Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true Combo: test_expr[len(s1)-source_object7-1] Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : len(s1) Object Transformation : Source Object: s1 : - a Target Object: derived : 1 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true Combo: test_expr[s1 \\< s2-source_object8-True] {#combo-test_exprs1--s2-source_object8-true} Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer s2 : name : s2 range : integer tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 < s2 Object Transformation : Source Object: s1 : 5 s2 : 6 Target Object: derived : true Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true Feature Set: test_simple_unit_conversion Test unit conversion. This test uses a simple source schema with a single class and a single attribute, where the attribute is described using the units metaslot. The recommended way to describe unit slots in LinkML is with UCUM, but a number of other schemes can be used. We explicitly test for some known cases where UCUM uses non-standard units (e.g. Cel, mo), as well as UCUM-specific syntax (e.g. m.s-1 ) and extensions (e.g. using annotations like {Cre} ). Developers note : to run this test, the units extension should be installed: poetry install -E units This installs the pint framework. source_slot : name of slot in source schema target_slot : name of slot in target schema source_unit : unit of source slot target_unit : unit of target slot source_value : magnitude of source slot (to be converted) target_value : expected magnitude of target slot (output of conversion) err : Combo: test_simple_unit_conversion[s1-s1-m-cm-ucum_code-1.0-100.0-None-None] {#combo-test_simple_unit_conversions1-s1-m-cm-ucum_code-10-1000-none-none} Unit Conversion: 1.0 m => 100.0 cm [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : cm Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : cm Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m target_unit_scheme : ucum_code source_unit : cm Combo: test_simple_unit_conversion[s1-s1-m-cm-symbol-1.0-100.0-None-None] {#combo-test_simple_unit_conversions1-s1-m-cm-symbol-10-1000-none-none} Unit Conversion: 1.0 m => 100.0 cm [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : symbol : m Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : cm Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : cm Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m target_unit_scheme : symbol source_unit : cm Combo: test_simple_unit_conversion[s1-s1-m-m-ucum_code-1.0-1.0-None-None] {#combo-test_simple_unit_conversions1-s1-m-m-ucum_code-10-10-none-none} Unit Conversion: 1.0 m => 1.0 m [with s1] Isomorphic mapping: input must equal output Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 1.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : m Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m target_unit_scheme : ucum_code source_unit : m Combo: test_simple_unit_conversion[s1-s1-a-mo-ucum_code-10.0-120.0-None-None] {#combo-test_simple_unit_conversions1-s1-a-mo-ucum_code-100-1200-none-none} Unit Conversion: 10.0 a => 120.0 mo [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : a Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : mo Object Transformation : Source Object: s1 : 10.0 Target Object: s1 : 120.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : mo Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : a target_unit_scheme : ucum_code source_unit : mo Combo: test_simple_unit_conversion[s1-s1-a-mo-symbol-10.0-None-UndefinedUnitError-None] {#combo-test_simple_unit_conversions1-s1-a-mo-symbol-100-none-undefineduniterror-none} Unit Conversion: 10.0 a => None mo [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : symbol : a Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : mo Object Transformation : Expected Error : UndefinedUnitError Source Object: s1 : 10.0 Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : mo Combo: test_simple_unit_conversion[s1-s1-m-ml-ucum_code-1.0-None-DimensionalityError-None] {#combo-test_simple_unit_conversions1-s1-m-ml-ucum_code-10-none-dimensionalityerror-none} Unit Conversion: 1.0 m => None ml [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : ml Object Transformation : Expected Error : DimensionalityError Source Object: s1 : 1.0 Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : ml Combo: test_simple_unit_conversion[s1-s1-m-pinknoodles-ucum_code-1.0-None-UndefinedUnitError-None] {#combo-test_simple_unit_conversions1-s1-m-pinknoodles-ucum_code-10-none-undefineduniterror-none} Unit Conversion: 1.0 m => None pinknoodles [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : pinknoodles Object Transformation : Expected Error : UndefinedUnitError Source Object: s1 : 1.0 Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : pinknoodles Combo: test_simple_unit_conversion[s1-s1-ml-m-ucum_code-1.0-None-DimensionalityError-None] {#combo-test_simple_unit_conversions1-s1-ml-m-ucum_code-10-none-dimensionalityerror-none} Unit Conversion: 1.0 ml => None m [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : ml Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m Object Transformation : Expected Error : DimensionalityError Source Object: s1 : 1.0 Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : m Combo: test_simple_unit_conversion[s1-s1-pinknoodles-m-ucum_code-1.0-None-UndefinedUnitError-None] {#combo-test_simple_unit_conversions1-s1-pinknoodles-m-ucum_code-10-none-undefineduniterror-none} Unit Conversion: 1.0 pinknoodles => None m [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : pinknoodles Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m Object Transformation : Expected Error : UndefinedUnitError Source Object: s1 : 1.0 Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : m Combo: test_simple_unit_conversion[s1-s1-m/s-cm/s-ucum_code-1.0-100.0-None-None] {#combo-test_simple_unit_conversions1-s1-ms-cms-ucum_code-10-1000-none-none} Unit Conversion: 1.0 m/s => 100.0 cm/s [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m/s Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : cm/s Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : cm/s Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m/s target_unit_scheme : ucum_code source_unit : cm/s Combo: test_simple_unit_conversion[s1-s1-m.s-1-cm.s-1-ucum_code-1.0-100.0-None-None] {#combo-test_simple_unit_conversions1-s1-ms-1-cms-1-ucum_code-10-1000-none-none} Unit Conversion: 1.0 m.s-1 => 100.0 cm.s-1 [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m.s-1 Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : cm.s-1 Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : cm.s-1 Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m.s-1 target_unit_scheme : ucum_code source_unit : cm.s-1 Combo: test_simple_unit_conversion[s1-s1-g.m2-1-kg.m2-1-ucum_code-1.0-0.001-None-https://github.com/dalito/ucumvert/issues/8] {#combo-test_simple_unit_conversions1-s1-gm2-1-kgm2-1-ucum_code-10-0001-none-httpsgithubcomdalitoucumvertissues8} s### Combo: test_simple_unit_conversion[height_in_m-height_in_cm-m-cm-ucum_code-1.0-100.0-None-None] Unit Conversion: 1.0 m => 100.0 cm [with height_in_m] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : height_in_m : name : height_in_m range : float unit : ucum_code : m Transformer Specification : class_derivations : C : name : C slot_derivations : height_in_cm : name : height_in_cm populated_from : height_in_m unit_conversion : target_unit : cm Object Transformation : Source Object: height_in_m : 1.0 Target Object: height_in_cm : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : height_in_cm : name : height_in_cm domain_of : - C range : float unit : ucum_code : cm Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : height_in_m : name : height_in_m populated_from : height_in_cm unit_conversion : target_unit : m target_unit_scheme : ucum_code source_unit : cm Combo: test_simple_unit_conversion[s1-s1-m[H2O]{35Cel}-m[H2O]{35Cel}-ucum_code-1.0-1.0-None-None] {#combo-test_simple_unit_conversions1-s1-mh2o35cel-mh2o35cel-ucum_code-10-10-none-none} Unit Conversion: 1.0 m[H2O]{35Cel} => 1.0 m[H2O]{35Cel} [with s1] Isomorphic mapping: input must equal output Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m[H2O]{35Cel} Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m[H2O]{35Cel} Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 1.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : m[H2O]{35Cel} Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m[H2O]{35Cel} target_unit_scheme : ucum_code source_unit : m[H2O]{35Cel} Feature Set: test_complex_unit_conversion Test unit conversion, from complex object to simple scalar. An example complex object would be an object with separate attributes for representing magnitude (value) and unit. For example magnitude: 1.0, unit: \"m\" source_unit : unit of source slot target_unit : unit of target slot source_value : magnitude of source slot (to be converted) target_value : expected magnitude of target slot (output of conversion) roundtrip_object : expected value of passing target object back through inverted transformation err : True if expected to raise an Error Combo: test_complex_unit_conversion[m-cm-1.0-100.0-roundtrip_object0-None] {#combo-test_complex_unit_conversionm-cm-10-1000-roundtrip_object0-none} Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Q : name : Q attributes : magnitude : name : magnitude range : float unit : name : unit range : string C : name : C attributes : q : name : q range : Q tree_root : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : q_in_cm : name : q_in_cm populated_from : q unit_conversion : target_unit : cm source_unit_slot : unit source_magnitude_slot : magnitude Object Transformation : Source Object: q : magnitude : 1.0 unit : m Target Object: q_in_cm : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : q_in_cm : name : q_in_cm domain_of : - C range : Q unit : ucum_code : cm tree_root : true Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : q : name : q populated_from : q_in_cm unit_conversion : source_unit : cm target_unit_slot : unit target_magnitude_slot : magnitude Combo: test_complex_unit_conversion[cm-cm-100.0-100.0-roundtrip_object1-None] {#combo-test_complex_unit_conversioncm-cm-1000-1000-roundtrip_object1-none} Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Q : name : Q attributes : magnitude : name : magnitude range : float unit : name : unit range : string C : name : C attributes : q : name : q range : Q tree_root : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : q_in_cm : name : q_in_cm populated_from : q unit_conversion : target_unit : cm source_unit_slot : unit source_magnitude_slot : magnitude Object Transformation : Source Object: q : magnitude : 100.0 unit : cm Target Object: q_in_cm : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : q_in_cm : name : q_in_cm domain_of : - C range : Q unit : ucum_code : cm tree_root : true Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : q : name : q populated_from : q_in_cm unit_conversion : source_unit : cm target_unit_slot : unit target_magnitude_slot : magnitude Combo: test_complex_unit_conversion[cm-ml-100.0-None-None-DimensionalityError] {#combo-test_complex_unit_conversioncm-ml-1000-none-none-dimensionalityerror} Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Q : name : Q attributes : magnitude : name : magnitude range : float unit : name : unit range : string C : name : C attributes : q : name : q range : Q tree_root : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : q_in_ml : name : q_in_ml populated_from : q unit_conversion : target_unit : ml source_unit_slot : unit source_magnitude_slot : magnitude Object Transformation : Expected Error : DimensionalityError Source Object: q : magnitude : 100.0 unit : cm Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : q_in_ml : name : q_in_ml domain_of : - C range : Q unit : ucum_code : ml tree_root : true Combo: test_complex_unit_conversion[cm-pinknoodles-100.0-None-None-UndefinedUnitError] {#combo-test_complex_unit_conversioncm-pinknoodles-1000-none-none-undefineduniterror} Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Q : name : Q attributes : magnitude : name : magnitude range : float unit : name : unit range : string C : name : C attributes : q : name : q range : Q tree_root : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : q_in_pinknoodles : name : q_in_pinknoodles populated_from : q unit_conversion : target_unit : pinknoodles source_unit_slot : unit source_magnitude_slot : magnitude Object Transformation : Expected Error : UndefinedUnitError Source Object: q : magnitude : 100.0 unit : cm Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : q_in_pinknoodles : name : q_in_pinknoodles domain_of : - C range : Q unit : ucum_code : pinknoodles tree_root : true Feature Set: test_stringify Test compaction of multivalued slots into a string. Stringification is primarily intended for mapping from complex nested formats to simple tabular TSV formats, where some of the following methodologies can be used: flattening lists using an (internal) delimiter flattening lists or more complex objects using JSON or YAML For example, [\"a\", \"b\"] => \"a,b\" As a convention we use s1_verbatim as a slot/attribute name for the stringified form. syntax : SerializationSyntaxType delimiter : delimiter to use in stringification source_value : source value (a list) target_value : expected value of slot in target object (a string) Combo: test_stringify[None-,-source_value0-a,b] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : delimiter : ',' Object Transformation : Source Object: s1 : - a - b Target Object: s1_verbatim : a,b Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : delimiter : ',' reversed : true Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS STRING_AGG(s1, \\',\\') FROM D; Combo: test_stringify[None-|-source_value1-a|b] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : delimiter : '|' Object Transformation : Source Object: s1 : - a - b Target Object: s1_verbatim : a|b Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : delimiter : '|' reversed : true Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS STRING_AGG(s1, \\'|\\') FROM D; Combo: test_stringify[None-|-source_value2-a] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : delimiter : '|' Object Transformation : Source Object: s1 : - a Target Object: s1_verbatim : a Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : delimiter : '|' reversed : true Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS STRING_AGG(s1, \\'|\\') FROM D; Combo: test_stringify[None-|-source_value3-] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : delimiter : '|' Object Transformation : Source Object: {} Target Object: s1_verbatim : '' Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : delimiter : '|' reversed : true Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS STRING_AGG(s1, \\'|\\') FROM D; Combo: test_stringify[JSON-None-source_value4-[\\\"a\\\", \\\"b\\\"]] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : syntax : JSON Object Transformation : Source Object: s1 : - a - b Target Object: s1_verbatim : '[\"a\", \"b\"]' Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : reversed : true syntax : JSON Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS CAST(s1 AS TEXT) FROM D; Combo: test_stringify[JSON-None-source_value5-[]] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : syntax : JSON Object Transformation : Source Object: {} Target Object: s1_verbatim : '[]' Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : reversed : true syntax : JSON Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS CAST(s1 AS TEXT) FROM D; Combo: test_stringify[YAML-None-source_value6-[a, b]] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : syntax : YAML Object Transformation : Source Object: s1 : - a - b Target Object: s1_verbatim : '[a, b]' Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : reversed : true syntax : YAML Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS s1 FROM D; Feature Set: test_isomorphic Test mapping a schema to an identical schema (i.e copy). This also tests for the ability to recursively descend a nested structure. source_object : use_expr : supply_source_schema : TODO: always True for now Combo: test_isomorphic[True-True-source_object0] Source Schema : name : isomorphic id : isomorphic imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Container : name : Container attributes : c_list : name : c_list range : C multivalued : true d : name : d range : D tree_root : true C : name : C attributes : s1 : name : s1 range : string s2 : name : s2 range : string D : name : D attributes : s3 : name : s3 range : string Transformer Specification : class_derivations : Container : name : Container populated_from : Container slot_derivations : c_list : name : c_list populated_from : c_list range : C d : name : d populated_from : d range : D C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 s2 : name : s2 populated_from : s2 D : name : D populated_from : D slot_derivations : s3 : name : s3 expr : s3 Object Transformation : Source Object: c_list : - s1 : a s2 : b - s1 : c s2 : d d : s3 : e Target Object: c_list : - s1 : a s2 : b - s1 : c s2 : d d : s3 : e Target Schema (Derived) : name : isomorphic-derived id : isomorphic-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : isomorphic-derived/ classes : Container : name : Container attributes : c_list : name : c_list domain_of : - Container range : C multivalued : true d : name : d domain_of : - Container range : D tree_root : true C : name : C attributes : s1 : name : s1 domain_of : - C range : string s2 : name : s2 domain_of : - C range : string D : name : D attributes : s3 : name : s3 domain_of : - D range : string Inverted Transformation Specification (Derived): class_derivations : Container : name : Container populated_from : Container slot_derivations : c_list : name : c_list populated_from : c_list range : C d : name : d populated_from : d range : D C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 s2 : name : s2 populated_from : s2 D : name : D populated_from : D slot_derivations : s3 : name : s3 populated_from : s3 Combo: test_isomorphic[True-False-source_object0] Source Schema : name : isomorphic id : isomorphic imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Container : name : Container attributes : c_list : name : c_list range : C multivalued : true d : name : d range : D tree_root : true C : name : C attributes : s1 : name : s1 range : string s2 : name : s2 range : string D : name : D attributes : s3 : name : s3 range : string Transformer Specification : class_derivations : Container : name : Container populated_from : Container slot_derivations : c_list : name : c_list populated_from : c_list range : C d : name : d populated_from : d range : D C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 s2 : name : s2 populated_from : s2 D : name : D populated_from : D slot_derivations : s3 : name : s3 populated_from : s3 Object Transformation : Source Object: c_list : - s1 : a s2 : b - s1 : c s2 : d d : s3 : e Target Object: c_list : - s1 : a s2 : b - s1 : c s2 : d d : s3 : e Target Schema (Derived) : name : isomorphic-derived id : isomorphic-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : isomorphic-derived/ classes : Container : name : Container attributes : c_list : name : c_list domain_of : - Container range : C multivalued : true d : name : d domain_of : - Container range : D tree_root : true C : name : C attributes : s1 : name : s1 domain_of : - C range : string s2 : name : s2 domain_of : - C range : string D : name : D attributes : s3 : name : s3 domain_of : - D range : string Inverted Transformation Specification (Derived): class_derivations : Container : name : Container populated_from : Container slot_derivations : c_list : name : c_list populated_from : c_list range : C d : name : d populated_from : d range : D C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 s2 : name : s2 populated_from : s2 D : name : D populated_from : D slot_derivations : s3 : name : s3 populated_from : s3 Feature Set: test_join Test joining two objects into a single object, aka denormalization. source_object : normalized source object target_object : denormalized target object inlined : True if the source objects are inlined Combo: test_join[source_object0-target_object0-True] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : R : name : R attributes : s1 : name : s1 range : E inlined : true s2 : name : s2 range : E inlined : true tree_root : true E : name : E attributes : id : name : id identifier : true range : string name : name : name range : string Transformer Specification : class_derivations : R : name : R populated_from : R slot_derivations : s1_id : name : s1_id expr : s1.id s1_name : name : s1_name expr : s1.name s2_id : name : s2_id expr : s2.id s2_name : name : s2_name expr : s2.name Object Transformation : Source Object: s1 : id : x1 name : foo s2 : id : x2 name : bar Target Object: s1_id : x1 s1_name : foo s2_id : x2 s2_name : bar Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : R : name : R attributes : s1_id : name : s1_id s1_name : name : s1_name s2_id : name : s2_id s2_name : name : s2_name tree_root : true Combo: test_join[source_object0-target_object0-False] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : R : name : R attributes : s1 : name : s1 range : E inlined : false s2 : name : s2 range : E inlined : false tree_root : false E : name : E attributes : id : name : id identifier : true range : string name : name : name range : string Container : name : Container attributes : r_list : name : r_list range : R multivalued : true e_list : name : e_list range : E multivalued : true inlined_as_list : true tree_root : true Transformer Specification : class_derivations : R : name : R populated_from : R slot_derivations : s1_id : name : s1_id expr : s1.id s1_name : name : s1_name expr : s1.name s2_id : name : s2_id expr : s2.id s2_name : name : s2_name expr : s2.name Container : name : Container populated_from : Container slot_derivations : r_list : name : r_list populated_from : r_list Object Transformation : Source Object: r_list : - s1 : x1 s2 : x2 e_list : - id : x1 name : foo - id : x2 name : bar Target Object: r_list : - s1_id : x1 s1_name : foo s2_id : x2 s2_name : bar Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : R : name : R attributes : s1_id : name : s1_id s1_name : name : s1_name s2_id : name : s2_id s2_name : name : s2_name tree_root : false Container : name : Container attributes : r_list : name : r_list domain_of : - Container range : R multivalued : true tree_root : true Feature Set: test_map_enum Test mapping between enum values. Currently this only supports simple dictionary-style mapping between permissible values, akin to SSSOM, but in future additional expressivity will be supported, including: mapping ranges to categorical values boolean/branching logic source_value : source enum permissible value to be mapped mapping : mapping from source to target enum permissible values target_value : expected target enum permissible value Combo: test_map_enum[A-mapping0-B-False] Source Schema : name : enums id : enums imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 range : E Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E mirror_source : false populated_from : E permissible_value_derivations : B : name : B populated_from : A Object Transformation : Source Object: s1 : A Target Object: s1 : B Target Schema (Derived) : name : enums-derived id : enums-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : enums-derived/ enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : E Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E populated_from : E permissible_value_derivations : A : name : A populated_from : B Combo: test_map_enum[Z-mapping1-None-False] Source Schema : name : enums id : enums imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 range : E Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E mirror_source : false populated_from : E permissible_value_derivations : B : name : B populated_from : A Object Transformation : Source Object: s1 : Z Target Object: {} Target Schema (Derived) : name : enums-derived id : enums-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : enums-derived/ enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : E Combo: test_map_enum[C-mapping2-C-True] Source Schema : name : enums id : enums imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 range : E Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E mirror_source : true populated_from : E permissible_value_derivations : B : name : B populated_from : A s### Combo: test_map_enum[A-mapping3-B-False] Source Schema : name : enums id : enums imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 range : E Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E mirror_source : false populated_from : E permissible_value_derivations : B : name : B sources : - A - C Object Transformation : Source Object: s1 : A Target Object: s1 : B Target Schema (Derived) : name : enums-derived id : enums-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : enums-derived/ enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : E Combo: test_map_enum[C-mapping4-B-False] Source Schema : name : enums id : enums imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 range : E Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E mirror_source : false populated_from : E permissible_value_derivations : B : name : B sources : - A - C Object Transformation : Source Object: s1 : C Target Object: s1 : B Target Schema (Derived) : name : enums-derived id : enums-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : enums-derived/ enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : E Feature Set: test_inheritance Test inheritance. Transformation specifications can utilize inheritance, in the same way that LinkML schemas can. is_a : use is_as instead of mixins in test schema flatten : roll down inherited slots Combo: test_inheritance[False-True] Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C is_a : D attributes : s1 : name : s1 range : integer tree_root : true D : name : D attributes : s2 : name : s2 range : integer Transformer Specification : class_derivations : C : name : C is_a : D populated_from : C slot_derivations : s1 : name : s1 expr : s1 + 1 D : name : D populated_from : D slot_derivations : s2 : name : s2 expr : s2 + 1 Object Transformation : Source Object: s1 : 1 s2 : 2 Target Object: s1 : 2 s2 : 3 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C is_a : D attributes : s1 : name : s1 domain_of : - C range : integer tree_root : true D : name : D attributes : s2 : name : s2 domain_of : - D range : integer Combo: test_inheritance[False-False] Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C mixins : - D attributes : s1 : name : s1 range : integer tree_root : true D : name : D attributes : s2 : name : s2 range : integer Transformer Specification : class_derivations : C : name : C mixins : - D populated_from : C slot_derivations : s1 : name : s1 expr : s1 + 1 D : name : D populated_from : D slot_derivations : s2 : name : s2 expr : s2 + 1 Object Transformation : Source Object: s1 : 1 s2 : 2 Target Object: s1 : 2 s2 : 3 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C mixins : - D attributes : s1 : name : s1 domain_of : - C range : integer tree_root : true D : name : D attributes : s2 : name : s2 domain_of : - D range : integer Combo: test_inheritance[True-True] Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C is_a : D attributes : s1 : name : s1 range : integer tree_root : true D : name : D attributes : s2 : name : s2 range : integer Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 expr : s1 + 1 s2 : name : s2 expr : s2 + 1 Object Transformation : Source Object: s1 : 1 s2 : 2 Target Object: s1 : 2 s2 : 3 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer s2 : name : s2 domain_of : - D range : integer tree_root : true Combo: test_inheritance[True-False] Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C mixins : - D attributes : s1 : name : s1 range : integer tree_root : true D : name : D attributes : s2 : name : s2 range : integer Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 expr : s1 + 1 s2 : name : s2 expr : s2 + 1 Object Transformation : Source Object: s1 : 1 s2 : 2 Target Object: s1 : 2 s2 : 3 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer s2 : name : s2 domain_of : - D range : integer tree_root : true . 55 passed, 2 skipped, 83 warnings in 4.60s","title":"Compliance Suite"},{"location":"specification/compliance/#linkml-map-compliance-suite","text":"This is the output from running the full compliance test suite. Time_executed : 2024-07-03 Package : /Users/cjm/repos/linkml-map/tests/test_compliance/test_compliance_suite.py It is organized into Feature Sets that test a particular feature or group of features, and combinations of different schemas, input objects, and transformation specifications. This is intended to exhaustively test all combinations of features, and provide informative output. Each test is designed to demonstrate: data mapping (transformation) derived schemas inversion (reverse transformation) (in some cases) compilation to other frameworks (coming soon)","title":"LinkML-Map Compliance Suite"},{"location":"specification/compliance/#feature-set-test_map_types","text":"Test mapping between basic data types. This test uses an ultra-minimal schema with a single class and a single attribute, the transformation specification maps that attribute onto itself, with a different type, demonstrating type coercion. Some cases will be trivially isomorphic (where source_datatype == target_datatype ), but these are executed anyway. source_datatype : linkml datatype of source object target_datatype : linkml datatype of target object source_value : value of source object target_value : expected value of slot in target object invertible : True if the transformation is invertible","title":"Feature Set: test_map_types"},{"location":"specification/compliance/#combo-test_map_typesstring-string-foo-foo-true","text":"Mapping string => string Isomorphic mapping: input should equal output Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : string Object Transformation : Source Object: s1 : foo Target Object: s1 : foo Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : string Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 range : string","title":"Combo: test_map_types[string-string-foo-foo-True]"},{"location":"specification/compliance/#combo-test_map_typesinteger-integer-5-5-true","text":"Mapping integer => integer Isomorphic mapping: input should equal output Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer Object Transformation : Source Object: s1 : 5 Target Object: s1 : 5 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer","title":"Combo: test_map_types[integer-integer-5-5-True]"},{"location":"specification/compliance/#combo-test_map_typesstring-integer-5-5-true","text":"Mapping string => integer Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer Object Transformation : Source Object: s1 : '5' Target Object: s1 : 5 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 range : string","title":"Combo: test_map_types[string-integer-5-5-True]"},{"location":"specification/compliance/#combo-test_map_typesinteger-float-5-50-true-combo-test_map_typesinteger-float-5-50-true","text":"Mapping integer => float Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : float Object Transformation : Source Object: s1 : 5 Target Object: s1 : 5.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer","title":"Combo: test_map_types[integer-float-5-5.0-True] {#combo-test_map_typesinteger-float-5-50-true}"},{"location":"specification/compliance/#combo-test_map_typesfloat-integer-50-5-true-combo-test_map_typesfloat-integer-50-5-true","text":"Mapping float => integer Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer Object Transformation : Source Object: s1 : 5.0 Target Object: s1 : 5 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 range : float","title":"Combo: test_map_types[float-integer-5.0-5-True] {#combo-test_map_typesfloat-integer-50-5-true}"},{"location":"specification/compliance/#combo-test_map_typesfloat-integer-52-5-false-combo-test_map_typesfloat-integer-52-5-false","text":"Mapping float => integer Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : integer Object Transformation : Source Object: s1 : 5.2 Target Object: s1 : 5 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer","title":"Combo: test_map_types[float-integer-5.2-5-False] {#combo-test_map_typesfloat-integer-52-5-false}"},{"location":"specification/compliance/#combo-test_map_typesinteger-boolean-5-true-false","text":"Mapping integer => boolean Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : boolean Object Transformation : Source Object: s1 : 5 Target Object: s1 : true Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : boolean","title":"Combo: test_map_types[integer-boolean-5-True-False]"},{"location":"specification/compliance/#combo-test_map_typesinteger-boolean-0-false-false","text":"Mapping integer => boolean Should coerce datatype Source Schema : name : types description : Minimal single-attribute schema for testing datatype mapping id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 range : boolean Object Transformation : Source Object: s1 : 0 Target Object: s1 : false Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : boolean","title":"Combo: test_map_types[integer-boolean-0-False-False]"},{"location":"specification/compliance/#feature-set-test_map_collections","text":"Test mapping between collection data types (lists and dicts). This makes use of the cast_collection_as construct source_datatype : linkml datatype of source object target_datatype : linkml datatype of target object source_value : value of source object target_value : expected value of slot in target object invertible : True if the transformation is invertible","title":"Feature Set: test_map_collections"},{"location":"specification/compliance/#combo-test_map_collectionsstring-string-source_value0-target_value0-true","text":"Mapping string => string Isomorphic mapping: input must equal output Source Schema : name : types description : Mapping between collection types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : ds : name : ds range : D multivalued : true inlined : true inlined_as_list : true tree_root : true D : name : D attributes : id : name : id identifier : true s1 : name : s1 range : string Transformer Specification : class_derivations : C : name : C slot_derivations : ds : name : ds populated_from : ds cast_collection_as : MultiValuedDict dictionary_key : id D : name : D slot_derivations : id : name : id populated_from : id s1 : name : s1 populated_from : s1 range : string Object Transformation : Source Object: ds : - id : X s1 : foo - id : Y s1 : bar Target Object: ds : X : s1 : foo Y : s1 : bar Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : ds : name : ds domain_of : - C range : D multivalued : true inlined : true inlined_as_list : false tree_root : true D : name : D attributes : id : name : id identifier : true domain_of : - D required : true s1 : name : s1 domain_of : - D range : string Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : ds : name : ds populated_from : ds cast_collection_as : MultiValuedList D : name : D populated_from : D slot_derivations : id : name : id populated_from : id s1 : name : s1 populated_from : s1 range : string","title":"Combo: test_map_collections[string-string-source_value0-target_value0-True]"},{"location":"specification/compliance/#combo-test_map_collectionsstring-string-source_value1-target_value1-true","text":"Mapping string => string Isomorphic mapping: input must equal output Source Schema : name : types description : Mapping between collection types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : ds : name : ds range : D multivalued : true inlined : true inlined_as_list : false tree_root : true D : name : D attributes : id : name : id identifier : true s1 : name : s1 range : string Transformer Specification : class_derivations : C : name : C slot_derivations : ds : name : ds populated_from : ds cast_collection_as : MultiValuedList D : name : D slot_derivations : id : name : id populated_from : id s1 : name : s1 populated_from : s1 range : string Object Transformation : Source Object: ds : X : s1 : foo Y : s1 : bar Target Object: ds : - id : X s1 : foo - id : Y s1 : bar Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : ds : name : ds domain_of : - C range : D multivalued : true inlined : true inlined_as_list : true tree_root : true D : name : D attributes : id : name : id identifier : true domain_of : - D required : true s1 : name : s1 domain_of : - D range : string Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : ds : name : ds populated_from : ds cast_collection_as : MultiValuedDict dictionary_key : id D : name : D populated_from : D slot_derivations : id : name : id populated_from : id s1 : name : s1 populated_from : s1 range : string","title":"Combo: test_map_collections[string-string-source_value1-target_value1-True]"},{"location":"specification/compliance/#feature-set-test_expr","text":"Test transformation using pythonic expressions. This test uses a simple source schema with two slots ( s1 and s2 ). These are combined using a pythonic expression, to populate the only slot in the target schema (called derived ). The values of s1 and s2 can be numbers or strings. If the expression wraps a slot in {...} then the presence of a None forces the entire expression to be None Limitations: At this time, the framework cannot generate a complete derived schema or inversion for expressions. This will be fixed in future. See also: LinkML Expressions expr : pythonic expression source_object : source object target_value : expected value of slot in target object","title":"Feature Set: test_expr"},{"location":"specification/compliance/#combo-test_exprs1-s2-source_object0-11-combo-test_exprs1-s2-source_object0-11","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer s2 : name : s2 range : integer tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 + s2 Object Transformation : Source Object: s1 : 5 s2 : 6 Target Object: derived : 11 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true","title":"Combo: test_expr[s1 + s2-source_object0-11] {#combo-test_exprs1--s2-source_object0-11}"},{"location":"specification/compliance/#combo-test_exprs1-s2-source_object1-11-combo-test_exprs1-s2-source_object1-11","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer s2 : name : s2 range : integer tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : '{s1} + {s2}' Object Transformation : Source Object: s1 : 5 s2 : 6 Target Object: derived : 11 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true","title":"Combo: test_expr[{s1} + {s2}-source_object1-11] {#combo-test_exprs1--s2-source_object1-11}"},{"location":"specification/compliance/#combo-test_exprs1-s2-source_object2-none-combo-test_exprs1-s2-source_object2-none","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : '{s1} + {s2}' Object Transformation : Source Object: s1 : 5 Target Object: {} Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true","title":"Combo: test_expr[{s1} + {s2}-source_object2-None] {#combo-test_exprs1--s2-source_object2-none}"},{"location":"specification/compliance/#combo-test_exprs1-s2s3-source_object3-11-combo-test_exprs1-s2s3-source_object3-11","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer s2 : name : s2 range : D tree_root : true D : name : D attributes : s3 : name : s3 range : integer Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 + s2.s3 Object Transformation : Source Object: s1 : 5 s2 : s3 : 6 Target Object: derived : 11 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true","title":"Combo: test_expr[s1 + s2.s3-source_object3-11] {#combo-test_exprs1--s2s3-source_object3-11}"},{"location":"specification/compliance/#combo-test_exprs1-s2s3s4-source_object4-11-combo-test_exprs1-s2s3s4-source_object4-11","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer s2 : name : s2 range : D tree_root : true D : name : D attributes : s4 : name : s4 range : integer s3 : name : s3 range : D Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 + s2.s3.s4 Object Transformation : Source Object: s1 : 5 s2 : s3 : s4 : 6 Target Object: derived : 11 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true","title":"Combo: test_expr[s1 + s2.s3.s4-source_object4-11] {#combo-test_exprs1--s2s3s4-source_object4-11}"},{"location":"specification/compliance/#combo-test_exprs1-s2-source_object5-ab-combo-test_exprs1-s2-source_object5-ab","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string s2 : name : s2 range : string tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 + s2 Object Transformation : Source Object: s1 : a s2 : b Target Object: derived : ab Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true","title":"Combo: test_expr[s1 + s2-source_object5-ab] {#combo-test_exprs1--s2-source_object5-ab}"},{"location":"specification/compliance/#combo-test_exprs1-s2-source_object6-target_value6-combo-test_exprs1-s2-source_object6-target_value6","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true s2 : name : s2 range : string multivalued : true tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 + s2 Object Transformation : Source Object: s1 : - a s2 : - b Target Object: derived : - a - b Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true","title":"Combo: test_expr[s1 + s2-source_object6-target_value6] {#combo-test_exprs1--s2-source_object6-target_value6}"},{"location":"specification/compliance/#combo-test_exprlens1-source_object7-1","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : len(s1) Object Transformation : Source Object: s1 : - a Target Object: derived : 1 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true","title":"Combo: test_expr[len(s1)-source_object7-1]"},{"location":"specification/compliance/#combo-test_exprs1-s2-source_object8-true-combo-test_exprs1-s2-source_object8-true","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : integer s2 : name : s2 range : integer tree_root : true Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : derived : name : derived expr : s1 < s2 Object Transformation : Source Object: s1 : 5 s2 : 6 Target Object: derived : true Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : derived : name : derived tree_root : true","title":"Combo: test_expr[s1 \\&lt; s2-source_object8-True] {#combo-test_exprs1--s2-source_object8-true}"},{"location":"specification/compliance/#feature-set-test_simple_unit_conversion","text":"Test unit conversion. This test uses a simple source schema with a single class and a single attribute, where the attribute is described using the units metaslot. The recommended way to describe unit slots in LinkML is with UCUM, but a number of other schemes can be used. We explicitly test for some known cases where UCUM uses non-standard units (e.g. Cel, mo), as well as UCUM-specific syntax (e.g. m.s-1 ) and extensions (e.g. using annotations like {Cre} ). Developers note : to run this test, the units extension should be installed: poetry install -E units This installs the pint framework. source_slot : name of slot in source schema target_slot : name of slot in target schema source_unit : unit of source slot target_unit : unit of target slot source_value : magnitude of source slot (to be converted) target_value : expected magnitude of target slot (output of conversion) err :","title":"Feature Set: test_simple_unit_conversion"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-m-cm-ucum_code-10-1000-none-none-combo-test_simple_unit_conversions1-s1-m-cm-ucum_code-10-1000-none-none","text":"Unit Conversion: 1.0 m => 100.0 cm [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : cm Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : cm Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m target_unit_scheme : ucum_code source_unit : cm","title":"Combo: test_simple_unit_conversion[s1-s1-m-cm-ucum_code-1.0-100.0-None-None] {#combo-test_simple_unit_conversions1-s1-m-cm-ucum_code-10-1000-none-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-m-cm-symbol-10-1000-none-none-combo-test_simple_unit_conversions1-s1-m-cm-symbol-10-1000-none-none","text":"Unit Conversion: 1.0 m => 100.0 cm [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : symbol : m Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : cm Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : cm Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m target_unit_scheme : symbol source_unit : cm","title":"Combo: test_simple_unit_conversion[s1-s1-m-cm-symbol-1.0-100.0-None-None] {#combo-test_simple_unit_conversions1-s1-m-cm-symbol-10-1000-none-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-m-m-ucum_code-10-10-none-none-combo-test_simple_unit_conversions1-s1-m-m-ucum_code-10-10-none-none","text":"Unit Conversion: 1.0 m => 1.0 m [with s1] Isomorphic mapping: input must equal output Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 1.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : m Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m target_unit_scheme : ucum_code source_unit : m","title":"Combo: test_simple_unit_conversion[s1-s1-m-m-ucum_code-1.0-1.0-None-None] {#combo-test_simple_unit_conversions1-s1-m-m-ucum_code-10-10-none-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-a-mo-ucum_code-100-1200-none-none-combo-test_simple_unit_conversions1-s1-a-mo-ucum_code-100-1200-none-none","text":"Unit Conversion: 10.0 a => 120.0 mo [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : a Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : mo Object Transformation : Source Object: s1 : 10.0 Target Object: s1 : 120.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : mo Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : a target_unit_scheme : ucum_code source_unit : mo","title":"Combo: test_simple_unit_conversion[s1-s1-a-mo-ucum_code-10.0-120.0-None-None] {#combo-test_simple_unit_conversions1-s1-a-mo-ucum_code-100-1200-none-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-a-mo-symbol-100-none-undefineduniterror-none-combo-test_simple_unit_conversions1-s1-a-mo-symbol-100-none-undefineduniterror-none","text":"Unit Conversion: 10.0 a => None mo [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : symbol : a Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : mo Object Transformation : Expected Error : UndefinedUnitError Source Object: s1 : 10.0 Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : mo","title":"Combo: test_simple_unit_conversion[s1-s1-a-mo-symbol-10.0-None-UndefinedUnitError-None] {#combo-test_simple_unit_conversions1-s1-a-mo-symbol-100-none-undefineduniterror-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-m-ml-ucum_code-10-none-dimensionalityerror-none-combo-test_simple_unit_conversions1-s1-m-ml-ucum_code-10-none-dimensionalityerror-none","text":"Unit Conversion: 1.0 m => None ml [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : ml Object Transformation : Expected Error : DimensionalityError Source Object: s1 : 1.0 Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : ml","title":"Combo: test_simple_unit_conversion[s1-s1-m-ml-ucum_code-1.0-None-DimensionalityError-None] {#combo-test_simple_unit_conversions1-s1-m-ml-ucum_code-10-none-dimensionalityerror-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-m-pinknoodles-ucum_code-10-none-undefineduniterror-none-combo-test_simple_unit_conversions1-s1-m-pinknoodles-ucum_code-10-none-undefineduniterror-none","text":"Unit Conversion: 1.0 m => None pinknoodles [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : pinknoodles Object Transformation : Expected Error : UndefinedUnitError Source Object: s1 : 1.0 Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : pinknoodles","title":"Combo: test_simple_unit_conversion[s1-s1-m-pinknoodles-ucum_code-1.0-None-UndefinedUnitError-None] {#combo-test_simple_unit_conversions1-s1-m-pinknoodles-ucum_code-10-none-undefineduniterror-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-ml-m-ucum_code-10-none-dimensionalityerror-none-combo-test_simple_unit_conversions1-s1-ml-m-ucum_code-10-none-dimensionalityerror-none","text":"Unit Conversion: 1.0 ml => None m [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : ml Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m Object Transformation : Expected Error : DimensionalityError Source Object: s1 : 1.0 Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : m","title":"Combo: test_simple_unit_conversion[s1-s1-ml-m-ucum_code-1.0-None-DimensionalityError-None] {#combo-test_simple_unit_conversions1-s1-ml-m-ucum_code-10-none-dimensionalityerror-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-pinknoodles-m-ucum_code-10-none-undefineduniterror-none-combo-test_simple_unit_conversions1-s1-pinknoodles-m-ucum_code-10-none-undefineduniterror-none","text":"Unit Conversion: 1.0 pinknoodles => None m [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : pinknoodles Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m Object Transformation : Expected Error : UndefinedUnitError Source Object: s1 : 1.0 Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : m","title":"Combo: test_simple_unit_conversion[s1-s1-pinknoodles-m-ucum_code-1.0-None-UndefinedUnitError-None] {#combo-test_simple_unit_conversions1-s1-pinknoodles-m-ucum_code-10-none-undefineduniterror-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-ms-cms-ucum_code-10-1000-none-none-combo-test_simple_unit_conversions1-s1-ms-cms-ucum_code-10-1000-none-none","text":"Unit Conversion: 1.0 m/s => 100.0 cm/s [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m/s Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : cm/s Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : cm/s Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m/s target_unit_scheme : ucum_code source_unit : cm/s","title":"Combo: test_simple_unit_conversion[s1-s1-m/s-cm/s-ucum_code-1.0-100.0-None-None] {#combo-test_simple_unit_conversions1-s1-ms-cms-ucum_code-10-1000-none-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-ms-1-cms-1-ucum_code-10-1000-none-none-combo-test_simple_unit_conversions1-s1-ms-1-cms-1-ucum_code-10-1000-none-none","text":"Unit Conversion: 1.0 m.s-1 => 100.0 cm.s-1 [with s1] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m.s-1 Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : cm.s-1 Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : cm.s-1 Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m.s-1 target_unit_scheme : ucum_code source_unit : cm.s-1","title":"Combo: test_simple_unit_conversion[s1-s1-m.s-1-cm.s-1-ucum_code-1.0-100.0-None-None] {#combo-test_simple_unit_conversions1-s1-ms-1-cms-1-ucum_code-10-1000-none-none}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-gm2-1-kgm2-1-ucum_code-10-0001-none-httpsgithubcomdalitoucumvertissues8-combo-test_simple_unit_conversions1-s1-gm2-1-kgm2-1-ucum_code-10-0001-none-httpsgithubcomdalitoucumvertissues8","text":"s### Combo: test_simple_unit_conversion[height_in_m-height_in_cm-m-cm-ucum_code-1.0-100.0-None-None] Unit Conversion: 1.0 m => 100.0 cm [with height_in_m] Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : height_in_m : name : height_in_m range : float unit : ucum_code : m Transformer Specification : class_derivations : C : name : C slot_derivations : height_in_cm : name : height_in_cm populated_from : height_in_m unit_conversion : target_unit : cm Object Transformation : Source Object: height_in_m : 1.0 Target Object: height_in_cm : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : height_in_cm : name : height_in_cm domain_of : - C range : float unit : ucum_code : cm Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : height_in_m : name : height_in_m populated_from : height_in_cm unit_conversion : target_unit : m target_unit_scheme : ucum_code source_unit : cm","title":"Combo: test_simple_unit_conversion[s1-s1-g.m2-1-kg.m2-1-ucum_code-1.0-0.001-None-https://github.com/dalito/ucumvert/issues/8] {#combo-test_simple_unit_conversions1-s1-gm2-1-kgm2-1-ucum_code-10-0001-none-httpsgithubcomdalitoucumvertissues8}"},{"location":"specification/compliance/#combo-test_simple_unit_conversions1-s1-mh2o35cel-mh2o35cel-ucum_code-10-10-none-none-combo-test_simple_unit_conversions1-s1-mh2o35cel-mh2o35cel-ucum_code-10-10-none-none","text":"Unit Conversion: 1.0 m[H2O]{35Cel} => 1.0 m[H2O]{35Cel} [with s1] Isomorphic mapping: input must equal output Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : float unit : ucum_code : m[H2O]{35Cel} Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m[H2O]{35Cel} Object Transformation : Source Object: s1 : 1.0 Target Object: s1 : 1.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : float unit : ucum_code : m[H2O]{35Cel} Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 unit_conversion : target_unit : m[H2O]{35Cel} target_unit_scheme : ucum_code source_unit : m[H2O]{35Cel}","title":"Combo: test_simple_unit_conversion[s1-s1-m[H2O]{35Cel}-m[H2O]{35Cel}-ucum_code-1.0-1.0-None-None] {#combo-test_simple_unit_conversions1-s1-mh2o35cel-mh2o35cel-ucum_code-10-10-none-none}"},{"location":"specification/compliance/#feature-set-test_complex_unit_conversion","text":"Test unit conversion, from complex object to simple scalar. An example complex object would be an object with separate attributes for representing magnitude (value) and unit. For example magnitude: 1.0, unit: \"m\" source_unit : unit of source slot target_unit : unit of target slot source_value : magnitude of source slot (to be converted) target_value : expected magnitude of target slot (output of conversion) roundtrip_object : expected value of passing target object back through inverted transformation err : True if expected to raise an Error","title":"Feature Set: test_complex_unit_conversion"},{"location":"specification/compliance/#combo-test_complex_unit_conversionm-cm-10-1000-roundtrip_object0-none-combo-test_complex_unit_conversionm-cm-10-1000-roundtrip_object0-none","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Q : name : Q attributes : magnitude : name : magnitude range : float unit : name : unit range : string C : name : C attributes : q : name : q range : Q tree_root : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : q_in_cm : name : q_in_cm populated_from : q unit_conversion : target_unit : cm source_unit_slot : unit source_magnitude_slot : magnitude Object Transformation : Source Object: q : magnitude : 1.0 unit : m Target Object: q_in_cm : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : q_in_cm : name : q_in_cm domain_of : - C range : Q unit : ucum_code : cm tree_root : true Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : q : name : q populated_from : q_in_cm unit_conversion : source_unit : cm target_unit_slot : unit target_magnitude_slot : magnitude","title":"Combo: test_complex_unit_conversion[m-cm-1.0-100.0-roundtrip_object0-None] {#combo-test_complex_unit_conversionm-cm-10-1000-roundtrip_object0-none}"},{"location":"specification/compliance/#combo-test_complex_unit_conversioncm-cm-1000-1000-roundtrip_object1-none-combo-test_complex_unit_conversioncm-cm-1000-1000-roundtrip_object1-none","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Q : name : Q attributes : magnitude : name : magnitude range : float unit : name : unit range : string C : name : C attributes : q : name : q range : Q tree_root : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : q_in_cm : name : q_in_cm populated_from : q unit_conversion : target_unit : cm source_unit_slot : unit source_magnitude_slot : magnitude Object Transformation : Source Object: q : magnitude : 100.0 unit : cm Target Object: q_in_cm : 100.0 Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : q_in_cm : name : q_in_cm domain_of : - C range : Q unit : ucum_code : cm tree_root : true Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : q : name : q populated_from : q_in_cm unit_conversion : source_unit : cm target_unit_slot : unit target_magnitude_slot : magnitude","title":"Combo: test_complex_unit_conversion[cm-cm-100.0-100.0-roundtrip_object1-None] {#combo-test_complex_unit_conversioncm-cm-1000-1000-roundtrip_object1-none}"},{"location":"specification/compliance/#combo-test_complex_unit_conversioncm-ml-1000-none-none-dimensionalityerror-combo-test_complex_unit_conversioncm-ml-1000-none-none-dimensionalityerror","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Q : name : Q attributes : magnitude : name : magnitude range : float unit : name : unit range : string C : name : C attributes : q : name : q range : Q tree_root : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : q_in_ml : name : q_in_ml populated_from : q unit_conversion : target_unit : ml source_unit_slot : unit source_magnitude_slot : magnitude Object Transformation : Expected Error : DimensionalityError Source Object: q : magnitude : 100.0 unit : cm Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : q_in_ml : name : q_in_ml domain_of : - C range : Q unit : ucum_code : ml tree_root : true","title":"Combo: test_complex_unit_conversion[cm-ml-100.0-None-None-DimensionalityError] {#combo-test_complex_unit_conversioncm-ml-1000-none-none-dimensionalityerror}"},{"location":"specification/compliance/#combo-test_complex_unit_conversioncm-pinknoodles-1000-none-none-undefineduniterror-combo-test_complex_unit_conversioncm-pinknoodles-1000-none-none-undefineduniterror","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Q : name : Q attributes : magnitude : name : magnitude range : float unit : name : unit range : string C : name : C attributes : q : name : q range : Q tree_root : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : q_in_pinknoodles : name : q_in_pinknoodles populated_from : q unit_conversion : target_unit : pinknoodles source_unit_slot : unit source_magnitude_slot : magnitude Object Transformation : Expected Error : UndefinedUnitError Source Object: q : magnitude : 100.0 unit : cm Target Object: null ... Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : q_in_pinknoodles : name : q_in_pinknoodles domain_of : - C range : Q unit : ucum_code : pinknoodles tree_root : true","title":"Combo: test_complex_unit_conversion[cm-pinknoodles-100.0-None-None-UndefinedUnitError] {#combo-test_complex_unit_conversioncm-pinknoodles-1000-none-none-undefineduniterror}"},{"location":"specification/compliance/#feature-set-test_stringify","text":"Test compaction of multivalued slots into a string. Stringification is primarily intended for mapping from complex nested formats to simple tabular TSV formats, where some of the following methodologies can be used: flattening lists using an (internal) delimiter flattening lists or more complex objects using JSON or YAML For example, [\"a\", \"b\"] => \"a,b\" As a convention we use s1_verbatim as a slot/attribute name for the stringified form. syntax : SerializationSyntaxType delimiter : delimiter to use in stringification source_value : source value (a list) target_value : expected value of slot in target object (a string)","title":"Feature Set: test_stringify"},{"location":"specification/compliance/#combo-test_stringifynone-source_value0-ab","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : delimiter : ',' Object Transformation : Source Object: s1 : - a - b Target Object: s1_verbatim : a,b Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : delimiter : ',' reversed : true Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS STRING_AGG(s1, \\',\\') FROM D;","title":"Combo: test_stringify[None-,-source_value0-a,b]"},{"location":"specification/compliance/#combo-test_stringifynone-source_value1-ab","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : delimiter : '|' Object Transformation : Source Object: s1 : - a - b Target Object: s1_verbatim : a|b Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : delimiter : '|' reversed : true Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS STRING_AGG(s1, \\'|\\') FROM D;","title":"Combo: test_stringify[None-|-source_value1-a|b]"},{"location":"specification/compliance/#combo-test_stringifynone-source_value2-a","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : delimiter : '|' Object Transformation : Source Object: s1 : - a Target Object: s1_verbatim : a Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : delimiter : '|' reversed : true Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS STRING_AGG(s1, \\'|\\') FROM D;","title":"Combo: test_stringify[None-|-source_value2-a]"},{"location":"specification/compliance/#combo-test_stringifynone-source_value3-","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : delimiter : '|' Object Transformation : Source Object: {} Target Object: s1_verbatim : '' Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : delimiter : '|' reversed : true Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS STRING_AGG(s1, \\'|\\') FROM D;","title":"Combo: test_stringify[None-|-source_value3-]"},{"location":"specification/compliance/#combo-test_stringifyjson-none-source_value4-a-b","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : syntax : JSON Object Transformation : Source Object: s1 : - a - b Target Object: s1_verbatim : '[\"a\", \"b\"]' Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : reversed : true syntax : JSON Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS CAST(s1 AS TEXT) FROM D;","title":"Combo: test_stringify[JSON-None-source_value4-[\\\"a\\\", \\\"b\\\"]]"},{"location":"specification/compliance/#combo-test_stringifyjson-none-source_value5-","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : syntax : JSON Object Transformation : Source Object: {} Target Object: s1_verbatim : '[]' Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : reversed : true syntax : JSON Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS CAST(s1 AS TEXT) FROM D;","title":"Combo: test_stringify[JSON-None-source_value5-[]]"},{"location":"specification/compliance/#combo-test_stringifyyaml-none-source_value6-a-b","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C attributes : s1 : name : s1 range : string multivalued : true Transformer Specification : class_derivations : D : name : D populated_from : C slot_derivations : s1_verbatim : name : s1_verbatim populated_from : s1 stringification : syntax : YAML Object Transformation : Source Object: s1 : - a - b Target Object: s1_verbatim : '[a, b]' Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : D : name : D attributes : s1_verbatim : name : s1_verbatim domain_of : - C range : string multivalued : false Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : D slot_derivations : s1 : name : s1 populated_from : s1_verbatim stringification : reversed : true syntax : YAML Compiled Specification (SQLCompiler) : INSERT INTO D SELECT s1_verbatim AS s1 FROM D;","title":"Combo: test_stringify[YAML-None-source_value6-[a, b]]"},{"location":"specification/compliance/#feature-set-test_isomorphic","text":"Test mapping a schema to an identical schema (i.e copy). This also tests for the ability to recursively descend a nested structure. source_object : use_expr : supply_source_schema : TODO: always True for now","title":"Feature Set: test_isomorphic"},{"location":"specification/compliance/#combo-test_isomorphictrue-true-source_object0","text":"Source Schema : name : isomorphic id : isomorphic imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Container : name : Container attributes : c_list : name : c_list range : C multivalued : true d : name : d range : D tree_root : true C : name : C attributes : s1 : name : s1 range : string s2 : name : s2 range : string D : name : D attributes : s3 : name : s3 range : string Transformer Specification : class_derivations : Container : name : Container populated_from : Container slot_derivations : c_list : name : c_list populated_from : c_list range : C d : name : d populated_from : d range : D C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 s2 : name : s2 populated_from : s2 D : name : D populated_from : D slot_derivations : s3 : name : s3 expr : s3 Object Transformation : Source Object: c_list : - s1 : a s2 : b - s1 : c s2 : d d : s3 : e Target Object: c_list : - s1 : a s2 : b - s1 : c s2 : d d : s3 : e Target Schema (Derived) : name : isomorphic-derived id : isomorphic-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : isomorphic-derived/ classes : Container : name : Container attributes : c_list : name : c_list domain_of : - Container range : C multivalued : true d : name : d domain_of : - Container range : D tree_root : true C : name : C attributes : s1 : name : s1 domain_of : - C range : string s2 : name : s2 domain_of : - C range : string D : name : D attributes : s3 : name : s3 domain_of : - D range : string Inverted Transformation Specification (Derived): class_derivations : Container : name : Container populated_from : Container slot_derivations : c_list : name : c_list populated_from : c_list range : C d : name : d populated_from : d range : D C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 s2 : name : s2 populated_from : s2 D : name : D populated_from : D slot_derivations : s3 : name : s3 populated_from : s3","title":"Combo: test_isomorphic[True-True-source_object0]"},{"location":"specification/compliance/#combo-test_isomorphictrue-false-source_object0","text":"Source Schema : name : isomorphic id : isomorphic imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : Container : name : Container attributes : c_list : name : c_list range : C multivalued : true d : name : d range : D tree_root : true C : name : C attributes : s1 : name : s1 range : string s2 : name : s2 range : string D : name : D attributes : s3 : name : s3 range : string Transformer Specification : class_derivations : Container : name : Container populated_from : Container slot_derivations : c_list : name : c_list populated_from : c_list range : C d : name : d populated_from : d range : D C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 s2 : name : s2 populated_from : s2 D : name : D populated_from : D slot_derivations : s3 : name : s3 populated_from : s3 Object Transformation : Source Object: c_list : - s1 : a s2 : b - s1 : c s2 : d d : s3 : e Target Object: c_list : - s1 : a s2 : b - s1 : c s2 : d d : s3 : e Target Schema (Derived) : name : isomorphic-derived id : isomorphic-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : isomorphic-derived/ classes : Container : name : Container attributes : c_list : name : c_list domain_of : - Container range : C multivalued : true d : name : d domain_of : - Container range : D tree_root : true C : name : C attributes : s1 : name : s1 domain_of : - C range : string s2 : name : s2 domain_of : - C range : string D : name : D attributes : s3 : name : s3 domain_of : - D range : string Inverted Transformation Specification (Derived): class_derivations : Container : name : Container populated_from : Container slot_derivations : c_list : name : c_list populated_from : c_list range : C d : name : d populated_from : d range : D C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 s2 : name : s2 populated_from : s2 D : name : D populated_from : D slot_derivations : s3 : name : s3 populated_from : s3","title":"Combo: test_isomorphic[True-False-source_object0]"},{"location":"specification/compliance/#feature-set-test_join","text":"Test joining two objects into a single object, aka denormalization. source_object : normalized source object target_object : denormalized target object inlined : True if the source objects are inlined","title":"Feature Set: test_join"},{"location":"specification/compliance/#combo-test_joinsource_object0-target_object0-true","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : R : name : R attributes : s1 : name : s1 range : E inlined : true s2 : name : s2 range : E inlined : true tree_root : true E : name : E attributes : id : name : id identifier : true range : string name : name : name range : string Transformer Specification : class_derivations : R : name : R populated_from : R slot_derivations : s1_id : name : s1_id expr : s1.id s1_name : name : s1_name expr : s1.name s2_id : name : s2_id expr : s2.id s2_name : name : s2_name expr : s2.name Object Transformation : Source Object: s1 : id : x1 name : foo s2 : id : x2 name : bar Target Object: s1_id : x1 s1_name : foo s2_id : x2 s2_name : bar Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : R : name : R attributes : s1_id : name : s1_id s1_name : name : s1_name s2_id : name : s2_id s2_name : name : s2_name tree_root : true","title":"Combo: test_join[source_object0-target_object0-True]"},{"location":"specification/compliance/#combo-test_joinsource_object0-target_object0-false","text":"Source Schema : name : types id : types imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : R : name : R attributes : s1 : name : s1 range : E inlined : false s2 : name : s2 range : E inlined : false tree_root : false E : name : E attributes : id : name : id identifier : true range : string name : name : name range : string Container : name : Container attributes : r_list : name : r_list range : R multivalued : true e_list : name : e_list range : E multivalued : true inlined_as_list : true tree_root : true Transformer Specification : class_derivations : R : name : R populated_from : R slot_derivations : s1_id : name : s1_id expr : s1.id s1_name : name : s1_name expr : s1.name s2_id : name : s2_id expr : s2.id s2_name : name : s2_name expr : s2.name Container : name : Container populated_from : Container slot_derivations : r_list : name : r_list populated_from : r_list Object Transformation : Source Object: r_list : - s1 : x1 s2 : x2 e_list : - id : x1 name : foo - id : x2 name : bar Target Object: r_list : - s1_id : x1 s1_name : foo s2_id : x2 s2_name : bar Target Schema (Derived) : name : types-derived id : types-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : types-derived/ classes : R : name : R attributes : s1_id : name : s1_id s1_name : name : s1_name s2_id : name : s2_id s2_name : name : s2_name tree_root : false Container : name : Container attributes : r_list : name : r_list domain_of : - Container range : R multivalued : true tree_root : true","title":"Combo: test_join[source_object0-target_object0-False]"},{"location":"specification/compliance/#feature-set-test_map_enum","text":"Test mapping between enum values. Currently this only supports simple dictionary-style mapping between permissible values, akin to SSSOM, but in future additional expressivity will be supported, including: mapping ranges to categorical values boolean/branching logic source_value : source enum permissible value to be mapped mapping : mapping from source to target enum permissible values target_value : expected target enum permissible value","title":"Feature Set: test_map_enum"},{"location":"specification/compliance/#combo-test_map_enuma-mapping0-b-false","text":"Source Schema : name : enums id : enums imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 range : E Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E mirror_source : false populated_from : E permissible_value_derivations : B : name : B populated_from : A Object Transformation : Source Object: s1 : A Target Object: s1 : B Target Schema (Derived) : name : enums-derived id : enums-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : enums-derived/ enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : E Inverted Transformation Specification (Derived): class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E populated_from : E permissible_value_derivations : A : name : A populated_from : B","title":"Combo: test_map_enum[A-mapping0-B-False]"},{"location":"specification/compliance/#combo-test_map_enumz-mapping1-none-false","text":"Source Schema : name : enums id : enums imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 range : E Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E mirror_source : false populated_from : E permissible_value_derivations : B : name : B populated_from : A Object Transformation : Source Object: s1 : Z Target Object: {} Target Schema (Derived) : name : enums-derived id : enums-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : enums-derived/ enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : E","title":"Combo: test_map_enum[Z-mapping1-None-False]"},{"location":"specification/compliance/#combo-test_map_enumc-mapping2-c-true","text":"Source Schema : name : enums id : enums imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 range : E Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E mirror_source : true populated_from : E permissible_value_derivations : B : name : B populated_from : A s### Combo: test_map_enum[A-mapping3-B-False] Source Schema : name : enums id : enums imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 range : E Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E mirror_source : false populated_from : E permissible_value_derivations : B : name : B sources : - A - C Object Transformation : Source Object: s1 : A Target Object: s1 : B Target Schema (Derived) : name : enums-derived id : enums-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : enums-derived/ enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : E","title":"Combo: test_map_enum[C-mapping2-C-True]"},{"location":"specification/compliance/#combo-test_map_enumc-mapping4-b-false","text":"Source Schema : name : enums id : enums imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 range : E Transformer Specification : class_derivations : C : name : C slot_derivations : s1 : name : s1 populated_from : s1 enum_derivations : E : name : E mirror_source : false populated_from : E permissible_value_derivations : B : name : B sources : - A - C Object Transformation : Source Object: s1 : C Target Object: s1 : B Target Schema (Derived) : name : enums-derived id : enums-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : enums-derived/ enums : E : name : E permissible_values : A : text : A B : text : B C : text : C classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : E","title":"Combo: test_map_enum[C-mapping4-B-False]"},{"location":"specification/compliance/#feature-set-test_inheritance","text":"Test inheritance. Transformation specifications can utilize inheritance, in the same way that LinkML schemas can. is_a : use is_as instead of mixins in test schema flatten : roll down inherited slots","title":"Feature Set: test_inheritance"},{"location":"specification/compliance/#combo-test_inheritancefalse-true","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C is_a : D attributes : s1 : name : s1 range : integer tree_root : true D : name : D attributes : s2 : name : s2 range : integer Transformer Specification : class_derivations : C : name : C is_a : D populated_from : C slot_derivations : s1 : name : s1 expr : s1 + 1 D : name : D populated_from : D slot_derivations : s2 : name : s2 expr : s2 + 1 Object Transformation : Source Object: s1 : 1 s2 : 2 Target Object: s1 : 2 s2 : 3 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C is_a : D attributes : s1 : name : s1 domain_of : - C range : integer tree_root : true D : name : D attributes : s2 : name : s2 domain_of : - D range : integer","title":"Combo: test_inheritance[False-True]"},{"location":"specification/compliance/#combo-test_inheritancefalse-false","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C mixins : - D attributes : s1 : name : s1 range : integer tree_root : true D : name : D attributes : s2 : name : s2 range : integer Transformer Specification : class_derivations : C : name : C mixins : - D populated_from : C slot_derivations : s1 : name : s1 expr : s1 + 1 D : name : D populated_from : D slot_derivations : s2 : name : s2 expr : s2 + 1 Object Transformation : Source Object: s1 : 1 s2 : 2 Target Object: s1 : 2 s2 : 3 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C mixins : - D attributes : s1 : name : s1 domain_of : - C range : integer tree_root : true D : name : D attributes : s2 : name : s2 domain_of : - D range : integer","title":"Combo: test_inheritance[False-False]"},{"location":"specification/compliance/#combo-test_inheritancetrue-true","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C is_a : D attributes : s1 : name : s1 range : integer tree_root : true D : name : D attributes : s2 : name : s2 range : integer Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 expr : s1 + 1 s2 : name : s2 expr : s2 + 1 Object Transformation : Source Object: s1 : 1 s2 : 2 Target Object: s1 : 2 s2 : 3 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer s2 : name : s2 domain_of : - D range : integer tree_root : true","title":"Combo: test_inheritance[True-True]"},{"location":"specification/compliance/#combo-test_inheritancetrue-false","text":"Source Schema : name : expr id : expr imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : test classes : C : name : C mixins : - D attributes : s1 : name : s1 range : integer tree_root : true D : name : D attributes : s2 : name : s2 range : integer Transformer Specification : class_derivations : C : name : C populated_from : C slot_derivations : s1 : name : s1 expr : s1 + 1 s2 : name : s2 expr : s2 + 1 Object Transformation : Source Object: s1 : 1 s2 : 2 Target Object: s1 : 2 s2 : 3 Target Schema (Derived) : name : expr-derived id : expr-derived imports : - linkml:types prefixes : linkml : prefix_prefix : linkml prefix_reference : https://w3id.org/linkml/ test : prefix_prefix : test prefix_reference : http://example.org/test/ default_prefix : expr-derived/ classes : C : name : C attributes : s1 : name : s1 domain_of : - C range : integer s2 : name : s2 domain_of : - D range : integer tree_root : true . 55 passed, 2 skipped, 83 warnings in 4.60s","title":"Combo: test_inheritance[True-False]"}]}